
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model UserOrganization
 * 
 */
export type UserOrganization = $Result.DefaultSelection<Prisma.$UserOrganizationPayload>
/**
 * Model Proposal
 * 
 */
export type Proposal = $Result.DefaultSelection<Prisma.$ProposalPayload>
/**
 * Model History
 * 
 */
export type History = $Result.DefaultSelection<Prisma.$HistoryPayload>
/**
 * Model Person
 * 
 */
export type Person = $Result.DefaultSelection<Prisma.$PersonPayload>
/**
 * Model ProposalService
 * 
 */
export type ProposalService = $Result.DefaultSelection<Prisma.$ProposalServicePayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model ProposalCost
 * 
 */
export type ProposalCost = $Result.DefaultSelection<Prisma.$ProposalCostPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model DateEvent
 * 
 */
export type DateEvent = $Result.DefaultSelection<Prisma.$DateEventPayload>
/**
 * Model Venue
 * 
 */
export type Venue = $Result.DefaultSelection<Prisma.$VenuePayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model OwnerVenue
 * 
 */
export type OwnerVenue = $Result.DefaultSelection<Prisma.$OwnerVenuePayload>
/**
 * Model Owner
 * 
 */
export type Owner = $Result.DefaultSelection<Prisma.$OwnerPayload>
/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model Text
 * 
 */
export type Text = $Result.DefaultSelection<Prisma.$TextPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model Clause
 * 
 */
export type Clause = $Result.DefaultSelection<Prisma.$ClausePayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ProposalType: {
  EVENT: 'EVENT',
  OVERNIGHT: 'OVERNIGHT',
  PRODUCTION: 'PRODUCTION',
  BARTER: 'BARTER',
  OTHER: 'OTHER'
};

export type ProposalType = (typeof ProposalType)[keyof typeof ProposalType]


export const TrafficSource: {
  AIRBNB: 'AIRBNB',
  GOOGLE: 'GOOGLE',
  INSTAGRAM: 'INSTAGRAM',
  TIKTOK: 'TIKTOK',
  OTHER: 'OTHER',
  FRIEND: 'FRIEND',
  FACEBOOK: 'FACEBOOK'
};

export type TrafficSource = (typeof TrafficSource)[keyof typeof TrafficSource]


export const PersonType: {
  GUEST: 'GUEST',
  WORKER: 'WORKER'
};

export type PersonType = (typeof PersonType)[keyof typeof PersonType]


export const PaymentMethod: {
  PIX: 'PIX',
  CREDIT_CARD: 'CREDIT_CARD'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const ProposalName: {
  RECEPTIONIST: 'RECEPTIONIST',
  SECURITY: 'SECURITY',
  CLEANER: 'CLEANER'
};

export type ProposalName = (typeof ProposalName)[keyof typeof ProposalName]


export const ExpenseType: {
  WEEKLY: 'WEEKLY',
  ANNUAL: 'ANNUAL',
  MONTHLY: 'MONTHLY',
  BIWEEKLY: 'BIWEEKLY',
  SPORADIC: 'SPORADIC'
};

export type ExpenseType = (typeof ExpenseType)[keyof typeof ExpenseType]


export const ExpenseCategory: {
  TAX: 'TAX',
  INVESTMENT: 'INVESTMENT',
  MAINTENANCE: 'MAINTENANCE',
  ADVERTISING: 'ADVERTISING'
};

export type ExpenseCategory = (typeof ExpenseCategory)[keyof typeof ExpenseCategory]


export const NotificationType: {
  VISIT: 'VISIT',
  EVENT: 'EVENT',
  OTHER: 'OTHER',
  BARTER: 'BARTER',
  PROPOSAL: 'PROPOSAL',
  OVERNIGHT: 'OVERNIGHT',
  PRODUCTION: 'PRODUCTION'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const DateEventType: {
  VISIT: 'VISIT',
  EVENT: 'EVENT',
  OTHER: 'OTHER',
  BARTER: 'BARTER',
  PROPOSAL: 'PROPOSAL',
  OVERNIGHT: 'OVERNIGHT',
  PRODUCTION: 'PRODUCTION'
};

export type DateEventType = (typeof DateEventType)[keyof typeof DateEventType]


export const PricingModel: {
  PER_PERSON: 'PER_PERSON',
  PER_DAY: 'PER_DAY'
};

export type PricingModel = (typeof PricingModel)[keyof typeof PricingModel]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ProposalType = $Enums.ProposalType

export const ProposalType: typeof $Enums.ProposalType

export type TrafficSource = $Enums.TrafficSource

export const TrafficSource: typeof $Enums.TrafficSource

export type PersonType = $Enums.PersonType

export const PersonType: typeof $Enums.PersonType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type ProposalName = $Enums.ProposalName

export const ProposalName: typeof $Enums.ProposalName

export type ExpenseType = $Enums.ExpenseType

export const ExpenseType: typeof $Enums.ExpenseType

export type ExpenseCategory = $Enums.ExpenseCategory

export const ExpenseCategory: typeof $Enums.ExpenseCategory

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type DateEventType = $Enums.DateEventType

export const DateEventType: typeof $Enums.DateEventType

export type PricingModel = $Enums.PricingModel

export const PricingModel: typeof $Enums.PricingModel

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more RefreshTokens
 * const refreshTokens = await prisma.refreshToken.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more RefreshTokens
   * const refreshTokens = await prisma.refreshToken.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.userOrganization`: Exposes CRUD operations for the **UserOrganization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOrganizations
    * const userOrganizations = await prisma.userOrganization.findMany()
    * ```
    */
  get userOrganization(): Prisma.UserOrganizationDelegate<ExtArgs>;

  /**
   * `prisma.proposal`: Exposes CRUD operations for the **Proposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proposals
    * const proposals = await prisma.proposal.findMany()
    * ```
    */
  get proposal(): Prisma.ProposalDelegate<ExtArgs>;

  /**
   * `prisma.history`: Exposes CRUD operations for the **History** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Histories
    * const histories = await prisma.history.findMany()
    * ```
    */
  get history(): Prisma.HistoryDelegate<ExtArgs>;

  /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<ExtArgs>;

  /**
   * `prisma.proposalService`: Exposes CRUD operations for the **ProposalService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProposalServices
    * const proposalServices = await prisma.proposalService.findMany()
    * ```
    */
  get proposalService(): Prisma.ProposalServiceDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.proposalCost`: Exposes CRUD operations for the **ProposalCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProposalCosts
    * const proposalCosts = await prisma.proposalCost.findMany()
    * ```
    */
  get proposalCost(): Prisma.ProposalCostDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.dateEvent`: Exposes CRUD operations for the **DateEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DateEvents
    * const dateEvents = await prisma.dateEvent.findMany()
    * ```
    */
  get dateEvent(): Prisma.DateEventDelegate<ExtArgs>;

  /**
   * `prisma.venue`: Exposes CRUD operations for the **Venue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venues
    * const venues = await prisma.venue.findMany()
    * ```
    */
  get venue(): Prisma.VenueDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.ownerVenue`: Exposes CRUD operations for the **OwnerVenue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerVenues
    * const ownerVenues = await prisma.ownerVenue.findMany()
    * ```
    */
  get ownerVenue(): Prisma.OwnerVenueDelegate<ExtArgs>;

  /**
   * `prisma.owner`: Exposes CRUD operations for the **Owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owners
    * const owners = await prisma.owner.findMany()
    * ```
    */
  get owner(): Prisma.OwnerDelegate<ExtArgs>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs>;

  /**
   * `prisma.text`: Exposes CRUD operations for the **Text** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Texts
    * const texts = await prisma.text.findMany()
    * ```
    */
  get text(): Prisma.TextDelegate<ExtArgs>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs>;

  /**
   * `prisma.clause`: Exposes CRUD operations for the **Clause** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clauses
    * const clauses = await prisma.clause.findMany()
    * ```
    */
  get clause(): Prisma.ClauseDelegate<ExtArgs>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    RefreshToken: 'RefreshToken',
    Session: 'Session',
    User: 'User',
    Organization: 'Organization',
    UserOrganization: 'UserOrganization',
    Proposal: 'Proposal',
    History: 'History',
    Person: 'Person',
    ProposalService: 'ProposalService',
    Service: 'Service',
    Payment: 'Payment',
    ProposalCost: 'ProposalCost',
    Expense: 'Expense',
    Notification: 'Notification',
    DateEvent: 'DateEvent',
    Venue: 'Venue',
    Contact: 'Contact',
    OwnerVenue: 'OwnerVenue',
    Owner: 'Owner',
    Image: 'Image',
    Text: 'Text',
    Question: 'Question',
    Contract: 'Contract',
    Clause: 'Clause',
    Schedule: 'Schedule'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "refreshToken" | "session" | "user" | "organization" | "userOrganization" | "proposal" | "history" | "person" | "proposalService" | "service" | "payment" | "proposalCost" | "expense" | "notification" | "dateEvent" | "venue" | "contact" | "ownerVenue" | "owner" | "image" | "text" | "question" | "contract" | "clause" | "schedule"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      UserOrganization: {
        payload: Prisma.$UserOrganizationPayload<ExtArgs>
        fields: Prisma.UserOrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOrganizationPayload>
          }
          findFirst: {
            args: Prisma.UserOrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOrganizationPayload>
          }
          findMany: {
            args: Prisma.UserOrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOrganizationPayload>[]
          }
          create: {
            args: Prisma.UserOrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOrganizationPayload>
          }
          createMany: {
            args: Prisma.UserOrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserOrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOrganizationPayload>
          }
          update: {
            args: Prisma.UserOrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOrganizationPayload>
          }
          deleteMany: {
            args: Prisma.UserOrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserOrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserOrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOrganizationPayload>
          }
          aggregate: {
            args: Prisma.UserOrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserOrganization>
          }
          groupBy: {
            args: Prisma.UserOrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserOrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<UserOrganizationCountAggregateOutputType> | number
          }
        }
      }
      Proposal: {
        payload: Prisma.$ProposalPayload<ExtArgs>
        fields: Prisma.ProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findFirst: {
            args: Prisma.ProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findMany: {
            args: Prisma.ProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          create: {
            args: Prisma.ProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          createMany: {
            args: Prisma.ProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          update: {
            args: Prisma.ProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          deleteMany: {
            args: Prisma.ProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          aggregate: {
            args: Prisma.ProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposal>
          }
          groupBy: {
            args: Prisma.ProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalCountAggregateOutputType> | number
          }
        }
      }
      History: {
        payload: Prisma.$HistoryPayload<ExtArgs>
        fields: Prisma.HistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          findFirst: {
            args: Prisma.HistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          findMany: {
            args: Prisma.HistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>[]
          }
          create: {
            args: Prisma.HistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          createMany: {
            args: Prisma.HistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          update: {
            args: Prisma.HistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          deleteMany: {
            args: Prisma.HistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          aggregate: {
            args: Prisma.HistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistory>
          }
          groupBy: {
            args: Prisma.HistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistoryCountArgs<ExtArgs>
            result: $Utils.Optional<HistoryCountAggregateOutputType> | number
          }
        }
      }
      Person: {
        payload: Prisma.$PersonPayload<ExtArgs>
        fields: Prisma.PersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findFirst: {
            args: Prisma.PersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findMany: {
            args: Prisma.PersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          create: {
            args: Prisma.PersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          createMany: {
            args: Prisma.PersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          update: {
            args: Prisma.PersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          deleteMany: {
            args: Prisma.PersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          aggregate: {
            args: Prisma.PersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerson>
          }
          groupBy: {
            args: Prisma.PersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonCountArgs<ExtArgs>
            result: $Utils.Optional<PersonCountAggregateOutputType> | number
          }
        }
      }
      ProposalService: {
        payload: Prisma.$ProposalServicePayload<ExtArgs>
        fields: Prisma.ProposalServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalServicePayload>
          }
          findFirst: {
            args: Prisma.ProposalServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalServicePayload>
          }
          findMany: {
            args: Prisma.ProposalServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalServicePayload>[]
          }
          create: {
            args: Prisma.ProposalServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalServicePayload>
          }
          createMany: {
            args: Prisma.ProposalServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProposalServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalServicePayload>
          }
          update: {
            args: Prisma.ProposalServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalServicePayload>
          }
          deleteMany: {
            args: Prisma.ProposalServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProposalServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalServicePayload>
          }
          aggregate: {
            args: Prisma.ProposalServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposalService>
          }
          groupBy: {
            args: Prisma.ProposalServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalServiceCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      ProposalCost: {
        payload: Prisma.$ProposalCostPayload<ExtArgs>
        fields: Prisma.ProposalCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCostPayload>
          }
          findFirst: {
            args: Prisma.ProposalCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCostPayload>
          }
          findMany: {
            args: Prisma.ProposalCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCostPayload>[]
          }
          create: {
            args: Prisma.ProposalCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCostPayload>
          }
          createMany: {
            args: Prisma.ProposalCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProposalCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCostPayload>
          }
          update: {
            args: Prisma.ProposalCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCostPayload>
          }
          deleteMany: {
            args: Prisma.ProposalCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProposalCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalCostPayload>
          }
          aggregate: {
            args: Prisma.ProposalCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposalCost>
          }
          groupBy: {
            args: Prisma.ProposalCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalCostCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalCostCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      DateEvent: {
        payload: Prisma.$DateEventPayload<ExtArgs>
        fields: Prisma.DateEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DateEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DateEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DateEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DateEventPayload>
          }
          findFirst: {
            args: Prisma.DateEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DateEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DateEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DateEventPayload>
          }
          findMany: {
            args: Prisma.DateEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DateEventPayload>[]
          }
          create: {
            args: Prisma.DateEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DateEventPayload>
          }
          createMany: {
            args: Prisma.DateEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DateEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DateEventPayload>
          }
          update: {
            args: Prisma.DateEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DateEventPayload>
          }
          deleteMany: {
            args: Prisma.DateEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DateEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DateEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DateEventPayload>
          }
          aggregate: {
            args: Prisma.DateEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDateEvent>
          }
          groupBy: {
            args: Prisma.DateEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<DateEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.DateEventCountArgs<ExtArgs>
            result: $Utils.Optional<DateEventCountAggregateOutputType> | number
          }
        }
      }
      Venue: {
        payload: Prisma.$VenuePayload<ExtArgs>
        fields: Prisma.VenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findFirst: {
            args: Prisma.VenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findMany: {
            args: Prisma.VenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          create: {
            args: Prisma.VenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          createMany: {
            args: Prisma.VenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          update: {
            args: Prisma.VenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          deleteMany: {
            args: Prisma.VenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          aggregate: {
            args: Prisma.VenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenue>
          }
          groupBy: {
            args: Prisma.VenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueCountArgs<ExtArgs>
            result: $Utils.Optional<VenueCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      OwnerVenue: {
        payload: Prisma.$OwnerVenuePayload<ExtArgs>
        fields: Prisma.OwnerVenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerVenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerVenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVenuePayload>
          }
          findFirst: {
            args: Prisma.OwnerVenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerVenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVenuePayload>
          }
          findMany: {
            args: Prisma.OwnerVenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVenuePayload>[]
          }
          create: {
            args: Prisma.OwnerVenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVenuePayload>
          }
          createMany: {
            args: Prisma.OwnerVenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OwnerVenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVenuePayload>
          }
          update: {
            args: Prisma.OwnerVenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVenuePayload>
          }
          deleteMany: {
            args: Prisma.OwnerVenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerVenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OwnerVenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVenuePayload>
          }
          aggregate: {
            args: Prisma.OwnerVenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwnerVenue>
          }
          groupBy: {
            args: Prisma.OwnerVenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerVenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerVenueCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerVenueCountAggregateOutputType> | number
          }
        }
      }
      Owner: {
        payload: Prisma.$OwnerPayload<ExtArgs>
        fields: Prisma.OwnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findFirst: {
            args: Prisma.OwnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findMany: {
            args: Prisma.OwnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          create: {
            args: Prisma.OwnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          createMany: {
            args: Prisma.OwnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OwnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          update: {
            args: Prisma.OwnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          deleteMany: {
            args: Prisma.OwnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OwnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          aggregate: {
            args: Prisma.OwnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwner>
          }
          groupBy: {
            args: Prisma.OwnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      Text: {
        payload: Prisma.$TextPayload<ExtArgs>
        fields: Prisma.TextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPayload>
          }
          findFirst: {
            args: Prisma.TextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPayload>
          }
          findMany: {
            args: Prisma.TextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPayload>[]
          }
          create: {
            args: Prisma.TextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPayload>
          }
          createMany: {
            args: Prisma.TextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPayload>
          }
          update: {
            args: Prisma.TextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPayload>
          }
          deleteMany: {
            args: Prisma.TextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPayload>
          }
          aggregate: {
            args: Prisma.TextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateText>
          }
          groupBy: {
            args: Prisma.TextGroupByArgs<ExtArgs>
            result: $Utils.Optional<TextGroupByOutputType>[]
          }
          count: {
            args: Prisma.TextCountArgs<ExtArgs>
            result: $Utils.Optional<TextCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      Clause: {
        payload: Prisma.$ClausePayload<ExtArgs>
        fields: Prisma.ClauseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClauseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClausePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClauseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClausePayload>
          }
          findFirst: {
            args: Prisma.ClauseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClausePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClauseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClausePayload>
          }
          findMany: {
            args: Prisma.ClauseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClausePayload>[]
          }
          create: {
            args: Prisma.ClauseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClausePayload>
          }
          createMany: {
            args: Prisma.ClauseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClauseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClausePayload>
          }
          update: {
            args: Prisma.ClauseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClausePayload>
          }
          deleteMany: {
            args: Prisma.ClauseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClauseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClauseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClausePayload>
          }
          aggregate: {
            args: Prisma.ClauseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClause>
          }
          groupBy: {
            args: Prisma.ClauseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClauseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClauseCountArgs<ExtArgs>
            result: $Utils.Optional<ClauseCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RefreshTokenCountOutputType
   */

  export type RefreshTokenCountOutputType = {
    session: number
  }

  export type RefreshTokenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | RefreshTokenCountOutputTypeCountSessionArgs
  }

  // Custom InputTypes
  /**
   * RefreshTokenCountOutputType without action
   */
  export type RefreshTokenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshTokenCountOutputType
     */
    select?: RefreshTokenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RefreshTokenCountOutputType without action
   */
  export type RefreshTokenCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    session: number
    histories: number
    refreshToken: number
    userOrganizations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | UserCountOutputTypeCountSessionArgs
    histories?: boolean | UserCountOutputTypeCountHistoriesArgs
    refreshToken?: boolean | UserCountOutputTypeCountRefreshTokenArgs
    userOrganizations?: boolean | UserCountOutputTypeCountUserOrganizationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOrganizationWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    venues: number
    owners: number
    userOrganizations: number
    Clause: number
    Contract: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venues?: boolean | OrganizationCountOutputTypeCountVenuesArgs
    owners?: boolean | OrganizationCountOutputTypeCountOwnersArgs
    userOrganizations?: boolean | OrganizationCountOutputTypeCountUserOrganizationsArgs
    Clause?: boolean | OrganizationCountOutputTypeCountClauseArgs
    Contract?: boolean | OrganizationCountOutputTypeCountContractArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountVenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountOwnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUserOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOrganizationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountClauseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClauseWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }


  /**
   * Count Type ProposalCountOutputType
   */

  export type ProposalCountOutputType = {
    personList: number
    histories: number
    payments: number
    dateEvents: number
    proposalCosts: number
    proposalServices: number
    noificationList: number
    scheduleList: number
  }

  export type ProposalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personList?: boolean | ProposalCountOutputTypeCountPersonListArgs
    histories?: boolean | ProposalCountOutputTypeCountHistoriesArgs
    payments?: boolean | ProposalCountOutputTypeCountPaymentsArgs
    dateEvents?: boolean | ProposalCountOutputTypeCountDateEventsArgs
    proposalCosts?: boolean | ProposalCountOutputTypeCountProposalCostsArgs
    proposalServices?: boolean | ProposalCountOutputTypeCountProposalServicesArgs
    noificationList?: boolean | ProposalCountOutputTypeCountNoificationListArgs
    scheduleList?: boolean | ProposalCountOutputTypeCountScheduleListArgs
  }

  // Custom InputTypes
  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCountOutputType
     */
    select?: ProposalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountPersonListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoryWhereInput
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountDateEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DateEventWhereInput
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountProposalCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalCostWhereInput
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountProposalServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalServiceWhereInput
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountNoificationListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountScheduleListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    proposalServices: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposalServices?: boolean | ServiceCountOutputTypeCountProposalServicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountProposalServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalServiceWhereInput
  }


  /**
   * Count Type ProposalCostCountOutputType
   */

  export type ProposalCostCountOutputType = {
    proposals: number
  }

  export type ProposalCostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposals?: boolean | ProposalCostCountOutputTypeCountProposalsArgs
  }

  // Custom InputTypes
  /**
   * ProposalCostCountOutputType without action
   */
  export type ProposalCostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCostCountOutputType
     */
    select?: ProposalCostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProposalCostCountOutputType without action
   */
  export type ProposalCostCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }


  /**
   * Count Type DateEventCountOutputType
   */

  export type DateEventCountOutputType = {
    notifications: number
  }

  export type DateEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | DateEventCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * DateEventCountOutputType without action
   */
  export type DateEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEventCountOutputType
     */
    select?: DateEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DateEventCountOutputType without action
   */
  export type DateEventCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type VenueCountOutputType
   */

  export type VenueCountOutputType = {
    texts: number
    contacts: number
    images: number
    expenses: number
    services: number
    Payment: number
    questions: number
    proposals: number
    DateEvent: number
    ownerVenue: number
    notifications: number
  }

  export type VenueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    texts?: boolean | VenueCountOutputTypeCountTextsArgs
    contacts?: boolean | VenueCountOutputTypeCountContactsArgs
    images?: boolean | VenueCountOutputTypeCountImagesArgs
    expenses?: boolean | VenueCountOutputTypeCountExpensesArgs
    services?: boolean | VenueCountOutputTypeCountServicesArgs
    Payment?: boolean | VenueCountOutputTypeCountPaymentArgs
    questions?: boolean | VenueCountOutputTypeCountQuestionsArgs
    proposals?: boolean | VenueCountOutputTypeCountProposalsArgs
    DateEvent?: boolean | VenueCountOutputTypeCountDateEventArgs
    ownerVenue?: boolean | VenueCountOutputTypeCountOwnerVenueArgs
    notifications?: boolean | VenueCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueCountOutputType
     */
    select?: VenueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountTextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountDateEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DateEventWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountOwnerVenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerVenueWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type OwnerCountOutputType
   */

  export type OwnerCountOutputType = {
    ownerVenue: number
  }

  export type OwnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerVenue?: boolean | OwnerCountOutputTypeCountOwnerVenueArgs
  }

  // Custom InputTypes
  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCountOutputType
     */
    select?: OwnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountOwnerVenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerVenueWhereInput
  }


  /**
   * Count Type ContractCountOutputType
   */

  export type ContractCountOutputType = {
    clauses: number
  }

  export type ContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clauses?: boolean | ContractCountOutputTypeCountClausesArgs
  }

  // Custom InputTypes
  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     */
    select?: ContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountClausesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClauseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    expireIn: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    expireIn: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    expireIn: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    expireIn: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    expireIn: number
    userId: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    expireIn?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    expireIn?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    id?: true
    expireIn?: true
    userId?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    expireIn?: true
    userId?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    expireIn?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    expireIn: number
    userId: string
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expireIn?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | RefreshToken$sessionArgs<ExtArgs>
    _count?: boolean | RefreshTokenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>


  export type RefreshTokenSelectScalar = {
    id?: boolean
    expireIn?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | RefreshToken$sessionArgs<ExtArgs>
    _count?: boolean | RefreshTokenCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      session: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expireIn: number
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends RefreshToken$sessionArgs<ExtArgs> = {}>(args?: Subset<T, RefreshToken$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly expireIn: FieldRef<"RefreshToken", 'Int'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken.session
   */
  export type RefreshToken$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshTokenId: string | null
    ipAddress: string | null
    isValid: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshTokenId: string | null
    ipAddress: string | null
    isValid: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshTokenId: number
    ipAddress: number
    isValid: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenId?: true
    ipAddress?: true
    isValid?: true
    createdAt?: true
    expiresAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenId?: true
    ipAddress?: true
    isValid?: true
    createdAt?: true
    expiresAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenId?: true
    ipAddress?: true
    isValid?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    refreshTokenId: string
    ipAddress: string | null
    isValid: boolean
    createdAt: Date
    expiresAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenId?: boolean
    ipAddress?: boolean
    isValid?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    refreshToken?: boolean | Session$refreshTokenArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>


  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshTokenId?: boolean
    ipAddress?: boolean
    isValid?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    refreshToken?: boolean | Session$refreshTokenArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      refreshToken: Prisma.$RefreshTokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshTokenId: string
      ipAddress: string | null
      isValid: boolean
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    refreshToken<T extends Session$refreshTokenArgs<ExtArgs> = {}>(args?: Subset<T, Session$refreshTokenArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly refreshTokenId: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly isValid: FieldRef<"Session", 'Boolean'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session.refreshToken
   */
  export type Session$refreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    avatarUrl: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    avatarUrl: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    avatarUrl: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    avatarUrl?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    avatarUrl?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    avatarUrl?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    password: string
    avatarUrl: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    avatarUrl?: boolean
    session?: boolean | User$sessionArgs<ExtArgs>
    histories?: boolean | User$historiesArgs<ExtArgs>
    refreshToken?: boolean | User$refreshTokenArgs<ExtArgs>
    userOrganizations?: boolean | User$userOrganizationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    avatarUrl?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | User$sessionArgs<ExtArgs>
    histories?: boolean | User$historiesArgs<ExtArgs>
    refreshToken?: boolean | User$refreshTokenArgs<ExtArgs>
    userOrganizations?: boolean | User$userOrganizationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>[]
      histories: Prisma.$HistoryPayload<ExtArgs>[]
      refreshToken: Prisma.$RefreshTokenPayload<ExtArgs>[]
      userOrganizations: Prisma.$UserOrganizationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      password: string
      avatarUrl: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends User$sessionArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    histories<T extends User$historiesArgs<ExtArgs> = {}>(args?: Subset<T, User$historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findMany"> | Null>
    refreshToken<T extends User$refreshTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    userOrganizations<T extends User$userOrganizationsArgs<ExtArgs> = {}>(args?: Subset<T, User$userOrganizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.session
   */
  export type User$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.histories
   */
  export type User$historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    where?: HistoryWhereInput
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    cursor?: HistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * User.refreshToken
   */
  export type User$refreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.userOrganizations
   */
  export type User$userOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    where?: UserOrganizationWhereInput
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    cursor?: UserOrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOrganizationScalarFieldEnum | UserOrganizationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    venues?: boolean | Organization$venuesArgs<ExtArgs>
    owners?: boolean | Organization$ownersArgs<ExtArgs>
    userOrganizations?: boolean | Organization$userOrganizationsArgs<ExtArgs>
    Clause?: boolean | Organization$ClauseArgs<ExtArgs>
    Contract?: boolean | Organization$ContractArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>


  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venues?: boolean | Organization$venuesArgs<ExtArgs>
    owners?: boolean | Organization$ownersArgs<ExtArgs>
    userOrganizations?: boolean | Organization$userOrganizationsArgs<ExtArgs>
    Clause?: boolean | Organization$ClauseArgs<ExtArgs>
    Contract?: boolean | Organization$ContractArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      venues: Prisma.$VenuePayload<ExtArgs>[]
      owners: Prisma.$OwnerPayload<ExtArgs>[]
      userOrganizations: Prisma.$UserOrganizationPayload<ExtArgs>[]
      Clause: Prisma.$ClausePayload<ExtArgs>[]
      Contract: Prisma.$ContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venues<T extends Organization$venuesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$venuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany"> | Null>
    owners<T extends Organization$ownersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ownersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findMany"> | Null>
    userOrganizations<T extends Organization$userOrganizationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$userOrganizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findMany"> | Null>
    Clause<T extends Organization$ClauseArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ClauseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "findMany"> | Null>
    Contract<T extends Organization$ContractArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ContractArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.venues
   */
  export type Organization$venuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    cursor?: VenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Organization.owners
   */
  export type Organization$ownersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    cursor?: OwnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Organization.userOrganizations
   */
  export type Organization$userOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    where?: UserOrganizationWhereInput
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    cursor?: UserOrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOrganizationScalarFieldEnum | UserOrganizationScalarFieldEnum[]
  }

  /**
   * Organization.Clause
   */
  export type Organization$ClauseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    where?: ClauseWhereInput
    orderBy?: ClauseOrderByWithRelationInput | ClauseOrderByWithRelationInput[]
    cursor?: ClauseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClauseScalarFieldEnum | ClauseScalarFieldEnum[]
  }

  /**
   * Organization.Contract
   */
  export type Organization$ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model UserOrganization
   */

  export type AggregateUserOrganization = {
    _count: UserOrganizationCountAggregateOutputType | null
    _min: UserOrganizationMinAggregateOutputType | null
    _max: UserOrganizationMaxAggregateOutputType | null
  }

  export type UserOrganizationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    role: $Enums.Role | null
    joinedAt: Date | null
  }

  export type UserOrganizationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    role: $Enums.Role | null
    joinedAt: Date | null
  }

  export type UserOrganizationCountAggregateOutputType = {
    id: number
    userId: number
    organizationId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type UserOrganizationMinAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    role?: true
    joinedAt?: true
  }

  export type UserOrganizationMaxAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    role?: true
    joinedAt?: true
  }

  export type UserOrganizationCountAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type UserOrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOrganization to aggregate.
     */
    where?: UserOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrganizations to fetch.
     */
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOrganizations
    **/
    _count?: true | UserOrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOrganizationMaxAggregateInputType
  }

  export type GetUserOrganizationAggregateType<T extends UserOrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOrganization[P]>
      : GetScalarType<T[P], AggregateUserOrganization[P]>
  }




  export type UserOrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOrganizationWhereInput
    orderBy?: UserOrganizationOrderByWithAggregationInput | UserOrganizationOrderByWithAggregationInput[]
    by: UserOrganizationScalarFieldEnum[] | UserOrganizationScalarFieldEnum
    having?: UserOrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOrganizationCountAggregateInputType | true
    _min?: UserOrganizationMinAggregateInputType
    _max?: UserOrganizationMaxAggregateInputType
  }

  export type UserOrganizationGroupByOutputType = {
    id: string
    userId: string
    organizationId: string
    role: $Enums.Role
    joinedAt: Date
    _count: UserOrganizationCountAggregateOutputType | null
    _min: UserOrganizationMinAggregateOutputType | null
    _max: UserOrganizationMaxAggregateOutputType | null
  }

  type GetUserOrganizationGroupByPayload<T extends UserOrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], UserOrganizationGroupByOutputType[P]>
        }
      >
    >


  export type UserOrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOrganization"]>


  export type UserOrganizationSelectScalar = {
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type UserOrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $UserOrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOrganization"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      organizationId: string
      role: $Enums.Role
      joinedAt: Date
    }, ExtArgs["result"]["userOrganization"]>
    composites: {}
  }

  type UserOrganizationGetPayload<S extends boolean | null | undefined | UserOrganizationDefaultArgs> = $Result.GetResult<Prisma.$UserOrganizationPayload, S>

  type UserOrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserOrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserOrganizationCountAggregateInputType | true
    }

  export interface UserOrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOrganization'], meta: { name: 'UserOrganization' } }
    /**
     * Find zero or one UserOrganization that matches the filter.
     * @param {UserOrganizationFindUniqueArgs} args - Arguments to find a UserOrganization
     * @example
     * // Get one UserOrganization
     * const userOrganization = await prisma.userOrganization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserOrganizationFindUniqueArgs>(args: SelectSubset<T, UserOrganizationFindUniqueArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserOrganization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserOrganizationFindUniqueOrThrowArgs} args - Arguments to find a UserOrganization
     * @example
     * // Get one UserOrganization
     * const userOrganization = await prisma.userOrganization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserOrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserOrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserOrganization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationFindFirstArgs} args - Arguments to find a UserOrganization
     * @example
     * // Get one UserOrganization
     * const userOrganization = await prisma.userOrganization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserOrganizationFindFirstArgs>(args?: SelectSubset<T, UserOrganizationFindFirstArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserOrganization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationFindFirstOrThrowArgs} args - Arguments to find a UserOrganization
     * @example
     * // Get one UserOrganization
     * const userOrganization = await prisma.userOrganization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserOrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserOrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOrganizations
     * const userOrganizations = await prisma.userOrganization.findMany()
     * 
     * // Get first 10 UserOrganizations
     * const userOrganizations = await prisma.userOrganization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userOrganizationWithIdOnly = await prisma.userOrganization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserOrganizationFindManyArgs>(args?: SelectSubset<T, UserOrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserOrganization.
     * @param {UserOrganizationCreateArgs} args - Arguments to create a UserOrganization.
     * @example
     * // Create one UserOrganization
     * const UserOrganization = await prisma.userOrganization.create({
     *   data: {
     *     // ... data to create a UserOrganization
     *   }
     * })
     * 
     */
    create<T extends UserOrganizationCreateArgs>(args: SelectSubset<T, UserOrganizationCreateArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserOrganizations.
     * @param {UserOrganizationCreateManyArgs} args - Arguments to create many UserOrganizations.
     * @example
     * // Create many UserOrganizations
     * const userOrganization = await prisma.userOrganization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserOrganizationCreateManyArgs>(args?: SelectSubset<T, UserOrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserOrganization.
     * @param {UserOrganizationDeleteArgs} args - Arguments to delete one UserOrganization.
     * @example
     * // Delete one UserOrganization
     * const UserOrganization = await prisma.userOrganization.delete({
     *   where: {
     *     // ... filter to delete one UserOrganization
     *   }
     * })
     * 
     */
    delete<T extends UserOrganizationDeleteArgs>(args: SelectSubset<T, UserOrganizationDeleteArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserOrganization.
     * @param {UserOrganizationUpdateArgs} args - Arguments to update one UserOrganization.
     * @example
     * // Update one UserOrganization
     * const userOrganization = await prisma.userOrganization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserOrganizationUpdateArgs>(args: SelectSubset<T, UserOrganizationUpdateArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserOrganizations.
     * @param {UserOrganizationDeleteManyArgs} args - Arguments to filter UserOrganizations to delete.
     * @example
     * // Delete a few UserOrganizations
     * const { count } = await prisma.userOrganization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserOrganizationDeleteManyArgs>(args?: SelectSubset<T, UserOrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOrganizations
     * const userOrganization = await prisma.userOrganization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserOrganizationUpdateManyArgs>(args: SelectSubset<T, UserOrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserOrganization.
     * @param {UserOrganizationUpsertArgs} args - Arguments to update or create a UserOrganization.
     * @example
     * // Update or create a UserOrganization
     * const userOrganization = await prisma.userOrganization.upsert({
     *   create: {
     *     // ... data to create a UserOrganization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOrganization we want to update
     *   }
     * })
     */
    upsert<T extends UserOrganizationUpsertArgs>(args: SelectSubset<T, UserOrganizationUpsertArgs<ExtArgs>>): Prisma__UserOrganizationClient<$Result.GetResult<Prisma.$UserOrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationCountArgs} args - Arguments to filter UserOrganizations to count.
     * @example
     * // Count the number of UserOrganizations
     * const count = await prisma.userOrganization.count({
     *   where: {
     *     // ... the filter for the UserOrganizations we want to count
     *   }
     * })
    **/
    count<T extends UserOrganizationCountArgs>(
      args?: Subset<T, UserOrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOrganizationAggregateArgs>(args: Subset<T, UserOrganizationAggregateArgs>): Prisma.PrismaPromise<GetUserOrganizationAggregateType<T>>

    /**
     * Group by UserOrganization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOrganizationGroupByArgs['orderBy'] }
        : { orderBy?: UserOrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOrganization model
   */
  readonly fields: UserOrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOrganization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserOrganization model
   */ 
  interface UserOrganizationFieldRefs {
    readonly id: FieldRef<"UserOrganization", 'String'>
    readonly userId: FieldRef<"UserOrganization", 'String'>
    readonly organizationId: FieldRef<"UserOrganization", 'String'>
    readonly role: FieldRef<"UserOrganization", 'Role'>
    readonly joinedAt: FieldRef<"UserOrganization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserOrganization findUnique
   */
  export type UserOrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrganization to fetch.
     */
    where: UserOrganizationWhereUniqueInput
  }

  /**
   * UserOrganization findUniqueOrThrow
   */
  export type UserOrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrganization to fetch.
     */
    where: UserOrganizationWhereUniqueInput
  }

  /**
   * UserOrganization findFirst
   */
  export type UserOrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrganization to fetch.
     */
    where?: UserOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrganizations to fetch.
     */
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOrganizations.
     */
    cursor?: UserOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOrganizations.
     */
    distinct?: UserOrganizationScalarFieldEnum | UserOrganizationScalarFieldEnum[]
  }

  /**
   * UserOrganization findFirstOrThrow
   */
  export type UserOrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrganization to fetch.
     */
    where?: UserOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrganizations to fetch.
     */
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOrganizations.
     */
    cursor?: UserOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOrganizations.
     */
    distinct?: UserOrganizationScalarFieldEnum | UserOrganizationScalarFieldEnum[]
  }

  /**
   * UserOrganization findMany
   */
  export type UserOrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrganizations to fetch.
     */
    where?: UserOrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrganizations to fetch.
     */
    orderBy?: UserOrganizationOrderByWithRelationInput | UserOrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOrganizations.
     */
    cursor?: UserOrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrganizations.
     */
    skip?: number
    distinct?: UserOrganizationScalarFieldEnum | UserOrganizationScalarFieldEnum[]
  }

  /**
   * UserOrganization create
   */
  export type UserOrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOrganization.
     */
    data: XOR<UserOrganizationCreateInput, UserOrganizationUncheckedCreateInput>
  }

  /**
   * UserOrganization createMany
   */
  export type UserOrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOrganizations.
     */
    data: UserOrganizationCreateManyInput | UserOrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserOrganization update
   */
  export type UserOrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOrganization.
     */
    data: XOR<UserOrganizationUpdateInput, UserOrganizationUncheckedUpdateInput>
    /**
     * Choose, which UserOrganization to update.
     */
    where: UserOrganizationWhereUniqueInput
  }

  /**
   * UserOrganization updateMany
   */
  export type UserOrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOrganizations.
     */
    data: XOR<UserOrganizationUpdateManyMutationInput, UserOrganizationUncheckedUpdateManyInput>
    /**
     * Filter which UserOrganizations to update
     */
    where?: UserOrganizationWhereInput
  }

  /**
   * UserOrganization upsert
   */
  export type UserOrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOrganization to update in case it exists.
     */
    where: UserOrganizationWhereUniqueInput
    /**
     * In case the UserOrganization found by the `where` argument doesn't exist, create a new UserOrganization with this data.
     */
    create: XOR<UserOrganizationCreateInput, UserOrganizationUncheckedCreateInput>
    /**
     * In case the UserOrganization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOrganizationUpdateInput, UserOrganizationUncheckedUpdateInput>
  }

  /**
   * UserOrganization delete
   */
  export type UserOrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
    /**
     * Filter which UserOrganization to delete.
     */
    where: UserOrganizationWhereUniqueInput
  }

  /**
   * UserOrganization deleteMany
   */
  export type UserOrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOrganizations to delete
     */
    where?: UserOrganizationWhereInput
  }

  /**
   * UserOrganization without action
   */
  export type UserOrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrganization
     */
    select?: UserOrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Proposal
   */

  export type AggregateProposal = {
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  export type ProposalAvgAggregateOutputType = {
    guestNumber: number | null
    basePrice: number | null
    extraHoursQty: number | null
    extraHourPrice: number | null
    totalAmount: number | null
    amountPaid: number | null
  }

  export type ProposalSumAggregateOutputType = {
    guestNumber: number | null
    basePrice: number | null
    extraHoursQty: number | null
    extraHourPrice: number | null
    totalAmount: number | null
    amountPaid: number | null
  }

  export type ProposalMinAggregateOutputType = {
    id: string | null
    completeName: string | null
    cpf: string | null
    rg: string | null
    street: string | null
    streetNumber: string | null
    neighborhood: string | null
    cep: string | null
    city: string | null
    state: string | null
    type: $Enums.ProposalType | null
    trafficSource: $Enums.TrafficSource | null
    guestNumber: number | null
    knowsVenue: boolean | null
    startDate: Date | null
    endDate: Date | null
    name: string | null
    email: string | null
    whatsapp: string | null
    description: string | null
    basePrice: number | null
    extraHoursQty: number | null
    extraHourPrice: number | null
    totalAmount: number | null
    termsAccepted: boolean | null
    approved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    contact: boolean | null
    paid: boolean | null
    amountPaid: number | null
    venueId: string | null
  }

  export type ProposalMaxAggregateOutputType = {
    id: string | null
    completeName: string | null
    cpf: string | null
    rg: string | null
    street: string | null
    streetNumber: string | null
    neighborhood: string | null
    cep: string | null
    city: string | null
    state: string | null
    type: $Enums.ProposalType | null
    trafficSource: $Enums.TrafficSource | null
    guestNumber: number | null
    knowsVenue: boolean | null
    startDate: Date | null
    endDate: Date | null
    name: string | null
    email: string | null
    whatsapp: string | null
    description: string | null
    basePrice: number | null
    extraHoursQty: number | null
    extraHourPrice: number | null
    totalAmount: number | null
    termsAccepted: boolean | null
    approved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    contact: boolean | null
    paid: boolean | null
    amountPaid: number | null
    venueId: string | null
  }

  export type ProposalCountAggregateOutputType = {
    id: number
    completeName: number
    cpf: number
    rg: number
    street: number
    streetNumber: number
    neighborhood: number
    cep: number
    city: number
    state: number
    type: number
    trafficSource: number
    guestNumber: number
    knowsVenue: number
    startDate: number
    endDate: number
    name: number
    email: number
    whatsapp: number
    description: number
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted: number
    approved: number
    createdAt: number
    updatedAt: number
    contact: number
    paid: number
    amountPaid: number
    venueId: number
    _all: number
  }


  export type ProposalAvgAggregateInputType = {
    guestNumber?: true
    basePrice?: true
    extraHoursQty?: true
    extraHourPrice?: true
    totalAmount?: true
    amountPaid?: true
  }

  export type ProposalSumAggregateInputType = {
    guestNumber?: true
    basePrice?: true
    extraHoursQty?: true
    extraHourPrice?: true
    totalAmount?: true
    amountPaid?: true
  }

  export type ProposalMinAggregateInputType = {
    id?: true
    completeName?: true
    cpf?: true
    rg?: true
    street?: true
    streetNumber?: true
    neighborhood?: true
    cep?: true
    city?: true
    state?: true
    type?: true
    trafficSource?: true
    guestNumber?: true
    knowsVenue?: true
    startDate?: true
    endDate?: true
    name?: true
    email?: true
    whatsapp?: true
    description?: true
    basePrice?: true
    extraHoursQty?: true
    extraHourPrice?: true
    totalAmount?: true
    termsAccepted?: true
    approved?: true
    createdAt?: true
    updatedAt?: true
    contact?: true
    paid?: true
    amountPaid?: true
    venueId?: true
  }

  export type ProposalMaxAggregateInputType = {
    id?: true
    completeName?: true
    cpf?: true
    rg?: true
    street?: true
    streetNumber?: true
    neighborhood?: true
    cep?: true
    city?: true
    state?: true
    type?: true
    trafficSource?: true
    guestNumber?: true
    knowsVenue?: true
    startDate?: true
    endDate?: true
    name?: true
    email?: true
    whatsapp?: true
    description?: true
    basePrice?: true
    extraHoursQty?: true
    extraHourPrice?: true
    totalAmount?: true
    termsAccepted?: true
    approved?: true
    createdAt?: true
    updatedAt?: true
    contact?: true
    paid?: true
    amountPaid?: true
    venueId?: true
  }

  export type ProposalCountAggregateInputType = {
    id?: true
    completeName?: true
    cpf?: true
    rg?: true
    street?: true
    streetNumber?: true
    neighborhood?: true
    cep?: true
    city?: true
    state?: true
    type?: true
    trafficSource?: true
    guestNumber?: true
    knowsVenue?: true
    startDate?: true
    endDate?: true
    name?: true
    email?: true
    whatsapp?: true
    description?: true
    basePrice?: true
    extraHoursQty?: true
    extraHourPrice?: true
    totalAmount?: true
    termsAccepted?: true
    approved?: true
    createdAt?: true
    updatedAt?: true
    contact?: true
    paid?: true
    amountPaid?: true
    venueId?: true
    _all?: true
  }

  export type ProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposal to aggregate.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proposals
    **/
    _count?: true | ProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalMaxAggregateInputType
  }

  export type GetProposalAggregateType<T extends ProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposal[P]>
      : GetScalarType<T[P], AggregateProposal[P]>
  }




  export type ProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithAggregationInput | ProposalOrderByWithAggregationInput[]
    by: ProposalScalarFieldEnum[] | ProposalScalarFieldEnum
    having?: ProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalCountAggregateInputType | true
    _avg?: ProposalAvgAggregateInputType
    _sum?: ProposalSumAggregateInputType
    _min?: ProposalMinAggregateInputType
    _max?: ProposalMaxAggregateInputType
  }

  export type ProposalGroupByOutputType = {
    id: string
    completeName: string | null
    cpf: string | null
    rg: string | null
    street: string | null
    streetNumber: string | null
    neighborhood: string | null
    cep: string | null
    city: string | null
    state: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue: boolean
    startDate: Date
    endDate: Date
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted: boolean
    approved: boolean
    createdAt: Date
    updatedAt: Date
    contact: boolean | null
    paid: boolean | null
    amountPaid: number | null
    venueId: string
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  type GetProposalGroupByPayload<T extends ProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalGroupByOutputType[P]>
        }
      >
    >


  export type ProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    completeName?: boolean
    cpf?: boolean
    rg?: boolean
    street?: boolean
    streetNumber?: boolean
    neighborhood?: boolean
    cep?: boolean
    city?: boolean
    state?: boolean
    type?: boolean
    trafficSource?: boolean
    guestNumber?: boolean
    knowsVenue?: boolean
    startDate?: boolean
    endDate?: boolean
    name?: boolean
    email?: boolean
    whatsapp?: boolean
    description?: boolean
    basePrice?: boolean
    extraHoursQty?: boolean
    extraHourPrice?: boolean
    totalAmount?: boolean
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean
    paid?: boolean
    amountPaid?: boolean
    venueId?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    personList?: boolean | Proposal$personListArgs<ExtArgs>
    histories?: boolean | Proposal$historiesArgs<ExtArgs>
    payments?: boolean | Proposal$paymentsArgs<ExtArgs>
    dateEvents?: boolean | Proposal$dateEventsArgs<ExtArgs>
    proposalCosts?: boolean | Proposal$proposalCostsArgs<ExtArgs>
    proposalServices?: boolean | Proposal$proposalServicesArgs<ExtArgs>
    noificationList?: boolean | Proposal$noificationListArgs<ExtArgs>
    scheduleList?: boolean | Proposal$scheduleListArgs<ExtArgs>
    _count?: boolean | ProposalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>


  export type ProposalSelectScalar = {
    id?: boolean
    completeName?: boolean
    cpf?: boolean
    rg?: boolean
    street?: boolean
    streetNumber?: boolean
    neighborhood?: boolean
    cep?: boolean
    city?: boolean
    state?: boolean
    type?: boolean
    trafficSource?: boolean
    guestNumber?: boolean
    knowsVenue?: boolean
    startDate?: boolean
    endDate?: boolean
    name?: boolean
    email?: boolean
    whatsapp?: boolean
    description?: boolean
    basePrice?: boolean
    extraHoursQty?: boolean
    extraHourPrice?: boolean
    totalAmount?: boolean
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean
    paid?: boolean
    amountPaid?: boolean
    venueId?: boolean
  }

  export type ProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    personList?: boolean | Proposal$personListArgs<ExtArgs>
    histories?: boolean | Proposal$historiesArgs<ExtArgs>
    payments?: boolean | Proposal$paymentsArgs<ExtArgs>
    dateEvents?: boolean | Proposal$dateEventsArgs<ExtArgs>
    proposalCosts?: boolean | Proposal$proposalCostsArgs<ExtArgs>
    proposalServices?: boolean | Proposal$proposalServicesArgs<ExtArgs>
    noificationList?: boolean | Proposal$noificationListArgs<ExtArgs>
    scheduleList?: boolean | Proposal$scheduleListArgs<ExtArgs>
    _count?: boolean | ProposalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proposal"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
      personList: Prisma.$PersonPayload<ExtArgs>[]
      histories: Prisma.$HistoryPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      dateEvents: Prisma.$DateEventPayload<ExtArgs>[]
      proposalCosts: Prisma.$ProposalCostPayload<ExtArgs>[]
      proposalServices: Prisma.$ProposalServicePayload<ExtArgs>[]
      noificationList: Prisma.$NotificationPayload<ExtArgs>[]
      scheduleList: Prisma.$SchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      completeName: string | null
      cpf: string | null
      rg: string | null
      street: string | null
      streetNumber: string | null
      neighborhood: string | null
      cep: string | null
      city: string | null
      state: string | null
      type: $Enums.ProposalType
      trafficSource: $Enums.TrafficSource
      guestNumber: number
      knowsVenue: boolean
      startDate: Date
      endDate: Date
      name: string
      email: string
      whatsapp: string
      description: string
      basePrice: number
      extraHoursQty: number
      extraHourPrice: number
      totalAmount: number
      termsAccepted: boolean
      approved: boolean
      createdAt: Date
      updatedAt: Date
      contact: boolean | null
      paid: boolean | null
      amountPaid: number | null
      venueId: string
    }, ExtArgs["result"]["proposal"]>
    composites: {}
  }

  type ProposalGetPayload<S extends boolean | null | undefined | ProposalDefaultArgs> = $Result.GetResult<Prisma.$ProposalPayload, S>

  type ProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProposalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProposalCountAggregateInputType | true
    }

  export interface ProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proposal'], meta: { name: 'Proposal' } }
    /**
     * Find zero or one Proposal that matches the filter.
     * @param {ProposalFindUniqueArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalFindUniqueArgs>(args: SelectSubset<T, ProposalFindUniqueArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Proposal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProposalFindUniqueOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Proposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalFindFirstArgs>(args?: SelectSubset<T, ProposalFindFirstArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Proposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proposals
     * const proposals = await prisma.proposal.findMany()
     * 
     * // Get first 10 Proposals
     * const proposals = await prisma.proposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalWithIdOnly = await prisma.proposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalFindManyArgs>(args?: SelectSubset<T, ProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Proposal.
     * @param {ProposalCreateArgs} args - Arguments to create a Proposal.
     * @example
     * // Create one Proposal
     * const Proposal = await prisma.proposal.create({
     *   data: {
     *     // ... data to create a Proposal
     *   }
     * })
     * 
     */
    create<T extends ProposalCreateArgs>(args: SelectSubset<T, ProposalCreateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Proposals.
     * @param {ProposalCreateManyArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalCreateManyArgs>(args?: SelectSubset<T, ProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proposal.
     * @param {ProposalDeleteArgs} args - Arguments to delete one Proposal.
     * @example
     * // Delete one Proposal
     * const Proposal = await prisma.proposal.delete({
     *   where: {
     *     // ... filter to delete one Proposal
     *   }
     * })
     * 
     */
    delete<T extends ProposalDeleteArgs>(args: SelectSubset<T, ProposalDeleteArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Proposal.
     * @param {ProposalUpdateArgs} args - Arguments to update one Proposal.
     * @example
     * // Update one Proposal
     * const proposal = await prisma.proposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalUpdateArgs>(args: SelectSubset<T, ProposalUpdateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Proposals.
     * @param {ProposalDeleteManyArgs} args - Arguments to filter Proposals to delete.
     * @example
     * // Delete a few Proposals
     * const { count } = await prisma.proposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalDeleteManyArgs>(args?: SelectSubset<T, ProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalUpdateManyArgs>(args: SelectSubset<T, ProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proposal.
     * @param {ProposalUpsertArgs} args - Arguments to update or create a Proposal.
     * @example
     * // Update or create a Proposal
     * const proposal = await prisma.proposal.upsert({
     *   create: {
     *     // ... data to create a Proposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proposal we want to update
     *   }
     * })
     */
    upsert<T extends ProposalUpsertArgs>(args: SelectSubset<T, ProposalUpsertArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCountArgs} args - Arguments to filter Proposals to count.
     * @example
     * // Count the number of Proposals
     * const count = await prisma.proposal.count({
     *   where: {
     *     // ... the filter for the Proposals we want to count
     *   }
     * })
    **/
    count<T extends ProposalCountArgs>(
      args?: Subset<T, ProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalAggregateArgs>(args: Subset<T, ProposalAggregateArgs>): Prisma.PrismaPromise<GetProposalAggregateType<T>>

    /**
     * Group by Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalGroupByArgs['orderBy'] }
        : { orderBy?: ProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proposal model
   */
  readonly fields: ProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    personList<T extends Proposal$personListArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$personListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany"> | Null>
    histories<T extends Proposal$historiesArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Proposal$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    dateEvents<T extends Proposal$dateEventsArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$dateEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "findMany"> | Null>
    proposalCosts<T extends Proposal$proposalCostsArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$proposalCostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalCostPayload<ExtArgs>, T, "findMany"> | Null>
    proposalServices<T extends Proposal$proposalServicesArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$proposalServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "findMany"> | Null>
    noificationList<T extends Proposal$noificationListArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$noificationListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    scheduleList<T extends Proposal$scheduleListArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$scheduleListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proposal model
   */ 
  interface ProposalFieldRefs {
    readonly id: FieldRef<"Proposal", 'String'>
    readonly completeName: FieldRef<"Proposal", 'String'>
    readonly cpf: FieldRef<"Proposal", 'String'>
    readonly rg: FieldRef<"Proposal", 'String'>
    readonly street: FieldRef<"Proposal", 'String'>
    readonly streetNumber: FieldRef<"Proposal", 'String'>
    readonly neighborhood: FieldRef<"Proposal", 'String'>
    readonly cep: FieldRef<"Proposal", 'String'>
    readonly city: FieldRef<"Proposal", 'String'>
    readonly state: FieldRef<"Proposal", 'String'>
    readonly type: FieldRef<"Proposal", 'ProposalType'>
    readonly trafficSource: FieldRef<"Proposal", 'TrafficSource'>
    readonly guestNumber: FieldRef<"Proposal", 'Int'>
    readonly knowsVenue: FieldRef<"Proposal", 'Boolean'>
    readonly startDate: FieldRef<"Proposal", 'DateTime'>
    readonly endDate: FieldRef<"Proposal", 'DateTime'>
    readonly name: FieldRef<"Proposal", 'String'>
    readonly email: FieldRef<"Proposal", 'String'>
    readonly whatsapp: FieldRef<"Proposal", 'String'>
    readonly description: FieldRef<"Proposal", 'String'>
    readonly basePrice: FieldRef<"Proposal", 'Float'>
    readonly extraHoursQty: FieldRef<"Proposal", 'Int'>
    readonly extraHourPrice: FieldRef<"Proposal", 'Float'>
    readonly totalAmount: FieldRef<"Proposal", 'Float'>
    readonly termsAccepted: FieldRef<"Proposal", 'Boolean'>
    readonly approved: FieldRef<"Proposal", 'Boolean'>
    readonly createdAt: FieldRef<"Proposal", 'DateTime'>
    readonly updatedAt: FieldRef<"Proposal", 'DateTime'>
    readonly contact: FieldRef<"Proposal", 'Boolean'>
    readonly paid: FieldRef<"Proposal", 'Boolean'>
    readonly amountPaid: FieldRef<"Proposal", 'Float'>
    readonly venueId: FieldRef<"Proposal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Proposal findUnique
   */
  export type ProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal findUniqueOrThrow
   */
  export type ProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal findFirst
   */
  export type ProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal findFirstOrThrow
   */
  export type ProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal findMany
   */
  export type ProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposals to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal create
   */
  export type ProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a Proposal.
     */
    data: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
  }

  /**
   * Proposal createMany
   */
  export type ProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proposal update
   */
  export type ProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a Proposal.
     */
    data: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
    /**
     * Choose, which Proposal to update.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal updateMany
   */
  export type ProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proposals.
     */
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyInput>
    /**
     * Filter which Proposals to update
     */
    where?: ProposalWhereInput
  }

  /**
   * Proposal upsert
   */
  export type ProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the Proposal to update in case it exists.
     */
    where: ProposalWhereUniqueInput
    /**
     * In case the Proposal found by the `where` argument doesn't exist, create a new Proposal with this data.
     */
    create: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
    /**
     * In case the Proposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
  }

  /**
   * Proposal delete
   */
  export type ProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter which Proposal to delete.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal deleteMany
   */
  export type ProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposals to delete
     */
    where?: ProposalWhereInput
  }

  /**
   * Proposal.personList
   */
  export type Proposal$personListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    cursor?: PersonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Proposal.histories
   */
  export type Proposal$historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    where?: HistoryWhereInput
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    cursor?: HistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * Proposal.payments
   */
  export type Proposal$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Proposal.dateEvents
   */
  export type Proposal$dateEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    where?: DateEventWhereInput
    orderBy?: DateEventOrderByWithRelationInput | DateEventOrderByWithRelationInput[]
    cursor?: DateEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DateEventScalarFieldEnum | DateEventScalarFieldEnum[]
  }

  /**
   * Proposal.proposalCosts
   */
  export type Proposal$proposalCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
    where?: ProposalCostWhereInput
    orderBy?: ProposalCostOrderByWithRelationInput | ProposalCostOrderByWithRelationInput[]
    cursor?: ProposalCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalCostScalarFieldEnum | ProposalCostScalarFieldEnum[]
  }

  /**
   * Proposal.proposalServices
   */
  export type Proposal$proposalServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    where?: ProposalServiceWhereInput
    orderBy?: ProposalServiceOrderByWithRelationInput | ProposalServiceOrderByWithRelationInput[]
    cursor?: ProposalServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalServiceScalarFieldEnum | ProposalServiceScalarFieldEnum[]
  }

  /**
   * Proposal.noificationList
   */
  export type Proposal$noificationListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Proposal.scheduleList
   */
  export type Proposal$scheduleListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Proposal without action
   */
  export type ProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
  }


  /**
   * Model History
   */

  export type AggregateHistory = {
    _count: HistoryCountAggregateOutputType | null
    _min: HistoryMinAggregateOutputType | null
    _max: HistoryMaxAggregateOutputType | null
  }

  export type HistoryMinAggregateOutputType = {
    id: string | null
    action: string | null
    username: string | null
    userId: string | null
    proposalId: string | null
    createdAt: Date | null
  }

  export type HistoryMaxAggregateOutputType = {
    id: string | null
    action: string | null
    username: string | null
    userId: string | null
    proposalId: string | null
    createdAt: Date | null
  }

  export type HistoryCountAggregateOutputType = {
    id: number
    action: number
    username: number
    userId: number
    proposalId: number
    createdAt: number
    _all: number
  }


  export type HistoryMinAggregateInputType = {
    id?: true
    action?: true
    username?: true
    userId?: true
    proposalId?: true
    createdAt?: true
  }

  export type HistoryMaxAggregateInputType = {
    id?: true
    action?: true
    username?: true
    userId?: true
    proposalId?: true
    createdAt?: true
  }

  export type HistoryCountAggregateInputType = {
    id?: true
    action?: true
    username?: true
    userId?: true
    proposalId?: true
    createdAt?: true
    _all?: true
  }

  export type HistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which History to aggregate.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Histories
    **/
    _count?: true | HistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoryMaxAggregateInputType
  }

  export type GetHistoryAggregateType<T extends HistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistory[P]>
      : GetScalarType<T[P], AggregateHistory[P]>
  }




  export type HistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoryWhereInput
    orderBy?: HistoryOrderByWithAggregationInput | HistoryOrderByWithAggregationInput[]
    by: HistoryScalarFieldEnum[] | HistoryScalarFieldEnum
    having?: HistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoryCountAggregateInputType | true
    _min?: HistoryMinAggregateInputType
    _max?: HistoryMaxAggregateInputType
  }

  export type HistoryGroupByOutputType = {
    id: string
    action: string
    username: string | null
    userId: string | null
    proposalId: string
    createdAt: Date
    _count: HistoryCountAggregateOutputType | null
    _min: HistoryMinAggregateOutputType | null
    _max: HistoryMaxAggregateOutputType | null
  }

  type GetHistoryGroupByPayload<T extends HistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoryGroupByOutputType[P]>
            : GetScalarType<T[P], HistoryGroupByOutputType[P]>
        }
      >
    >


  export type HistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    username?: boolean
    userId?: boolean
    proposalId?: boolean
    createdAt?: boolean
    user?: boolean | History$userArgs<ExtArgs>
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["history"]>


  export type HistorySelectScalar = {
    id?: boolean
    action?: boolean
    username?: boolean
    userId?: boolean
    proposalId?: boolean
    createdAt?: boolean
  }

  export type HistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | History$userArgs<ExtArgs>
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }

  export type $HistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "History"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      proposal: Prisma.$ProposalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      username: string | null
      userId: string | null
      proposalId: string
      createdAt: Date
    }, ExtArgs["result"]["history"]>
    composites: {}
  }

  type HistoryGetPayload<S extends boolean | null | undefined | HistoryDefaultArgs> = $Result.GetResult<Prisma.$HistoryPayload, S>

  type HistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistoryCountAggregateInputType | true
    }

  export interface HistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['History'], meta: { name: 'History' } }
    /**
     * Find zero or one History that matches the filter.
     * @param {HistoryFindUniqueArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistoryFindUniqueArgs>(args: SelectSubset<T, HistoryFindUniqueArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one History that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HistoryFindUniqueOrThrowArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, HistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first History that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryFindFirstArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistoryFindFirstArgs>(args?: SelectSubset<T, HistoryFindFirstArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first History that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryFindFirstOrThrowArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, HistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Histories
     * const histories = await prisma.history.findMany()
     * 
     * // Get first 10 Histories
     * const histories = await prisma.history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historyWithIdOnly = await prisma.history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HistoryFindManyArgs>(args?: SelectSubset<T, HistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a History.
     * @param {HistoryCreateArgs} args - Arguments to create a History.
     * @example
     * // Create one History
     * const History = await prisma.history.create({
     *   data: {
     *     // ... data to create a History
     *   }
     * })
     * 
     */
    create<T extends HistoryCreateArgs>(args: SelectSubset<T, HistoryCreateArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Histories.
     * @param {HistoryCreateManyArgs} args - Arguments to create many Histories.
     * @example
     * // Create many Histories
     * const history = await prisma.history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistoryCreateManyArgs>(args?: SelectSubset<T, HistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a History.
     * @param {HistoryDeleteArgs} args - Arguments to delete one History.
     * @example
     * // Delete one History
     * const History = await prisma.history.delete({
     *   where: {
     *     // ... filter to delete one History
     *   }
     * })
     * 
     */
    delete<T extends HistoryDeleteArgs>(args: SelectSubset<T, HistoryDeleteArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one History.
     * @param {HistoryUpdateArgs} args - Arguments to update one History.
     * @example
     * // Update one History
     * const history = await prisma.history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistoryUpdateArgs>(args: SelectSubset<T, HistoryUpdateArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Histories.
     * @param {HistoryDeleteManyArgs} args - Arguments to filter Histories to delete.
     * @example
     * // Delete a few Histories
     * const { count } = await prisma.history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistoryDeleteManyArgs>(args?: SelectSubset<T, HistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Histories
     * const history = await prisma.history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistoryUpdateManyArgs>(args: SelectSubset<T, HistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one History.
     * @param {HistoryUpsertArgs} args - Arguments to update or create a History.
     * @example
     * // Update or create a History
     * const history = await prisma.history.upsert({
     *   create: {
     *     // ... data to create a History
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the History we want to update
     *   }
     * })
     */
    upsert<T extends HistoryUpsertArgs>(args: SelectSubset<T, HistoryUpsertArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryCountArgs} args - Arguments to filter Histories to count.
     * @example
     * // Count the number of Histories
     * const count = await prisma.history.count({
     *   where: {
     *     // ... the filter for the Histories we want to count
     *   }
     * })
    **/
    count<T extends HistoryCountArgs>(
      args?: Subset<T, HistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a History.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoryAggregateArgs>(args: Subset<T, HistoryAggregateArgs>): Prisma.PrismaPromise<GetHistoryAggregateType<T>>

    /**
     * Group by History.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoryGroupByArgs['orderBy'] }
        : { orderBy?: HistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the History model
   */
  readonly fields: HistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for History.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends History$userArgs<ExtArgs> = {}>(args?: Subset<T, History$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    proposal<T extends ProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProposalDefaultArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the History model
   */ 
  interface HistoryFieldRefs {
    readonly id: FieldRef<"History", 'String'>
    readonly action: FieldRef<"History", 'String'>
    readonly username: FieldRef<"History", 'String'>
    readonly userId: FieldRef<"History", 'String'>
    readonly proposalId: FieldRef<"History", 'String'>
    readonly createdAt: FieldRef<"History", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * History findUnique
   */
  export type HistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History findUniqueOrThrow
   */
  export type HistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History findFirst
   */
  export type HistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Histories.
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Histories.
     */
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * History findFirstOrThrow
   */
  export type HistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Histories.
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Histories.
     */
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * History findMany
   */
  export type HistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter, which Histories to fetch.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Histories.
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * History create
   */
  export type HistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a History.
     */
    data: XOR<HistoryCreateInput, HistoryUncheckedCreateInput>
  }

  /**
   * History createMany
   */
  export type HistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Histories.
     */
    data: HistoryCreateManyInput | HistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * History update
   */
  export type HistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a History.
     */
    data: XOR<HistoryUpdateInput, HistoryUncheckedUpdateInput>
    /**
     * Choose, which History to update.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History updateMany
   */
  export type HistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Histories.
     */
    data: XOR<HistoryUpdateManyMutationInput, HistoryUncheckedUpdateManyInput>
    /**
     * Filter which Histories to update
     */
    where?: HistoryWhereInput
  }

  /**
   * History upsert
   */
  export type HistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the History to update in case it exists.
     */
    where: HistoryWhereUniqueInput
    /**
     * In case the History found by the `where` argument doesn't exist, create a new History with this data.
     */
    create: XOR<HistoryCreateInput, HistoryUncheckedCreateInput>
    /**
     * In case the History was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistoryUpdateInput, HistoryUncheckedUpdateInput>
  }

  /**
   * History delete
   */
  export type HistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
    /**
     * Filter which History to delete.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History deleteMany
   */
  export type HistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Histories to delete
     */
    where?: HistoryWhereInput
  }

  /**
   * History.user
   */
  export type History$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * History without action
   */
  export type HistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoryInclude<ExtArgs> | null
  }


  /**
   * Model Person
   */

  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonMinAggregateOutputType = {
    id: string | null
    attendance: boolean | null
    type: $Enums.PersonType | null
    name: string | null
    email: string | null
    rg: string | null
    proposalId: string | null
  }

  export type PersonMaxAggregateOutputType = {
    id: string | null
    attendance: boolean | null
    type: $Enums.PersonType | null
    name: string | null
    email: string | null
    rg: string | null
    proposalId: string | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    attendance: number
    type: number
    name: number
    email: number
    rg: number
    proposalId: number
    _all: number
  }


  export type PersonMinAggregateInputType = {
    id?: true
    attendance?: true
    type?: true
    name?: true
    email?: true
    rg?: true
    proposalId?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    attendance?: true
    type?: true
    name?: true
    email?: true
    rg?: true
    proposalId?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    attendance?: true
    type?: true
    name?: true
    email?: true
    rg?: true
    proposalId?: true
    _all?: true
  }

  export type PersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Person to aggregate.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithAggregationInput | PersonOrderByWithAggregationInput[]
    by: PersonScalarFieldEnum[] | PersonScalarFieldEnum
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }

  export type PersonGroupByOutputType = {
    id: string
    attendance: boolean
    type: $Enums.PersonType
    name: string
    email: string | null
    rg: string | null
    proposalId: string
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendance?: boolean
    type?: boolean
    name?: boolean
    email?: boolean
    rg?: boolean
    proposalId?: boolean
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>


  export type PersonSelectScalar = {
    id?: boolean
    attendance?: boolean
    type?: boolean
    name?: boolean
    email?: boolean
    rg?: boolean
    proposalId?: boolean
  }

  export type PersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }

  export type $PersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Person"
    objects: {
      proposal: Prisma.$ProposalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attendance: boolean
      type: $Enums.PersonType
      name: string
      email: string | null
      rg: string | null
      proposalId: string
    }, ExtArgs["result"]["person"]>
    composites: {}
  }

  type PersonGetPayload<S extends boolean | null | undefined | PersonDefaultArgs> = $Result.GetResult<Prisma.$PersonPayload, S>

  type PersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonCountAggregateInputType | true
    }

  export interface PersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Person'], meta: { name: 'Person' } }
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonFindUniqueArgs>(args: SelectSubset<T, PersonFindUniqueArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Person that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonFindUniqueOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonFindFirstArgs>(args?: SelectSubset<T, PersonFindFirstArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonFindManyArgs>(args?: SelectSubset<T, PersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
     */
    create<T extends PersonCreateArgs>(args: SelectSubset<T, PersonCreateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many People.
     * @param {PersonCreateManyArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonCreateManyArgs>(args?: SelectSubset<T, PersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
     */
    delete<T extends PersonDeleteArgs>(args: SelectSubset<T, PersonDeleteArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonUpdateArgs>(args: SelectSubset<T, PersonUpdateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonDeleteManyArgs>(args?: SelectSubset<T, PersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonUpdateManyArgs>(args: SelectSubset<T, PersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
     */
    upsert<T extends PersonUpsertArgs>(args: SelectSubset<T, PersonUpsertArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): Prisma.PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Person model
   */
  readonly fields: PersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposal<T extends ProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProposalDefaultArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Person model
   */ 
  interface PersonFieldRefs {
    readonly id: FieldRef<"Person", 'String'>
    readonly attendance: FieldRef<"Person", 'Boolean'>
    readonly type: FieldRef<"Person", 'PersonType'>
    readonly name: FieldRef<"Person", 'String'>
    readonly email: FieldRef<"Person", 'String'>
    readonly rg: FieldRef<"Person", 'String'>
    readonly proposalId: FieldRef<"Person", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findUniqueOrThrow
   */
  export type PersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findFirstOrThrow
   */
  export type PersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findMany
   */
  export type PersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person create
   */
  export type PersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to create a Person.
     */
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }

  /**
   * Person createMany
   */
  export type PersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person update
   */
  export type PersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to update a Person.
     */
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
  }

  /**
   * Person upsert
   */
  export type PersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The filter to search for the Person to update in case it exists.
     */
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     */
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }

  /**
   * Person delete
   */
  export type PersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter which Person to delete.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PersonWhereInput
  }

  /**
   * Person without action
   */
  export type PersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
  }


  /**
   * Model ProposalService
   */

  export type AggregateProposalService = {
    _count: ProposalServiceCountAggregateOutputType | null
    _min: ProposalServiceMinAggregateOutputType | null
    _max: ProposalServiceMaxAggregateOutputType | null
  }

  export type ProposalServiceMinAggregateOutputType = {
    id: string | null
    proposalId: string | null
    serviceId: string | null
    joinedAt: Date | null
  }

  export type ProposalServiceMaxAggregateOutputType = {
    id: string | null
    proposalId: string | null
    serviceId: string | null
    joinedAt: Date | null
  }

  export type ProposalServiceCountAggregateOutputType = {
    id: number
    proposalId: number
    serviceId: number
    joinedAt: number
    _all: number
  }


  export type ProposalServiceMinAggregateInputType = {
    id?: true
    proposalId?: true
    serviceId?: true
    joinedAt?: true
  }

  export type ProposalServiceMaxAggregateInputType = {
    id?: true
    proposalId?: true
    serviceId?: true
    joinedAt?: true
  }

  export type ProposalServiceCountAggregateInputType = {
    id?: true
    proposalId?: true
    serviceId?: true
    joinedAt?: true
    _all?: true
  }

  export type ProposalServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalService to aggregate.
     */
    where?: ProposalServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalServices to fetch.
     */
    orderBy?: ProposalServiceOrderByWithRelationInput | ProposalServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProposalServices
    **/
    _count?: true | ProposalServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalServiceMaxAggregateInputType
  }

  export type GetProposalServiceAggregateType<T extends ProposalServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateProposalService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposalService[P]>
      : GetScalarType<T[P], AggregateProposalService[P]>
  }




  export type ProposalServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalServiceWhereInput
    orderBy?: ProposalServiceOrderByWithAggregationInput | ProposalServiceOrderByWithAggregationInput[]
    by: ProposalServiceScalarFieldEnum[] | ProposalServiceScalarFieldEnum
    having?: ProposalServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalServiceCountAggregateInputType | true
    _min?: ProposalServiceMinAggregateInputType
    _max?: ProposalServiceMaxAggregateInputType
  }

  export type ProposalServiceGroupByOutputType = {
    id: string
    proposalId: string
    serviceId: string
    joinedAt: Date
    _count: ProposalServiceCountAggregateOutputType | null
    _min: ProposalServiceMinAggregateOutputType | null
    _max: ProposalServiceMaxAggregateOutputType | null
  }

  type GetProposalServiceGroupByPayload<T extends ProposalServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalServiceGroupByOutputType[P]>
        }
      >
    >


  export type ProposalServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    serviceId?: boolean
    joinedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalService"]>


  export type ProposalServiceSelectScalar = {
    id?: boolean
    proposalId?: boolean
    serviceId?: boolean
    joinedAt?: boolean
  }

  export type ProposalServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }

  export type $ProposalServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProposalService"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      proposal: Prisma.$ProposalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proposalId: string
      serviceId: string
      joinedAt: Date
    }, ExtArgs["result"]["proposalService"]>
    composites: {}
  }

  type ProposalServiceGetPayload<S extends boolean | null | undefined | ProposalServiceDefaultArgs> = $Result.GetResult<Prisma.$ProposalServicePayload, S>

  type ProposalServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProposalServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProposalServiceCountAggregateInputType | true
    }

  export interface ProposalServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProposalService'], meta: { name: 'ProposalService' } }
    /**
     * Find zero or one ProposalService that matches the filter.
     * @param {ProposalServiceFindUniqueArgs} args - Arguments to find a ProposalService
     * @example
     * // Get one ProposalService
     * const proposalService = await prisma.proposalService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalServiceFindUniqueArgs>(args: SelectSubset<T, ProposalServiceFindUniqueArgs<ExtArgs>>): Prisma__ProposalServiceClient<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProposalService that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProposalServiceFindUniqueOrThrowArgs} args - Arguments to find a ProposalService
     * @example
     * // Get one ProposalService
     * const proposalService = await prisma.proposalService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalServiceClient<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProposalService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalServiceFindFirstArgs} args - Arguments to find a ProposalService
     * @example
     * // Get one ProposalService
     * const proposalService = await prisma.proposalService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalServiceFindFirstArgs>(args?: SelectSubset<T, ProposalServiceFindFirstArgs<ExtArgs>>): Prisma__ProposalServiceClient<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProposalService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalServiceFindFirstOrThrowArgs} args - Arguments to find a ProposalService
     * @example
     * // Get one ProposalService
     * const proposalService = await prisma.proposalService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalServiceClient<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProposalServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProposalServices
     * const proposalServices = await prisma.proposalService.findMany()
     * 
     * // Get first 10 ProposalServices
     * const proposalServices = await prisma.proposalService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalServiceWithIdOnly = await prisma.proposalService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalServiceFindManyArgs>(args?: SelectSubset<T, ProposalServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProposalService.
     * @param {ProposalServiceCreateArgs} args - Arguments to create a ProposalService.
     * @example
     * // Create one ProposalService
     * const ProposalService = await prisma.proposalService.create({
     *   data: {
     *     // ... data to create a ProposalService
     *   }
     * })
     * 
     */
    create<T extends ProposalServiceCreateArgs>(args: SelectSubset<T, ProposalServiceCreateArgs<ExtArgs>>): Prisma__ProposalServiceClient<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProposalServices.
     * @param {ProposalServiceCreateManyArgs} args - Arguments to create many ProposalServices.
     * @example
     * // Create many ProposalServices
     * const proposalService = await prisma.proposalService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalServiceCreateManyArgs>(args?: SelectSubset<T, ProposalServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProposalService.
     * @param {ProposalServiceDeleteArgs} args - Arguments to delete one ProposalService.
     * @example
     * // Delete one ProposalService
     * const ProposalService = await prisma.proposalService.delete({
     *   where: {
     *     // ... filter to delete one ProposalService
     *   }
     * })
     * 
     */
    delete<T extends ProposalServiceDeleteArgs>(args: SelectSubset<T, ProposalServiceDeleteArgs<ExtArgs>>): Prisma__ProposalServiceClient<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProposalService.
     * @param {ProposalServiceUpdateArgs} args - Arguments to update one ProposalService.
     * @example
     * // Update one ProposalService
     * const proposalService = await prisma.proposalService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalServiceUpdateArgs>(args: SelectSubset<T, ProposalServiceUpdateArgs<ExtArgs>>): Prisma__ProposalServiceClient<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProposalServices.
     * @param {ProposalServiceDeleteManyArgs} args - Arguments to filter ProposalServices to delete.
     * @example
     * // Delete a few ProposalServices
     * const { count } = await prisma.proposalService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalServiceDeleteManyArgs>(args?: SelectSubset<T, ProposalServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProposalServices
     * const proposalService = await prisma.proposalService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalServiceUpdateManyArgs>(args: SelectSubset<T, ProposalServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProposalService.
     * @param {ProposalServiceUpsertArgs} args - Arguments to update or create a ProposalService.
     * @example
     * // Update or create a ProposalService
     * const proposalService = await prisma.proposalService.upsert({
     *   create: {
     *     // ... data to create a ProposalService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProposalService we want to update
     *   }
     * })
     */
    upsert<T extends ProposalServiceUpsertArgs>(args: SelectSubset<T, ProposalServiceUpsertArgs<ExtArgs>>): Prisma__ProposalServiceClient<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProposalServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalServiceCountArgs} args - Arguments to filter ProposalServices to count.
     * @example
     * // Count the number of ProposalServices
     * const count = await prisma.proposalService.count({
     *   where: {
     *     // ... the filter for the ProposalServices we want to count
     *   }
     * })
    **/
    count<T extends ProposalServiceCountArgs>(
      args?: Subset<T, ProposalServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProposalService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalServiceAggregateArgs>(args: Subset<T, ProposalServiceAggregateArgs>): Prisma.PrismaPromise<GetProposalServiceAggregateType<T>>

    /**
     * Group by ProposalService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalServiceGroupByArgs['orderBy'] }
        : { orderBy?: ProposalServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProposalService model
   */
  readonly fields: ProposalServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProposalService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    proposal<T extends ProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProposalDefaultArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProposalService model
   */ 
  interface ProposalServiceFieldRefs {
    readonly id: FieldRef<"ProposalService", 'String'>
    readonly proposalId: FieldRef<"ProposalService", 'String'>
    readonly serviceId: FieldRef<"ProposalService", 'String'>
    readonly joinedAt: FieldRef<"ProposalService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProposalService findUnique
   */
  export type ProposalServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    /**
     * Filter, which ProposalService to fetch.
     */
    where: ProposalServiceWhereUniqueInput
  }

  /**
   * ProposalService findUniqueOrThrow
   */
  export type ProposalServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    /**
     * Filter, which ProposalService to fetch.
     */
    where: ProposalServiceWhereUniqueInput
  }

  /**
   * ProposalService findFirst
   */
  export type ProposalServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    /**
     * Filter, which ProposalService to fetch.
     */
    where?: ProposalServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalServices to fetch.
     */
    orderBy?: ProposalServiceOrderByWithRelationInput | ProposalServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalServices.
     */
    cursor?: ProposalServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalServices.
     */
    distinct?: ProposalServiceScalarFieldEnum | ProposalServiceScalarFieldEnum[]
  }

  /**
   * ProposalService findFirstOrThrow
   */
  export type ProposalServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    /**
     * Filter, which ProposalService to fetch.
     */
    where?: ProposalServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalServices to fetch.
     */
    orderBy?: ProposalServiceOrderByWithRelationInput | ProposalServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalServices.
     */
    cursor?: ProposalServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalServices.
     */
    distinct?: ProposalServiceScalarFieldEnum | ProposalServiceScalarFieldEnum[]
  }

  /**
   * ProposalService findMany
   */
  export type ProposalServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    /**
     * Filter, which ProposalServices to fetch.
     */
    where?: ProposalServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalServices to fetch.
     */
    orderBy?: ProposalServiceOrderByWithRelationInput | ProposalServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProposalServices.
     */
    cursor?: ProposalServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalServices.
     */
    skip?: number
    distinct?: ProposalServiceScalarFieldEnum | ProposalServiceScalarFieldEnum[]
  }

  /**
   * ProposalService create
   */
  export type ProposalServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a ProposalService.
     */
    data: XOR<ProposalServiceCreateInput, ProposalServiceUncheckedCreateInput>
  }

  /**
   * ProposalService createMany
   */
  export type ProposalServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProposalServices.
     */
    data: ProposalServiceCreateManyInput | ProposalServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProposalService update
   */
  export type ProposalServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a ProposalService.
     */
    data: XOR<ProposalServiceUpdateInput, ProposalServiceUncheckedUpdateInput>
    /**
     * Choose, which ProposalService to update.
     */
    where: ProposalServiceWhereUniqueInput
  }

  /**
   * ProposalService updateMany
   */
  export type ProposalServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProposalServices.
     */
    data: XOR<ProposalServiceUpdateManyMutationInput, ProposalServiceUncheckedUpdateManyInput>
    /**
     * Filter which ProposalServices to update
     */
    where?: ProposalServiceWhereInput
  }

  /**
   * ProposalService upsert
   */
  export type ProposalServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the ProposalService to update in case it exists.
     */
    where: ProposalServiceWhereUniqueInput
    /**
     * In case the ProposalService found by the `where` argument doesn't exist, create a new ProposalService with this data.
     */
    create: XOR<ProposalServiceCreateInput, ProposalServiceUncheckedCreateInput>
    /**
     * In case the ProposalService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalServiceUpdateInput, ProposalServiceUncheckedUpdateInput>
  }

  /**
   * ProposalService delete
   */
  export type ProposalServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    /**
     * Filter which ProposalService to delete.
     */
    where: ProposalServiceWhereUniqueInput
  }

  /**
   * ProposalService deleteMany
   */
  export type ProposalServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalServices to delete
     */
    where?: ProposalServiceWhereInput
  }

  /**
   * ProposalService without action
   */
  export type ProposalServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: number | null
  }

  export type ServiceSumAggregateOutputType = {
    price: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    venueId: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    venueId: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    price: number
    venueId: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    venueId?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    venueId?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    venueId?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    price: number
    venueId: string
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    venueId?: boolean
    proposalServices?: boolean | Service$proposalServicesArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>


  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    venueId?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposalServices?: boolean | Service$proposalServicesArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      proposalServices: Prisma.$ProposalServicePayload<ExtArgs>[]
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      venueId: string
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposalServices<T extends Service$proposalServicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$proposalServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalServicePayload<ExtArgs>, T, "findMany"> | Null>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Float'>
    readonly venueId: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.proposalServices
   */
  export type Service$proposalServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalService
     */
    select?: ProposalServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalServiceInclude<ExtArgs> | null
    where?: ProposalServiceWhereInput
    orderBy?: ProposalServiceOrderByWithRelationInput | ProposalServiceOrderByWithRelationInput[]
    cursor?: ProposalServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalServiceScalarFieldEnum | ProposalServiceScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    proposalId: string | null
    venueId: string | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date | null
    updatedAt: Date | null
    imageUrl: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    proposalId: string | null
    venueId: string | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date | null
    updatedAt: Date | null
    imageUrl: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    proposalId: number
    venueId: number
    amount: number
    paymentDate: number
    paymentMethod: number
    createdAt: number
    updatedAt: number
    imageUrl: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    proposalId?: true
    venueId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    imageUrl?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    proposalId?: true
    venueId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    imageUrl?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    proposalId?: true
    venueId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    imageUrl?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    proposalId: string
    venueId: string
    amount: number
    paymentDate: Date
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date
    updatedAt: Date
    imageUrl: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    venueId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageUrl?: boolean
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>


  export type PaymentSelectScalar = {
    id?: boolean
    proposalId?: boolean
    venueId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imageUrl?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      proposal: Prisma.$ProposalPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proposalId: string
      venueId: string
      amount: number
      paymentDate: Date
      paymentMethod: $Enums.PaymentMethod | null
      createdAt: Date
      updatedAt: Date
      imageUrl: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposal<T extends ProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProposalDefaultArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly proposalId: FieldRef<"Payment", 'String'>
    readonly venueId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly imageUrl: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model ProposalCost
   */

  export type AggregateProposalCost = {
    _count: ProposalCostCountAggregateOutputType | null
    _avg: ProposalCostAvgAggregateOutputType | null
    _sum: ProposalCostSumAggregateOutputType | null
    _min: ProposalCostMinAggregateOutputType | null
    _max: ProposalCostMaxAggregateOutputType | null
  }

  export type ProposalCostAvgAggregateOutputType = {
    amount: number | null
  }

  export type ProposalCostSumAggregateOutputType = {
    amount: number | null
  }

  export type ProposalCostMinAggregateOutputType = {
    id: string | null
    name: $Enums.ProposalName | null
    teste: string | null
    amount: number | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProposalCostMaxAggregateOutputType = {
    id: string | null
    name: $Enums.ProposalName | null
    teste: string | null
    amount: number | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProposalCostCountAggregateOutputType = {
    id: number
    name: number
    teste: number
    amount: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ProposalCostAvgAggregateInputType = {
    amount?: true
  }

  export type ProposalCostSumAggregateInputType = {
    amount?: true
  }

  export type ProposalCostMinAggregateInputType = {
    id?: true
    name?: true
    teste?: true
    amount?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProposalCostMaxAggregateInputType = {
    id?: true
    name?: true
    teste?: true
    amount?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProposalCostCountAggregateInputType = {
    id?: true
    name?: true
    teste?: true
    amount?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ProposalCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalCost to aggregate.
     */
    where?: ProposalCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalCosts to fetch.
     */
    orderBy?: ProposalCostOrderByWithRelationInput | ProposalCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProposalCosts
    **/
    _count?: true | ProposalCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalCostMaxAggregateInputType
  }

  export type GetProposalCostAggregateType<T extends ProposalCostAggregateArgs> = {
        [P in keyof T & keyof AggregateProposalCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposalCost[P]>
      : GetScalarType<T[P], AggregateProposalCost[P]>
  }




  export type ProposalCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalCostWhereInput
    orderBy?: ProposalCostOrderByWithAggregationInput | ProposalCostOrderByWithAggregationInput[]
    by: ProposalCostScalarFieldEnum[] | ProposalCostScalarFieldEnum
    having?: ProposalCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalCostCountAggregateInputType | true
    _avg?: ProposalCostAvgAggregateInputType
    _sum?: ProposalCostSumAggregateInputType
    _min?: ProposalCostMinAggregateInputType
    _max?: ProposalCostMaxAggregateInputType
  }

  export type ProposalCostGroupByOutputType = {
    id: string
    name: $Enums.ProposalName
    teste: string
    amount: number
    updatedAt: Date
    createdAt: Date
    _count: ProposalCostCountAggregateOutputType | null
    _avg: ProposalCostAvgAggregateOutputType | null
    _sum: ProposalCostSumAggregateOutputType | null
    _min: ProposalCostMinAggregateOutputType | null
    _max: ProposalCostMaxAggregateOutputType | null
  }

  type GetProposalCostGroupByPayload<T extends ProposalCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalCostGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalCostGroupByOutputType[P]>
        }
      >
    >


  export type ProposalCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    teste?: boolean
    amount?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    proposals?: boolean | ProposalCost$proposalsArgs<ExtArgs>
    _count?: boolean | ProposalCostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalCost"]>


  export type ProposalCostSelectScalar = {
    id?: boolean
    name?: boolean
    teste?: boolean
    amount?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ProposalCostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposals?: boolean | ProposalCost$proposalsArgs<ExtArgs>
    _count?: boolean | ProposalCostCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProposalCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProposalCost"
    objects: {
      proposals: Prisma.$ProposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: $Enums.ProposalName
      teste: string
      amount: number
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["proposalCost"]>
    composites: {}
  }

  type ProposalCostGetPayload<S extends boolean | null | undefined | ProposalCostDefaultArgs> = $Result.GetResult<Prisma.$ProposalCostPayload, S>

  type ProposalCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProposalCostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProposalCostCountAggregateInputType | true
    }

  export interface ProposalCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProposalCost'], meta: { name: 'ProposalCost' } }
    /**
     * Find zero or one ProposalCost that matches the filter.
     * @param {ProposalCostFindUniqueArgs} args - Arguments to find a ProposalCost
     * @example
     * // Get one ProposalCost
     * const proposalCost = await prisma.proposalCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalCostFindUniqueArgs>(args: SelectSubset<T, ProposalCostFindUniqueArgs<ExtArgs>>): Prisma__ProposalCostClient<$Result.GetResult<Prisma.$ProposalCostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProposalCost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProposalCostFindUniqueOrThrowArgs} args - Arguments to find a ProposalCost
     * @example
     * // Get one ProposalCost
     * const proposalCost = await prisma.proposalCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalCostFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalCostClient<$Result.GetResult<Prisma.$ProposalCostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProposalCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCostFindFirstArgs} args - Arguments to find a ProposalCost
     * @example
     * // Get one ProposalCost
     * const proposalCost = await prisma.proposalCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalCostFindFirstArgs>(args?: SelectSubset<T, ProposalCostFindFirstArgs<ExtArgs>>): Prisma__ProposalCostClient<$Result.GetResult<Prisma.$ProposalCostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProposalCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCostFindFirstOrThrowArgs} args - Arguments to find a ProposalCost
     * @example
     * // Get one ProposalCost
     * const proposalCost = await prisma.proposalCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalCostFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalCostClient<$Result.GetResult<Prisma.$ProposalCostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProposalCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProposalCosts
     * const proposalCosts = await prisma.proposalCost.findMany()
     * 
     * // Get first 10 ProposalCosts
     * const proposalCosts = await prisma.proposalCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalCostWithIdOnly = await prisma.proposalCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalCostFindManyArgs>(args?: SelectSubset<T, ProposalCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalCostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProposalCost.
     * @param {ProposalCostCreateArgs} args - Arguments to create a ProposalCost.
     * @example
     * // Create one ProposalCost
     * const ProposalCost = await prisma.proposalCost.create({
     *   data: {
     *     // ... data to create a ProposalCost
     *   }
     * })
     * 
     */
    create<T extends ProposalCostCreateArgs>(args: SelectSubset<T, ProposalCostCreateArgs<ExtArgs>>): Prisma__ProposalCostClient<$Result.GetResult<Prisma.$ProposalCostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProposalCosts.
     * @param {ProposalCostCreateManyArgs} args - Arguments to create many ProposalCosts.
     * @example
     * // Create many ProposalCosts
     * const proposalCost = await prisma.proposalCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalCostCreateManyArgs>(args?: SelectSubset<T, ProposalCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProposalCost.
     * @param {ProposalCostDeleteArgs} args - Arguments to delete one ProposalCost.
     * @example
     * // Delete one ProposalCost
     * const ProposalCost = await prisma.proposalCost.delete({
     *   where: {
     *     // ... filter to delete one ProposalCost
     *   }
     * })
     * 
     */
    delete<T extends ProposalCostDeleteArgs>(args: SelectSubset<T, ProposalCostDeleteArgs<ExtArgs>>): Prisma__ProposalCostClient<$Result.GetResult<Prisma.$ProposalCostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProposalCost.
     * @param {ProposalCostUpdateArgs} args - Arguments to update one ProposalCost.
     * @example
     * // Update one ProposalCost
     * const proposalCost = await prisma.proposalCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalCostUpdateArgs>(args: SelectSubset<T, ProposalCostUpdateArgs<ExtArgs>>): Prisma__ProposalCostClient<$Result.GetResult<Prisma.$ProposalCostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProposalCosts.
     * @param {ProposalCostDeleteManyArgs} args - Arguments to filter ProposalCosts to delete.
     * @example
     * // Delete a few ProposalCosts
     * const { count } = await prisma.proposalCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalCostDeleteManyArgs>(args?: SelectSubset<T, ProposalCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProposalCosts
     * const proposalCost = await prisma.proposalCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalCostUpdateManyArgs>(args: SelectSubset<T, ProposalCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProposalCost.
     * @param {ProposalCostUpsertArgs} args - Arguments to update or create a ProposalCost.
     * @example
     * // Update or create a ProposalCost
     * const proposalCost = await prisma.proposalCost.upsert({
     *   create: {
     *     // ... data to create a ProposalCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProposalCost we want to update
     *   }
     * })
     */
    upsert<T extends ProposalCostUpsertArgs>(args: SelectSubset<T, ProposalCostUpsertArgs<ExtArgs>>): Prisma__ProposalCostClient<$Result.GetResult<Prisma.$ProposalCostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProposalCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCostCountArgs} args - Arguments to filter ProposalCosts to count.
     * @example
     * // Count the number of ProposalCosts
     * const count = await prisma.proposalCost.count({
     *   where: {
     *     // ... the filter for the ProposalCosts we want to count
     *   }
     * })
    **/
    count<T extends ProposalCostCountArgs>(
      args?: Subset<T, ProposalCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProposalCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalCostAggregateArgs>(args: Subset<T, ProposalCostAggregateArgs>): Prisma.PrismaPromise<GetProposalCostAggregateType<T>>

    /**
     * Group by ProposalCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalCostGroupByArgs['orderBy'] }
        : { orderBy?: ProposalCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProposalCost model
   */
  readonly fields: ProposalCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProposalCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposals<T extends ProposalCost$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, ProposalCost$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProposalCost model
   */ 
  interface ProposalCostFieldRefs {
    readonly id: FieldRef<"ProposalCost", 'String'>
    readonly name: FieldRef<"ProposalCost", 'ProposalName'>
    readonly teste: FieldRef<"ProposalCost", 'String'>
    readonly amount: FieldRef<"ProposalCost", 'Float'>
    readonly updatedAt: FieldRef<"ProposalCost", 'DateTime'>
    readonly createdAt: FieldRef<"ProposalCost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProposalCost findUnique
   */
  export type ProposalCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
    /**
     * Filter, which ProposalCost to fetch.
     */
    where: ProposalCostWhereUniqueInput
  }

  /**
   * ProposalCost findUniqueOrThrow
   */
  export type ProposalCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
    /**
     * Filter, which ProposalCost to fetch.
     */
    where: ProposalCostWhereUniqueInput
  }

  /**
   * ProposalCost findFirst
   */
  export type ProposalCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
    /**
     * Filter, which ProposalCost to fetch.
     */
    where?: ProposalCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalCosts to fetch.
     */
    orderBy?: ProposalCostOrderByWithRelationInput | ProposalCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalCosts.
     */
    cursor?: ProposalCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalCosts.
     */
    distinct?: ProposalCostScalarFieldEnum | ProposalCostScalarFieldEnum[]
  }

  /**
   * ProposalCost findFirstOrThrow
   */
  export type ProposalCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
    /**
     * Filter, which ProposalCost to fetch.
     */
    where?: ProposalCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalCosts to fetch.
     */
    orderBy?: ProposalCostOrderByWithRelationInput | ProposalCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalCosts.
     */
    cursor?: ProposalCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalCosts.
     */
    distinct?: ProposalCostScalarFieldEnum | ProposalCostScalarFieldEnum[]
  }

  /**
   * ProposalCost findMany
   */
  export type ProposalCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
    /**
     * Filter, which ProposalCosts to fetch.
     */
    where?: ProposalCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalCosts to fetch.
     */
    orderBy?: ProposalCostOrderByWithRelationInput | ProposalCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProposalCosts.
     */
    cursor?: ProposalCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalCosts.
     */
    skip?: number
    distinct?: ProposalCostScalarFieldEnum | ProposalCostScalarFieldEnum[]
  }

  /**
   * ProposalCost create
   */
  export type ProposalCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
    /**
     * The data needed to create a ProposalCost.
     */
    data: XOR<ProposalCostCreateInput, ProposalCostUncheckedCreateInput>
  }

  /**
   * ProposalCost createMany
   */
  export type ProposalCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProposalCosts.
     */
    data: ProposalCostCreateManyInput | ProposalCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProposalCost update
   */
  export type ProposalCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
    /**
     * The data needed to update a ProposalCost.
     */
    data: XOR<ProposalCostUpdateInput, ProposalCostUncheckedUpdateInput>
    /**
     * Choose, which ProposalCost to update.
     */
    where: ProposalCostWhereUniqueInput
  }

  /**
   * ProposalCost updateMany
   */
  export type ProposalCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProposalCosts.
     */
    data: XOR<ProposalCostUpdateManyMutationInput, ProposalCostUncheckedUpdateManyInput>
    /**
     * Filter which ProposalCosts to update
     */
    where?: ProposalCostWhereInput
  }

  /**
   * ProposalCost upsert
   */
  export type ProposalCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
    /**
     * The filter to search for the ProposalCost to update in case it exists.
     */
    where: ProposalCostWhereUniqueInput
    /**
     * In case the ProposalCost found by the `where` argument doesn't exist, create a new ProposalCost with this data.
     */
    create: XOR<ProposalCostCreateInput, ProposalCostUncheckedCreateInput>
    /**
     * In case the ProposalCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalCostUpdateInput, ProposalCostUncheckedUpdateInput>
  }

  /**
   * ProposalCost delete
   */
  export type ProposalCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
    /**
     * Filter which ProposalCost to delete.
     */
    where: ProposalCostWhereUniqueInput
  }

  /**
   * ProposalCost deleteMany
   */
  export type ProposalCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalCosts to delete
     */
    where?: ProposalCostWhereInput
  }

  /**
   * ProposalCost.proposals
   */
  export type ProposalCost$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * ProposalCost without action
   */
  export type ProposalCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCost
     */
    select?: ProposalCostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalCostInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    amount: number | null
    paymentDate: Date | null
    type: $Enums.ExpenseType | null
    category: $Enums.ExpenseCategory | null
    recurring: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    venueId: string | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    amount: number | null
    paymentDate: Date | null
    type: $Enums.ExpenseType | null
    category: $Enums.ExpenseCategory | null
    recurring: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    venueId: string | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    name: number
    description: number
    amount: number
    paymentDate: number
    type: number
    category: number
    recurring: number
    createdAt: number
    updatedAt: number
    venueId: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    amount?: true
    paymentDate?: true
    type?: true
    category?: true
    recurring?: true
    createdAt?: true
    updatedAt?: true
    venueId?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    amount?: true
    paymentDate?: true
    type?: true
    category?: true
    recurring?: true
    createdAt?: true
    updatedAt?: true
    venueId?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    amount?: true
    paymentDate?: true
    type?: true
    category?: true
    recurring?: true
    createdAt?: true
    updatedAt?: true
    venueId?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    name: string
    description: string | null
    amount: number
    paymentDate: Date
    type: $Enums.ExpenseType
    category: $Enums.ExpenseCategory
    recurring: boolean
    createdAt: Date
    updatedAt: Date
    venueId: string
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    amount?: boolean
    paymentDate?: boolean
    type?: boolean
    category?: boolean
    recurring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venueId?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>


  export type ExpenseSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    amount?: boolean
    paymentDate?: boolean
    type?: boolean
    category?: boolean
    recurring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venueId?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      amount: number
      paymentDate: Date
      type: $Enums.ExpenseType
      category: $Enums.ExpenseCategory
      recurring: boolean
      createdAt: Date
      updatedAt: Date
      venueId: string
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly name: FieldRef<"Expense", 'String'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly paymentDate: FieldRef<"Expense", 'DateTime'>
    readonly type: FieldRef<"Expense", 'ExpenseType'>
    readonly category: FieldRef<"Expense", 'ExpenseCategory'>
    readonly recurring: FieldRef<"Expense", 'Boolean'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
    readonly venueId: FieldRef<"Expense", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    venueId: string | null
    proposalId: string | null
    dateEventId: string | null
    content: string | null
    type: $Enums.NotificationType | null
    createdAt: Date | null
    isRead: boolean | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    venueId: string | null
    proposalId: string | null
    dateEventId: string | null
    content: string | null
    type: $Enums.NotificationType | null
    createdAt: Date | null
    isRead: boolean | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    venueId: number
    proposalId: number
    dateEventId: number
    content: number
    type: number
    createdAt: number
    isRead: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    venueId?: true
    proposalId?: true
    dateEventId?: true
    content?: true
    type?: true
    createdAt?: true
    isRead?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    venueId?: true
    proposalId?: true
    dateEventId?: true
    content?: true
    type?: true
    createdAt?: true
    isRead?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    venueId?: true
    proposalId?: true
    dateEventId?: true
    content?: true
    type?: true
    createdAt?: true
    isRead?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    venueId: string
    proposalId: string | null
    dateEventId: string | null
    content: string
    type: $Enums.NotificationType
    createdAt: Date
    isRead: boolean
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    proposalId?: boolean
    dateEventId?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    isRead?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    proposal?: boolean | Notification$proposalArgs<ExtArgs>
    dateEvent?: boolean | Notification$dateEventArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type NotificationSelectScalar = {
    id?: boolean
    venueId?: boolean
    proposalId?: boolean
    dateEventId?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    isRead?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    proposal?: boolean | Notification$proposalArgs<ExtArgs>
    dateEvent?: boolean | Notification$dateEventArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
      proposal: Prisma.$ProposalPayload<ExtArgs> | null
      dateEvent: Prisma.$DateEventPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueId: string
      proposalId: string | null
      dateEventId: string | null
      content: string
      type: $Enums.NotificationType
      createdAt: Date
      isRead: boolean
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    proposal<T extends Notification$proposalArgs<ExtArgs> = {}>(args?: Subset<T, Notification$proposalArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    dateEvent<T extends Notification$dateEventArgs<ExtArgs> = {}>(args?: Subset<T, Notification$dateEventArgs<ExtArgs>>): Prisma__DateEventClient<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly venueId: FieldRef<"Notification", 'String'>
    readonly proposalId: FieldRef<"Notification", 'String'>
    readonly dateEventId: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.proposal
   */
  export type Notification$proposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
  }

  /**
   * Notification.dateEvent
   */
  export type Notification$dateEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    where?: DateEventWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model DateEvent
   */

  export type AggregateDateEvent = {
    _count: DateEventCountAggregateOutputType | null
    _min: DateEventMinAggregateOutputType | null
    _max: DateEventMaxAggregateOutputType | null
  }

  export type DateEventMinAggregateOutputType = {
    id: string | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    proposalId: string | null
    venueId: string | null
    type: $Enums.DateEventType | null
  }

  export type DateEventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    proposalId: string | null
    venueId: string | null
    type: $Enums.DateEventType | null
  }

  export type DateEventCountAggregateOutputType = {
    id: number
    title: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    proposalId: number
    venueId: number
    type: number
    _all: number
  }


  export type DateEventMinAggregateInputType = {
    id?: true
    title?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    proposalId?: true
    venueId?: true
    type?: true
  }

  export type DateEventMaxAggregateInputType = {
    id?: true
    title?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    proposalId?: true
    venueId?: true
    type?: true
  }

  export type DateEventCountAggregateInputType = {
    id?: true
    title?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    proposalId?: true
    venueId?: true
    type?: true
    _all?: true
  }

  export type DateEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DateEvent to aggregate.
     */
    where?: DateEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DateEvents to fetch.
     */
    orderBy?: DateEventOrderByWithRelationInput | DateEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DateEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DateEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DateEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DateEvents
    **/
    _count?: true | DateEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DateEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DateEventMaxAggregateInputType
  }

  export type GetDateEventAggregateType<T extends DateEventAggregateArgs> = {
        [P in keyof T & keyof AggregateDateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDateEvent[P]>
      : GetScalarType<T[P], AggregateDateEvent[P]>
  }




  export type DateEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DateEventWhereInput
    orderBy?: DateEventOrderByWithAggregationInput | DateEventOrderByWithAggregationInput[]
    by: DateEventScalarFieldEnum[] | DateEventScalarFieldEnum
    having?: DateEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DateEventCountAggregateInputType | true
    _min?: DateEventMinAggregateInputType
    _max?: DateEventMaxAggregateInputType
  }

  export type DateEventGroupByOutputType = {
    id: string
    title: string
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    proposalId: string | null
    venueId: string
    type: $Enums.DateEventType
    _count: DateEventCountAggregateOutputType | null
    _min: DateEventMinAggregateOutputType | null
    _max: DateEventMaxAggregateOutputType | null
  }

  type GetDateEventGroupByPayload<T extends DateEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DateEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DateEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DateEventGroupByOutputType[P]>
            : GetScalarType<T[P], DateEventGroupByOutputType[P]>
        }
      >
    >


  export type DateEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proposalId?: boolean
    venueId?: boolean
    type?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    proposal?: boolean | DateEvent$proposalArgs<ExtArgs>
    notifications?: boolean | DateEvent$notificationsArgs<ExtArgs>
    _count?: boolean | DateEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dateEvent"]>


  export type DateEventSelectScalar = {
    id?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proposalId?: boolean
    venueId?: boolean
    type?: boolean
  }

  export type DateEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    proposal?: boolean | DateEvent$proposalArgs<ExtArgs>
    notifications?: boolean | DateEvent$notificationsArgs<ExtArgs>
    _count?: boolean | DateEventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DateEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DateEvent"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
      proposal: Prisma.$ProposalPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
      proposalId: string | null
      venueId: string
      type: $Enums.DateEventType
    }, ExtArgs["result"]["dateEvent"]>
    composites: {}
  }

  type DateEventGetPayload<S extends boolean | null | undefined | DateEventDefaultArgs> = $Result.GetResult<Prisma.$DateEventPayload, S>

  type DateEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DateEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DateEventCountAggregateInputType | true
    }

  export interface DateEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DateEvent'], meta: { name: 'DateEvent' } }
    /**
     * Find zero or one DateEvent that matches the filter.
     * @param {DateEventFindUniqueArgs} args - Arguments to find a DateEvent
     * @example
     * // Get one DateEvent
     * const dateEvent = await prisma.dateEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DateEventFindUniqueArgs>(args: SelectSubset<T, DateEventFindUniqueArgs<ExtArgs>>): Prisma__DateEventClient<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DateEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DateEventFindUniqueOrThrowArgs} args - Arguments to find a DateEvent
     * @example
     * // Get one DateEvent
     * const dateEvent = await prisma.dateEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DateEventFindUniqueOrThrowArgs>(args: SelectSubset<T, DateEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DateEventClient<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DateEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DateEventFindFirstArgs} args - Arguments to find a DateEvent
     * @example
     * // Get one DateEvent
     * const dateEvent = await prisma.dateEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DateEventFindFirstArgs>(args?: SelectSubset<T, DateEventFindFirstArgs<ExtArgs>>): Prisma__DateEventClient<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DateEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DateEventFindFirstOrThrowArgs} args - Arguments to find a DateEvent
     * @example
     * // Get one DateEvent
     * const dateEvent = await prisma.dateEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DateEventFindFirstOrThrowArgs>(args?: SelectSubset<T, DateEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__DateEventClient<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DateEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DateEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DateEvents
     * const dateEvents = await prisma.dateEvent.findMany()
     * 
     * // Get first 10 DateEvents
     * const dateEvents = await prisma.dateEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dateEventWithIdOnly = await prisma.dateEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DateEventFindManyArgs>(args?: SelectSubset<T, DateEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DateEvent.
     * @param {DateEventCreateArgs} args - Arguments to create a DateEvent.
     * @example
     * // Create one DateEvent
     * const DateEvent = await prisma.dateEvent.create({
     *   data: {
     *     // ... data to create a DateEvent
     *   }
     * })
     * 
     */
    create<T extends DateEventCreateArgs>(args: SelectSubset<T, DateEventCreateArgs<ExtArgs>>): Prisma__DateEventClient<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DateEvents.
     * @param {DateEventCreateManyArgs} args - Arguments to create many DateEvents.
     * @example
     * // Create many DateEvents
     * const dateEvent = await prisma.dateEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DateEventCreateManyArgs>(args?: SelectSubset<T, DateEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DateEvent.
     * @param {DateEventDeleteArgs} args - Arguments to delete one DateEvent.
     * @example
     * // Delete one DateEvent
     * const DateEvent = await prisma.dateEvent.delete({
     *   where: {
     *     // ... filter to delete one DateEvent
     *   }
     * })
     * 
     */
    delete<T extends DateEventDeleteArgs>(args: SelectSubset<T, DateEventDeleteArgs<ExtArgs>>): Prisma__DateEventClient<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DateEvent.
     * @param {DateEventUpdateArgs} args - Arguments to update one DateEvent.
     * @example
     * // Update one DateEvent
     * const dateEvent = await prisma.dateEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DateEventUpdateArgs>(args: SelectSubset<T, DateEventUpdateArgs<ExtArgs>>): Prisma__DateEventClient<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DateEvents.
     * @param {DateEventDeleteManyArgs} args - Arguments to filter DateEvents to delete.
     * @example
     * // Delete a few DateEvents
     * const { count } = await prisma.dateEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DateEventDeleteManyArgs>(args?: SelectSubset<T, DateEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DateEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DateEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DateEvents
     * const dateEvent = await prisma.dateEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DateEventUpdateManyArgs>(args: SelectSubset<T, DateEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DateEvent.
     * @param {DateEventUpsertArgs} args - Arguments to update or create a DateEvent.
     * @example
     * // Update or create a DateEvent
     * const dateEvent = await prisma.dateEvent.upsert({
     *   create: {
     *     // ... data to create a DateEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DateEvent we want to update
     *   }
     * })
     */
    upsert<T extends DateEventUpsertArgs>(args: SelectSubset<T, DateEventUpsertArgs<ExtArgs>>): Prisma__DateEventClient<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DateEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DateEventCountArgs} args - Arguments to filter DateEvents to count.
     * @example
     * // Count the number of DateEvents
     * const count = await prisma.dateEvent.count({
     *   where: {
     *     // ... the filter for the DateEvents we want to count
     *   }
     * })
    **/
    count<T extends DateEventCountArgs>(
      args?: Subset<T, DateEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DateEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DateEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DateEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DateEventAggregateArgs>(args: Subset<T, DateEventAggregateArgs>): Prisma.PrismaPromise<GetDateEventAggregateType<T>>

    /**
     * Group by DateEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DateEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DateEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DateEventGroupByArgs['orderBy'] }
        : { orderBy?: DateEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DateEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDateEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DateEvent model
   */
  readonly fields: DateEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DateEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DateEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    proposal<T extends DateEvent$proposalArgs<ExtArgs> = {}>(args?: Subset<T, DateEvent$proposalArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends DateEvent$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, DateEvent$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DateEvent model
   */ 
  interface DateEventFieldRefs {
    readonly id: FieldRef<"DateEvent", 'String'>
    readonly title: FieldRef<"DateEvent", 'String'>
    readonly startDate: FieldRef<"DateEvent", 'DateTime'>
    readonly endDate: FieldRef<"DateEvent", 'DateTime'>
    readonly createdAt: FieldRef<"DateEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"DateEvent", 'DateTime'>
    readonly proposalId: FieldRef<"DateEvent", 'String'>
    readonly venueId: FieldRef<"DateEvent", 'String'>
    readonly type: FieldRef<"DateEvent", 'DateEventType'>
  }
    

  // Custom InputTypes
  /**
   * DateEvent findUnique
   */
  export type DateEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    /**
     * Filter, which DateEvent to fetch.
     */
    where: DateEventWhereUniqueInput
  }

  /**
   * DateEvent findUniqueOrThrow
   */
  export type DateEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    /**
     * Filter, which DateEvent to fetch.
     */
    where: DateEventWhereUniqueInput
  }

  /**
   * DateEvent findFirst
   */
  export type DateEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    /**
     * Filter, which DateEvent to fetch.
     */
    where?: DateEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DateEvents to fetch.
     */
    orderBy?: DateEventOrderByWithRelationInput | DateEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DateEvents.
     */
    cursor?: DateEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DateEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DateEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DateEvents.
     */
    distinct?: DateEventScalarFieldEnum | DateEventScalarFieldEnum[]
  }

  /**
   * DateEvent findFirstOrThrow
   */
  export type DateEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    /**
     * Filter, which DateEvent to fetch.
     */
    where?: DateEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DateEvents to fetch.
     */
    orderBy?: DateEventOrderByWithRelationInput | DateEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DateEvents.
     */
    cursor?: DateEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DateEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DateEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DateEvents.
     */
    distinct?: DateEventScalarFieldEnum | DateEventScalarFieldEnum[]
  }

  /**
   * DateEvent findMany
   */
  export type DateEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    /**
     * Filter, which DateEvents to fetch.
     */
    where?: DateEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DateEvents to fetch.
     */
    orderBy?: DateEventOrderByWithRelationInput | DateEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DateEvents.
     */
    cursor?: DateEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DateEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DateEvents.
     */
    skip?: number
    distinct?: DateEventScalarFieldEnum | DateEventScalarFieldEnum[]
  }

  /**
   * DateEvent create
   */
  export type DateEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    /**
     * The data needed to create a DateEvent.
     */
    data: XOR<DateEventCreateInput, DateEventUncheckedCreateInput>
  }

  /**
   * DateEvent createMany
   */
  export type DateEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DateEvents.
     */
    data: DateEventCreateManyInput | DateEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DateEvent update
   */
  export type DateEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    /**
     * The data needed to update a DateEvent.
     */
    data: XOR<DateEventUpdateInput, DateEventUncheckedUpdateInput>
    /**
     * Choose, which DateEvent to update.
     */
    where: DateEventWhereUniqueInput
  }

  /**
   * DateEvent updateMany
   */
  export type DateEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DateEvents.
     */
    data: XOR<DateEventUpdateManyMutationInput, DateEventUncheckedUpdateManyInput>
    /**
     * Filter which DateEvents to update
     */
    where?: DateEventWhereInput
  }

  /**
   * DateEvent upsert
   */
  export type DateEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    /**
     * The filter to search for the DateEvent to update in case it exists.
     */
    where: DateEventWhereUniqueInput
    /**
     * In case the DateEvent found by the `where` argument doesn't exist, create a new DateEvent with this data.
     */
    create: XOR<DateEventCreateInput, DateEventUncheckedCreateInput>
    /**
     * In case the DateEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DateEventUpdateInput, DateEventUncheckedUpdateInput>
  }

  /**
   * DateEvent delete
   */
  export type DateEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    /**
     * Filter which DateEvent to delete.
     */
    where: DateEventWhereUniqueInput
  }

  /**
   * DateEvent deleteMany
   */
  export type DateEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DateEvents to delete
     */
    where?: DateEventWhereInput
  }

  /**
   * DateEvent.proposal
   */
  export type DateEvent$proposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
  }

  /**
   * DateEvent.notifications
   */
  export type DateEvent$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * DateEvent without action
   */
  export type DateEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
  }


  /**
   * Model Venue
   */

  export type AggregateVenue = {
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  export type VenueAvgAggregateOutputType = {
    pricePerPerson: number | null
    pricePerDay: number | null
    maxGuest: number | null
  }

  export type VenueSumAggregateOutputType = {
    pricePerPerson: number | null
    pricePerDay: number | null
    maxGuest: number | null
  }

  export type VenueMinAggregateOutputType = {
    id: string | null
    name: string | null
    street: string | null
    streetNumber: string | null
    complement: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    checkIn: string | null
    checkOut: string | null
    cep: string | null
    hasOvernightStay: boolean | null
    createdAt: Date | null
    organizationId: string | null
    pricingModel: $Enums.PricingModel | null
    pricePerPerson: number | null
    pricePerDay: number | null
    maxGuest: number | null
  }

  export type VenueMaxAggregateOutputType = {
    id: string | null
    name: string | null
    street: string | null
    streetNumber: string | null
    complement: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    checkIn: string | null
    checkOut: string | null
    cep: string | null
    hasOvernightStay: boolean | null
    createdAt: Date | null
    organizationId: string | null
    pricingModel: $Enums.PricingModel | null
    pricePerPerson: number | null
    pricePerDay: number | null
    maxGuest: number | null
  }

  export type VenueCountAggregateOutputType = {
    id: number
    name: number
    street: number
    streetNumber: number
    complement: number
    neighborhood: number
    city: number
    state: number
    checkIn: number
    checkOut: number
    cep: number
    hasOvernightStay: number
    createdAt: number
    organizationId: number
    pricingModel: number
    pricePerPerson: number
    pricePerDay: number
    maxGuest: number
    _all: number
  }


  export type VenueAvgAggregateInputType = {
    pricePerPerson?: true
    pricePerDay?: true
    maxGuest?: true
  }

  export type VenueSumAggregateInputType = {
    pricePerPerson?: true
    pricePerDay?: true
    maxGuest?: true
  }

  export type VenueMinAggregateInputType = {
    id?: true
    name?: true
    street?: true
    streetNumber?: true
    complement?: true
    neighborhood?: true
    city?: true
    state?: true
    checkIn?: true
    checkOut?: true
    cep?: true
    hasOvernightStay?: true
    createdAt?: true
    organizationId?: true
    pricingModel?: true
    pricePerPerson?: true
    pricePerDay?: true
    maxGuest?: true
  }

  export type VenueMaxAggregateInputType = {
    id?: true
    name?: true
    street?: true
    streetNumber?: true
    complement?: true
    neighborhood?: true
    city?: true
    state?: true
    checkIn?: true
    checkOut?: true
    cep?: true
    hasOvernightStay?: true
    createdAt?: true
    organizationId?: true
    pricingModel?: true
    pricePerPerson?: true
    pricePerDay?: true
    maxGuest?: true
  }

  export type VenueCountAggregateInputType = {
    id?: true
    name?: true
    street?: true
    streetNumber?: true
    complement?: true
    neighborhood?: true
    city?: true
    state?: true
    checkIn?: true
    checkOut?: true
    cep?: true
    hasOvernightStay?: true
    createdAt?: true
    organizationId?: true
    pricingModel?: true
    pricePerPerson?: true
    pricePerDay?: true
    maxGuest?: true
    _all?: true
  }

  export type VenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venue to aggregate.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Venues
    **/
    _count?: true | VenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueMaxAggregateInputType
  }

  export type GetVenueAggregateType<T extends VenueAggregateArgs> = {
        [P in keyof T & keyof AggregateVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenue[P]>
      : GetScalarType<T[P], AggregateVenue[P]>
  }




  export type VenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithAggregationInput | VenueOrderByWithAggregationInput[]
    by: VenueScalarFieldEnum[] | VenueScalarFieldEnum
    having?: VenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueCountAggregateInputType | true
    _avg?: VenueAvgAggregateInputType
    _sum?: VenueSumAggregateInputType
    _min?: VenueMinAggregateInputType
    _max?: VenueMaxAggregateInputType
  }

  export type VenueGroupByOutputType = {
    id: string
    name: string
    street: string
    streetNumber: string
    complement: string | null
    neighborhood: string
    city: string
    state: string
    checkIn: string | null
    checkOut: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt: Date
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson: number | null
    pricePerDay: number | null
    maxGuest: number
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  type GetVenueGroupByPayload<T extends VenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueGroupByOutputType[P]>
            : GetScalarType<T[P], VenueGroupByOutputType[P]>
        }
      >
    >


  export type VenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    street?: boolean
    streetNumber?: boolean
    complement?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    checkIn?: boolean
    checkOut?: boolean
    cep?: boolean
    hasOvernightStay?: boolean
    createdAt?: boolean
    organizationId?: boolean
    pricingModel?: boolean
    pricePerPerson?: boolean
    pricePerDay?: boolean
    maxGuest?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    texts?: boolean | Venue$textsArgs<ExtArgs>
    contacts?: boolean | Venue$contactsArgs<ExtArgs>
    images?: boolean | Venue$imagesArgs<ExtArgs>
    expenses?: boolean | Venue$expensesArgs<ExtArgs>
    services?: boolean | Venue$servicesArgs<ExtArgs>
    Payment?: boolean | Venue$PaymentArgs<ExtArgs>
    questions?: boolean | Venue$questionsArgs<ExtArgs>
    proposals?: boolean | Venue$proposalsArgs<ExtArgs>
    DateEvent?: boolean | Venue$DateEventArgs<ExtArgs>
    ownerVenue?: boolean | Venue$ownerVenueArgs<ExtArgs>
    notifications?: boolean | Venue$notificationsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>


  export type VenueSelectScalar = {
    id?: boolean
    name?: boolean
    street?: boolean
    streetNumber?: boolean
    complement?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    checkIn?: boolean
    checkOut?: boolean
    cep?: boolean
    hasOvernightStay?: boolean
    createdAt?: boolean
    organizationId?: boolean
    pricingModel?: boolean
    pricePerPerson?: boolean
    pricePerDay?: boolean
    maxGuest?: boolean
  }

  export type VenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    texts?: boolean | Venue$textsArgs<ExtArgs>
    contacts?: boolean | Venue$contactsArgs<ExtArgs>
    images?: boolean | Venue$imagesArgs<ExtArgs>
    expenses?: boolean | Venue$expensesArgs<ExtArgs>
    services?: boolean | Venue$servicesArgs<ExtArgs>
    Payment?: boolean | Venue$PaymentArgs<ExtArgs>
    questions?: boolean | Venue$questionsArgs<ExtArgs>
    proposals?: boolean | Venue$proposalsArgs<ExtArgs>
    DateEvent?: boolean | Venue$DateEventArgs<ExtArgs>
    ownerVenue?: boolean | Venue$ownerVenueArgs<ExtArgs>
    notifications?: boolean | Venue$notificationsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venue"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      texts: Prisma.$TextPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      images: Prisma.$ImagePayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
      Payment: Prisma.$PaymentPayload<ExtArgs>[]
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      proposals: Prisma.$ProposalPayload<ExtArgs>[]
      DateEvent: Prisma.$DateEventPayload<ExtArgs>[]
      ownerVenue: Prisma.$OwnerVenuePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      street: string
      streetNumber: string
      complement: string | null
      neighborhood: string
      city: string
      state: string
      checkIn: string | null
      checkOut: string | null
      cep: string
      hasOvernightStay: boolean
      createdAt: Date
      organizationId: string
      pricingModel: $Enums.PricingModel
      pricePerPerson: number | null
      pricePerDay: number | null
      maxGuest: number
    }, ExtArgs["result"]["venue"]>
    composites: {}
  }

  type VenueGetPayload<S extends boolean | null | undefined | VenueDefaultArgs> = $Result.GetResult<Prisma.$VenuePayload, S>

  type VenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VenueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VenueCountAggregateInputType | true
    }

  export interface VenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venue'], meta: { name: 'Venue' } }
    /**
     * Find zero or one Venue that matches the filter.
     * @param {VenueFindUniqueArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueFindUniqueArgs>(args: SelectSubset<T, VenueFindUniqueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Venue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VenueFindUniqueOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Venue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueFindFirstArgs>(args?: SelectSubset<T, VenueFindFirstArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Venue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venues
     * const venues = await prisma.venue.findMany()
     * 
     * // Get first 10 Venues
     * const venues = await prisma.venue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueWithIdOnly = await prisma.venue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueFindManyArgs>(args?: SelectSubset<T, VenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Venue.
     * @param {VenueCreateArgs} args - Arguments to create a Venue.
     * @example
     * // Create one Venue
     * const Venue = await prisma.venue.create({
     *   data: {
     *     // ... data to create a Venue
     *   }
     * })
     * 
     */
    create<T extends VenueCreateArgs>(args: SelectSubset<T, VenueCreateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Venues.
     * @param {VenueCreateManyArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueCreateManyArgs>(args?: SelectSubset<T, VenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Venue.
     * @param {VenueDeleteArgs} args - Arguments to delete one Venue.
     * @example
     * // Delete one Venue
     * const Venue = await prisma.venue.delete({
     *   where: {
     *     // ... filter to delete one Venue
     *   }
     * })
     * 
     */
    delete<T extends VenueDeleteArgs>(args: SelectSubset<T, VenueDeleteArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Venue.
     * @param {VenueUpdateArgs} args - Arguments to update one Venue.
     * @example
     * // Update one Venue
     * const venue = await prisma.venue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueUpdateArgs>(args: SelectSubset<T, VenueUpdateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Venues.
     * @param {VenueDeleteManyArgs} args - Arguments to filter Venues to delete.
     * @example
     * // Delete a few Venues
     * const { count } = await prisma.venue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueDeleteManyArgs>(args?: SelectSubset<T, VenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueUpdateManyArgs>(args: SelectSubset<T, VenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Venue.
     * @param {VenueUpsertArgs} args - Arguments to update or create a Venue.
     * @example
     * // Update or create a Venue
     * const venue = await prisma.venue.upsert({
     *   create: {
     *     // ... data to create a Venue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venue we want to update
     *   }
     * })
     */
    upsert<T extends VenueUpsertArgs>(args: SelectSubset<T, VenueUpsertArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueCountArgs} args - Arguments to filter Venues to count.
     * @example
     * // Count the number of Venues
     * const count = await prisma.venue.count({
     *   where: {
     *     // ... the filter for the Venues we want to count
     *   }
     * })
    **/
    count<T extends VenueCountArgs>(
      args?: Subset<T, VenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueAggregateArgs>(args: Subset<T, VenueAggregateArgs>): Prisma.PrismaPromise<GetVenueAggregateType<T>>

    /**
     * Group by Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueGroupByArgs['orderBy'] }
        : { orderBy?: VenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venue model
   */
  readonly fields: VenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    texts<T extends Venue$textsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$textsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextPayload<ExtArgs>, T, "findMany"> | Null>
    contacts<T extends Venue$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    images<T extends Venue$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany"> | Null>
    expenses<T extends Venue$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    services<T extends Venue$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany"> | Null>
    Payment<T extends Venue$PaymentArgs<ExtArgs> = {}>(args?: Subset<T, Venue$PaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    questions<T extends Venue$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany"> | Null>
    proposals<T extends Venue$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany"> | Null>
    DateEvent<T extends Venue$DateEventArgs<ExtArgs> = {}>(args?: Subset<T, Venue$DateEventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DateEventPayload<ExtArgs>, T, "findMany"> | Null>
    ownerVenue<T extends Venue$ownerVenueArgs<ExtArgs> = {}>(args?: Subset<T, Venue$ownerVenueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Venue$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Venue model
   */ 
  interface VenueFieldRefs {
    readonly id: FieldRef<"Venue", 'String'>
    readonly name: FieldRef<"Venue", 'String'>
    readonly street: FieldRef<"Venue", 'String'>
    readonly streetNumber: FieldRef<"Venue", 'String'>
    readonly complement: FieldRef<"Venue", 'String'>
    readonly neighborhood: FieldRef<"Venue", 'String'>
    readonly city: FieldRef<"Venue", 'String'>
    readonly state: FieldRef<"Venue", 'String'>
    readonly checkIn: FieldRef<"Venue", 'String'>
    readonly checkOut: FieldRef<"Venue", 'String'>
    readonly cep: FieldRef<"Venue", 'String'>
    readonly hasOvernightStay: FieldRef<"Venue", 'Boolean'>
    readonly createdAt: FieldRef<"Venue", 'DateTime'>
    readonly organizationId: FieldRef<"Venue", 'String'>
    readonly pricingModel: FieldRef<"Venue", 'PricingModel'>
    readonly pricePerPerson: FieldRef<"Venue", 'Float'>
    readonly pricePerDay: FieldRef<"Venue", 'Float'>
    readonly maxGuest: FieldRef<"Venue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Venue findUnique
   */
  export type VenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findUniqueOrThrow
   */
  export type VenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findFirst
   */
  export type VenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findFirstOrThrow
   */
  export type VenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findMany
   */
  export type VenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venues to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue create
   */
  export type VenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to create a Venue.
     */
    data: XOR<VenueCreateInput, VenueUncheckedCreateInput>
  }

  /**
   * Venue createMany
   */
  export type VenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venue update
   */
  export type VenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to update a Venue.
     */
    data: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
    /**
     * Choose, which Venue to update.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue updateMany
   */
  export type VenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
  }

  /**
   * Venue upsert
   */
  export type VenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The filter to search for the Venue to update in case it exists.
     */
    where: VenueWhereUniqueInput
    /**
     * In case the Venue found by the `where` argument doesn't exist, create a new Venue with this data.
     */
    create: XOR<VenueCreateInput, VenueUncheckedCreateInput>
    /**
     * In case the Venue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
  }

  /**
   * Venue delete
   */
  export type VenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter which Venue to delete.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue deleteMany
   */
  export type VenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venues to delete
     */
    where?: VenueWhereInput
  }

  /**
   * Venue.texts
   */
  export type Venue$textsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
    where?: TextWhereInput
    orderBy?: TextOrderByWithRelationInput | TextOrderByWithRelationInput[]
    cursor?: TextWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TextScalarFieldEnum | TextScalarFieldEnum[]
  }

  /**
   * Venue.contacts
   */
  export type Venue$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Venue.images
   */
  export type Venue$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Venue.expenses
   */
  export type Venue$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Venue.services
   */
  export type Venue$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Venue.Payment
   */
  export type Venue$PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Venue.questions
   */
  export type Venue$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Venue.proposals
   */
  export type Venue$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Venue.DateEvent
   */
  export type Venue$DateEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DateEvent
     */
    select?: DateEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DateEventInclude<ExtArgs> | null
    where?: DateEventWhereInput
    orderBy?: DateEventOrderByWithRelationInput | DateEventOrderByWithRelationInput[]
    cursor?: DateEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DateEventScalarFieldEnum | DateEventScalarFieldEnum[]
  }

  /**
   * Venue.ownerVenue
   */
  export type Venue$ownerVenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    where?: OwnerVenueWhereInput
    orderBy?: OwnerVenueOrderByWithRelationInput | OwnerVenueOrderByWithRelationInput[]
    cursor?: OwnerVenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerVenueScalarFieldEnum | OwnerVenueScalarFieldEnum[]
  }

  /**
   * Venue.notifications
   */
  export type Venue$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Venue without action
   */
  export type VenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    whatsapp: string | null
    venueId: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    whatsapp: string | null
    venueId: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    role: number
    whatsapp: number
    venueId: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    whatsapp?: true
    venueId?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    whatsapp?: true
    venueId?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    whatsapp?: true
    venueId?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    name: string
    role: string
    whatsapp: string
    venueId: string
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    whatsapp?: boolean
    venueId?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>


  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    whatsapp?: boolean
    venueId?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      whatsapp: string
      venueId: string
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly role: FieldRef<"Contact", 'String'>
    readonly whatsapp: FieldRef<"Contact", 'String'>
    readonly venueId: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model OwnerVenue
   */

  export type AggregateOwnerVenue = {
    _count: OwnerVenueCountAggregateOutputType | null
    _min: OwnerVenueMinAggregateOutputType | null
    _max: OwnerVenueMaxAggregateOutputType | null
  }

  export type OwnerVenueMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    venueId: string | null
    role: $Enums.Role | null
    joinedAt: Date | null
  }

  export type OwnerVenueMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    venueId: string | null
    role: $Enums.Role | null
    joinedAt: Date | null
  }

  export type OwnerVenueCountAggregateOutputType = {
    id: number
    ownerId: number
    venueId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type OwnerVenueMinAggregateInputType = {
    id?: true
    ownerId?: true
    venueId?: true
    role?: true
    joinedAt?: true
  }

  export type OwnerVenueMaxAggregateInputType = {
    id?: true
    ownerId?: true
    venueId?: true
    role?: true
    joinedAt?: true
  }

  export type OwnerVenueCountAggregateInputType = {
    id?: true
    ownerId?: true
    venueId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type OwnerVenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerVenue to aggregate.
     */
    where?: OwnerVenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerVenues to fetch.
     */
    orderBy?: OwnerVenueOrderByWithRelationInput | OwnerVenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerVenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerVenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerVenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerVenues
    **/
    _count?: true | OwnerVenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerVenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerVenueMaxAggregateInputType
  }

  export type GetOwnerVenueAggregateType<T extends OwnerVenueAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerVenue[P]>
      : GetScalarType<T[P], AggregateOwnerVenue[P]>
  }




  export type OwnerVenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerVenueWhereInput
    orderBy?: OwnerVenueOrderByWithAggregationInput | OwnerVenueOrderByWithAggregationInput[]
    by: OwnerVenueScalarFieldEnum[] | OwnerVenueScalarFieldEnum
    having?: OwnerVenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerVenueCountAggregateInputType | true
    _min?: OwnerVenueMinAggregateInputType
    _max?: OwnerVenueMaxAggregateInputType
  }

  export type OwnerVenueGroupByOutputType = {
    id: string
    ownerId: string
    venueId: string
    role: $Enums.Role
    joinedAt: Date
    _count: OwnerVenueCountAggregateOutputType | null
    _min: OwnerVenueMinAggregateOutputType | null
    _max: OwnerVenueMaxAggregateOutputType | null
  }

  type GetOwnerVenueGroupByPayload<T extends OwnerVenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerVenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerVenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerVenueGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerVenueGroupByOutputType[P]>
        }
      >
    >


  export type OwnerVenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    venueId?: boolean
    role?: boolean
    joinedAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerVenue"]>


  export type OwnerVenueSelectScalar = {
    id?: boolean
    ownerId?: boolean
    venueId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type OwnerVenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $OwnerVenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerVenue"
    objects: {
      owner: Prisma.$OwnerPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      venueId: string
      role: $Enums.Role
      joinedAt: Date
    }, ExtArgs["result"]["ownerVenue"]>
    composites: {}
  }

  type OwnerVenueGetPayload<S extends boolean | null | undefined | OwnerVenueDefaultArgs> = $Result.GetResult<Prisma.$OwnerVenuePayload, S>

  type OwnerVenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OwnerVenueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OwnerVenueCountAggregateInputType | true
    }

  export interface OwnerVenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerVenue'], meta: { name: 'OwnerVenue' } }
    /**
     * Find zero or one OwnerVenue that matches the filter.
     * @param {OwnerVenueFindUniqueArgs} args - Arguments to find a OwnerVenue
     * @example
     * // Get one OwnerVenue
     * const ownerVenue = await prisma.ownerVenue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerVenueFindUniqueArgs>(args: SelectSubset<T, OwnerVenueFindUniqueArgs<ExtArgs>>): Prisma__OwnerVenueClient<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OwnerVenue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OwnerVenueFindUniqueOrThrowArgs} args - Arguments to find a OwnerVenue
     * @example
     * // Get one OwnerVenue
     * const ownerVenue = await prisma.ownerVenue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerVenueFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerVenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerVenueClient<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OwnerVenue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVenueFindFirstArgs} args - Arguments to find a OwnerVenue
     * @example
     * // Get one OwnerVenue
     * const ownerVenue = await prisma.ownerVenue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerVenueFindFirstArgs>(args?: SelectSubset<T, OwnerVenueFindFirstArgs<ExtArgs>>): Prisma__OwnerVenueClient<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OwnerVenue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVenueFindFirstOrThrowArgs} args - Arguments to find a OwnerVenue
     * @example
     * // Get one OwnerVenue
     * const ownerVenue = await prisma.ownerVenue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerVenueFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerVenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerVenueClient<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OwnerVenues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerVenues
     * const ownerVenues = await prisma.ownerVenue.findMany()
     * 
     * // Get first 10 OwnerVenues
     * const ownerVenues = await prisma.ownerVenue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerVenueWithIdOnly = await prisma.ownerVenue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnerVenueFindManyArgs>(args?: SelectSubset<T, OwnerVenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OwnerVenue.
     * @param {OwnerVenueCreateArgs} args - Arguments to create a OwnerVenue.
     * @example
     * // Create one OwnerVenue
     * const OwnerVenue = await prisma.ownerVenue.create({
     *   data: {
     *     // ... data to create a OwnerVenue
     *   }
     * })
     * 
     */
    create<T extends OwnerVenueCreateArgs>(args: SelectSubset<T, OwnerVenueCreateArgs<ExtArgs>>): Prisma__OwnerVenueClient<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OwnerVenues.
     * @param {OwnerVenueCreateManyArgs} args - Arguments to create many OwnerVenues.
     * @example
     * // Create many OwnerVenues
     * const ownerVenue = await prisma.ownerVenue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerVenueCreateManyArgs>(args?: SelectSubset<T, OwnerVenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OwnerVenue.
     * @param {OwnerVenueDeleteArgs} args - Arguments to delete one OwnerVenue.
     * @example
     * // Delete one OwnerVenue
     * const OwnerVenue = await prisma.ownerVenue.delete({
     *   where: {
     *     // ... filter to delete one OwnerVenue
     *   }
     * })
     * 
     */
    delete<T extends OwnerVenueDeleteArgs>(args: SelectSubset<T, OwnerVenueDeleteArgs<ExtArgs>>): Prisma__OwnerVenueClient<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OwnerVenue.
     * @param {OwnerVenueUpdateArgs} args - Arguments to update one OwnerVenue.
     * @example
     * // Update one OwnerVenue
     * const ownerVenue = await prisma.ownerVenue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerVenueUpdateArgs>(args: SelectSubset<T, OwnerVenueUpdateArgs<ExtArgs>>): Prisma__OwnerVenueClient<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OwnerVenues.
     * @param {OwnerVenueDeleteManyArgs} args - Arguments to filter OwnerVenues to delete.
     * @example
     * // Delete a few OwnerVenues
     * const { count } = await prisma.ownerVenue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerVenueDeleteManyArgs>(args?: SelectSubset<T, OwnerVenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerVenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerVenues
     * const ownerVenue = await prisma.ownerVenue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerVenueUpdateManyArgs>(args: SelectSubset<T, OwnerVenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OwnerVenue.
     * @param {OwnerVenueUpsertArgs} args - Arguments to update or create a OwnerVenue.
     * @example
     * // Update or create a OwnerVenue
     * const ownerVenue = await prisma.ownerVenue.upsert({
     *   create: {
     *     // ... data to create a OwnerVenue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerVenue we want to update
     *   }
     * })
     */
    upsert<T extends OwnerVenueUpsertArgs>(args: SelectSubset<T, OwnerVenueUpsertArgs<ExtArgs>>): Prisma__OwnerVenueClient<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OwnerVenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVenueCountArgs} args - Arguments to filter OwnerVenues to count.
     * @example
     * // Count the number of OwnerVenues
     * const count = await prisma.ownerVenue.count({
     *   where: {
     *     // ... the filter for the OwnerVenues we want to count
     *   }
     * })
    **/
    count<T extends OwnerVenueCountArgs>(
      args?: Subset<T, OwnerVenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerVenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerVenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerVenueAggregateArgs>(args: Subset<T, OwnerVenueAggregateArgs>): Prisma.PrismaPromise<GetOwnerVenueAggregateType<T>>

    /**
     * Group by OwnerVenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerVenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerVenueGroupByArgs['orderBy'] }
        : { orderBy?: OwnerVenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerVenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerVenue model
   */
  readonly fields: OwnerVenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerVenue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerVenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OwnerVenue model
   */ 
  interface OwnerVenueFieldRefs {
    readonly id: FieldRef<"OwnerVenue", 'String'>
    readonly ownerId: FieldRef<"OwnerVenue", 'String'>
    readonly venueId: FieldRef<"OwnerVenue", 'String'>
    readonly role: FieldRef<"OwnerVenue", 'Role'>
    readonly joinedAt: FieldRef<"OwnerVenue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OwnerVenue findUnique
   */
  export type OwnerVenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    /**
     * Filter, which OwnerVenue to fetch.
     */
    where: OwnerVenueWhereUniqueInput
  }

  /**
   * OwnerVenue findUniqueOrThrow
   */
  export type OwnerVenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    /**
     * Filter, which OwnerVenue to fetch.
     */
    where: OwnerVenueWhereUniqueInput
  }

  /**
   * OwnerVenue findFirst
   */
  export type OwnerVenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    /**
     * Filter, which OwnerVenue to fetch.
     */
    where?: OwnerVenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerVenues to fetch.
     */
    orderBy?: OwnerVenueOrderByWithRelationInput | OwnerVenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerVenues.
     */
    cursor?: OwnerVenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerVenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerVenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerVenues.
     */
    distinct?: OwnerVenueScalarFieldEnum | OwnerVenueScalarFieldEnum[]
  }

  /**
   * OwnerVenue findFirstOrThrow
   */
  export type OwnerVenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    /**
     * Filter, which OwnerVenue to fetch.
     */
    where?: OwnerVenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerVenues to fetch.
     */
    orderBy?: OwnerVenueOrderByWithRelationInput | OwnerVenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerVenues.
     */
    cursor?: OwnerVenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerVenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerVenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerVenues.
     */
    distinct?: OwnerVenueScalarFieldEnum | OwnerVenueScalarFieldEnum[]
  }

  /**
   * OwnerVenue findMany
   */
  export type OwnerVenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    /**
     * Filter, which OwnerVenues to fetch.
     */
    where?: OwnerVenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerVenues to fetch.
     */
    orderBy?: OwnerVenueOrderByWithRelationInput | OwnerVenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerVenues.
     */
    cursor?: OwnerVenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerVenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerVenues.
     */
    skip?: number
    distinct?: OwnerVenueScalarFieldEnum | OwnerVenueScalarFieldEnum[]
  }

  /**
   * OwnerVenue create
   */
  export type OwnerVenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerVenue.
     */
    data: XOR<OwnerVenueCreateInput, OwnerVenueUncheckedCreateInput>
  }

  /**
   * OwnerVenue createMany
   */
  export type OwnerVenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerVenues.
     */
    data: OwnerVenueCreateManyInput | OwnerVenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerVenue update
   */
  export type OwnerVenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerVenue.
     */
    data: XOR<OwnerVenueUpdateInput, OwnerVenueUncheckedUpdateInput>
    /**
     * Choose, which OwnerVenue to update.
     */
    where: OwnerVenueWhereUniqueInput
  }

  /**
   * OwnerVenue updateMany
   */
  export type OwnerVenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerVenues.
     */
    data: XOR<OwnerVenueUpdateManyMutationInput, OwnerVenueUncheckedUpdateManyInput>
    /**
     * Filter which OwnerVenues to update
     */
    where?: OwnerVenueWhereInput
  }

  /**
   * OwnerVenue upsert
   */
  export type OwnerVenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerVenue to update in case it exists.
     */
    where: OwnerVenueWhereUniqueInput
    /**
     * In case the OwnerVenue found by the `where` argument doesn't exist, create a new OwnerVenue with this data.
     */
    create: XOR<OwnerVenueCreateInput, OwnerVenueUncheckedCreateInput>
    /**
     * In case the OwnerVenue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerVenueUpdateInput, OwnerVenueUncheckedUpdateInput>
  }

  /**
   * OwnerVenue delete
   */
  export type OwnerVenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    /**
     * Filter which OwnerVenue to delete.
     */
    where: OwnerVenueWhereUniqueInput
  }

  /**
   * OwnerVenue deleteMany
   */
  export type OwnerVenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerVenues to delete
     */
    where?: OwnerVenueWhereInput
  }

  /**
   * OwnerVenue without action
   */
  export type OwnerVenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
  }


  /**
   * Model Owner
   */

  export type AggregateOwner = {
    _count: OwnerCountAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  export type OwnerMinAggregateOutputType = {
    id: string | null
    completeName: string | null
    rg: string | null
    cpf: string | null
    pix: string | null
    street: string | null
    streetNumber: string | null
    complement: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    bankName: string | null
    bankAgency: string | null
    cep: string | null
    createdAt: Date | null
    bankAccountNumber: string | null
    organizationId: string | null
  }

  export type OwnerMaxAggregateOutputType = {
    id: string | null
    completeName: string | null
    rg: string | null
    cpf: string | null
    pix: string | null
    street: string | null
    streetNumber: string | null
    complement: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    bankName: string | null
    bankAgency: string | null
    cep: string | null
    createdAt: Date | null
    bankAccountNumber: string | null
    organizationId: string | null
  }

  export type OwnerCountAggregateOutputType = {
    id: number
    completeName: number
    rg: number
    cpf: number
    pix: number
    street: number
    streetNumber: number
    complement: number
    neighborhood: number
    city: number
    state: number
    bankName: number
    bankAgency: number
    cep: number
    createdAt: number
    bankAccountNumber: number
    organizationId: number
    _all: number
  }


  export type OwnerMinAggregateInputType = {
    id?: true
    completeName?: true
    rg?: true
    cpf?: true
    pix?: true
    street?: true
    streetNumber?: true
    complement?: true
    neighborhood?: true
    city?: true
    state?: true
    bankName?: true
    bankAgency?: true
    cep?: true
    createdAt?: true
    bankAccountNumber?: true
    organizationId?: true
  }

  export type OwnerMaxAggregateInputType = {
    id?: true
    completeName?: true
    rg?: true
    cpf?: true
    pix?: true
    street?: true
    streetNumber?: true
    complement?: true
    neighborhood?: true
    city?: true
    state?: true
    bankName?: true
    bankAgency?: true
    cep?: true
    createdAt?: true
    bankAccountNumber?: true
    organizationId?: true
  }

  export type OwnerCountAggregateInputType = {
    id?: true
    completeName?: true
    rg?: true
    cpf?: true
    pix?: true
    street?: true
    streetNumber?: true
    complement?: true
    neighborhood?: true
    city?: true
    state?: true
    bankName?: true
    bankAgency?: true
    cep?: true
    createdAt?: true
    bankAccountNumber?: true
    organizationId?: true
    _all?: true
  }

  export type OwnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owner to aggregate.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Owners
    **/
    _count?: true | OwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerMaxAggregateInputType
  }

  export type GetOwnerAggregateType<T extends OwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwner[P]>
      : GetScalarType<T[P], AggregateOwner[P]>
  }




  export type OwnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByWithAggregationInput | OwnerOrderByWithAggregationInput[]
    by: OwnerScalarFieldEnum[] | OwnerScalarFieldEnum
    having?: OwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerCountAggregateInputType | true
    _min?: OwnerMinAggregateInputType
    _max?: OwnerMaxAggregateInputType
  }

  export type OwnerGroupByOutputType = {
    id: string
    completeName: string
    rg: string | null
    cpf: string
    pix: string
    street: string
    streetNumber: string
    complement: string | null
    neighborhood: string
    city: string
    state: string
    bankName: string
    bankAgency: string
    cep: string
    createdAt: Date
    bankAccountNumber: string
    organizationId: string
    _count: OwnerCountAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  type GetOwnerGroupByPayload<T extends OwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerGroupByOutputType[P]>
        }
      >
    >


  export type OwnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    completeName?: boolean
    rg?: boolean
    cpf?: boolean
    pix?: boolean
    street?: boolean
    streetNumber?: boolean
    complement?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    bankName?: boolean
    bankAgency?: boolean
    cep?: boolean
    createdAt?: boolean
    bankAccountNumber?: boolean
    organizationId?: boolean
    ownerVenue?: boolean | Owner$ownerVenueArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["owner"]>


  export type OwnerSelectScalar = {
    id?: boolean
    completeName?: boolean
    rg?: boolean
    cpf?: boolean
    pix?: boolean
    street?: boolean
    streetNumber?: boolean
    complement?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    bankName?: boolean
    bankAgency?: boolean
    cep?: boolean
    createdAt?: boolean
    bankAccountNumber?: boolean
    organizationId?: boolean
  }

  export type OwnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerVenue?: boolean | Owner$ownerVenueArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OwnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Owner"
    objects: {
      ownerVenue: Prisma.$OwnerVenuePayload<ExtArgs>[]
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      completeName: string
      rg: string | null
      cpf: string
      pix: string
      street: string
      streetNumber: string
      complement: string | null
      neighborhood: string
      city: string
      state: string
      bankName: string
      bankAgency: string
      cep: string
      createdAt: Date
      bankAccountNumber: string
      organizationId: string
    }, ExtArgs["result"]["owner"]>
    composites: {}
  }

  type OwnerGetPayload<S extends boolean | null | undefined | OwnerDefaultArgs> = $Result.GetResult<Prisma.$OwnerPayload, S>

  type OwnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OwnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OwnerCountAggregateInputType | true
    }

  export interface OwnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Owner'], meta: { name: 'Owner' } }
    /**
     * Find zero or one Owner that matches the filter.
     * @param {OwnerFindUniqueArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerFindUniqueArgs>(args: SelectSubset<T, OwnerFindUniqueArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Owner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OwnerFindUniqueOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Owner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerFindFirstArgs>(args?: SelectSubset<T, OwnerFindFirstArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Owner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Owners
     * const owners = await prisma.owner.findMany()
     * 
     * // Get first 10 Owners
     * const owners = await prisma.owner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerWithIdOnly = await prisma.owner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnerFindManyArgs>(args?: SelectSubset<T, OwnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Owner.
     * @param {OwnerCreateArgs} args - Arguments to create a Owner.
     * @example
     * // Create one Owner
     * const Owner = await prisma.owner.create({
     *   data: {
     *     // ... data to create a Owner
     *   }
     * })
     * 
     */
    create<T extends OwnerCreateArgs>(args: SelectSubset<T, OwnerCreateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Owners.
     * @param {OwnerCreateManyArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerCreateManyArgs>(args?: SelectSubset<T, OwnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Owner.
     * @param {OwnerDeleteArgs} args - Arguments to delete one Owner.
     * @example
     * // Delete one Owner
     * const Owner = await prisma.owner.delete({
     *   where: {
     *     // ... filter to delete one Owner
     *   }
     * })
     * 
     */
    delete<T extends OwnerDeleteArgs>(args: SelectSubset<T, OwnerDeleteArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Owner.
     * @param {OwnerUpdateArgs} args - Arguments to update one Owner.
     * @example
     * // Update one Owner
     * const owner = await prisma.owner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerUpdateArgs>(args: SelectSubset<T, OwnerUpdateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Owners.
     * @param {OwnerDeleteManyArgs} args - Arguments to filter Owners to delete.
     * @example
     * // Delete a few Owners
     * const { count } = await prisma.owner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerDeleteManyArgs>(args?: SelectSubset<T, OwnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Owners
     * const owner = await prisma.owner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerUpdateManyArgs>(args: SelectSubset<T, OwnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Owner.
     * @param {OwnerUpsertArgs} args - Arguments to update or create a Owner.
     * @example
     * // Update or create a Owner
     * const owner = await prisma.owner.upsert({
     *   create: {
     *     // ... data to create a Owner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Owner we want to update
     *   }
     * })
     */
    upsert<T extends OwnerUpsertArgs>(args: SelectSubset<T, OwnerUpsertArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCountArgs} args - Arguments to filter Owners to count.
     * @example
     * // Count the number of Owners
     * const count = await prisma.owner.count({
     *   where: {
     *     // ... the filter for the Owners we want to count
     *   }
     * })
    **/
    count<T extends OwnerCountArgs>(
      args?: Subset<T, OwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerAggregateArgs>(args: Subset<T, OwnerAggregateArgs>): Prisma.PrismaPromise<GetOwnerAggregateType<T>>

    /**
     * Group by Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerGroupByArgs['orderBy'] }
        : { orderBy?: OwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Owner model
   */
  readonly fields: OwnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Owner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownerVenue<T extends Owner$ownerVenueArgs<ExtArgs> = {}>(args?: Subset<T, Owner$ownerVenueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerVenuePayload<ExtArgs>, T, "findMany"> | Null>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Owner model
   */ 
  interface OwnerFieldRefs {
    readonly id: FieldRef<"Owner", 'String'>
    readonly completeName: FieldRef<"Owner", 'String'>
    readonly rg: FieldRef<"Owner", 'String'>
    readonly cpf: FieldRef<"Owner", 'String'>
    readonly pix: FieldRef<"Owner", 'String'>
    readonly street: FieldRef<"Owner", 'String'>
    readonly streetNumber: FieldRef<"Owner", 'String'>
    readonly complement: FieldRef<"Owner", 'String'>
    readonly neighborhood: FieldRef<"Owner", 'String'>
    readonly city: FieldRef<"Owner", 'String'>
    readonly state: FieldRef<"Owner", 'String'>
    readonly bankName: FieldRef<"Owner", 'String'>
    readonly bankAgency: FieldRef<"Owner", 'String'>
    readonly cep: FieldRef<"Owner", 'String'>
    readonly createdAt: FieldRef<"Owner", 'DateTime'>
    readonly bankAccountNumber: FieldRef<"Owner", 'String'>
    readonly organizationId: FieldRef<"Owner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Owner findUnique
   */
  export type OwnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findUniqueOrThrow
   */
  export type OwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findFirst
   */
  export type OwnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findFirstOrThrow
   */
  export type OwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findMany
   */
  export type OwnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owners to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner create
   */
  export type OwnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Owner.
     */
    data: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
  }

  /**
   * Owner createMany
   */
  export type OwnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Owner update
   */
  export type OwnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Owner.
     */
    data: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
    /**
     * Choose, which Owner to update.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner updateMany
   */
  export type OwnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Owners.
     */
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyInput>
    /**
     * Filter which Owners to update
     */
    where?: OwnerWhereInput
  }

  /**
   * Owner upsert
   */
  export type OwnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Owner to update in case it exists.
     */
    where: OwnerWhereUniqueInput
    /**
     * In case the Owner found by the `where` argument doesn't exist, create a new Owner with this data.
     */
    create: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
    /**
     * In case the Owner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
  }

  /**
   * Owner delete
   */
  export type OwnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter which Owner to delete.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner deleteMany
   */
  export type OwnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owners to delete
     */
    where?: OwnerWhereInput
  }

  /**
   * Owner.ownerVenue
   */
  export type Owner$ownerVenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVenue
     */
    select?: OwnerVenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVenueInclude<ExtArgs> | null
    where?: OwnerVenueWhereInput
    orderBy?: OwnerVenueOrderByWithRelationInput | OwnerVenueOrderByWithRelationInput[]
    cursor?: OwnerVenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerVenueScalarFieldEnum | OwnerVenueScalarFieldEnum[]
  }

  /**
   * Owner without action
   */
  export type OwnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    position: number | null
  }

  export type ImageSumAggregateOutputType = {
    position: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    description: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    responsiveMode: string | null
    tag: string | null
    venueId: string | null
  }

  export type ImageMaxAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    description: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    responsiveMode: string | null
    tag: string | null
    venueId: string | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    imageUrl: number
    description: number
    position: number
    createdAt: number
    updatedAt: number
    responsiveMode: number
    tag: number
    venueId: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    position?: true
  }

  export type ImageSumAggregateInputType = {
    position?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    imageUrl?: true
    description?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    responsiveMode?: true
    tag?: true
    venueId?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    description?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    responsiveMode?: true
    tag?: true
    venueId?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    imageUrl?: true
    description?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    responsiveMode?: true
    tag?: true
    venueId?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: string
    imageUrl: string
    description: string | null
    position: number
    createdAt: Date | null
    updatedAt: Date | null
    responsiveMode: string | null
    tag: string | null
    venueId: string
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    description?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsiveMode?: boolean
    tag?: boolean
    venueId?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>


  export type ImageSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    description?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsiveMode?: boolean
    tag?: boolean
    venueId?: boolean
  }

  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      imageUrl: string
      description: string | null
      position: number
      createdAt: Date | null
      updatedAt: Date | null
      responsiveMode: string | null
      tag: string | null
      venueId: string
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */ 
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'String'>
    readonly imageUrl: FieldRef<"Image", 'String'>
    readonly description: FieldRef<"Image", 'String'>
    readonly position: FieldRef<"Image", 'Int'>
    readonly createdAt: FieldRef<"Image", 'DateTime'>
    readonly updatedAt: FieldRef<"Image", 'DateTime'>
    readonly responsiveMode: FieldRef<"Image", 'String'>
    readonly tag: FieldRef<"Image", 'String'>
    readonly venueId: FieldRef<"Image", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model Text
   */

  export type AggregateText = {
    _count: TextCountAggregateOutputType | null
    _avg: TextAvgAggregateOutputType | null
    _sum: TextSumAggregateOutputType | null
    _min: TextMinAggregateOutputType | null
    _max: TextMaxAggregateOutputType | null
  }

  export type TextAvgAggregateOutputType = {
    position: number | null
  }

  export type TextSumAggregateOutputType = {
    position: number | null
  }

  export type TextMinAggregateOutputType = {
    id: string | null
    area: string | null
    title: string | null
    position: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
    venueId: string | null
  }

  export type TextMaxAggregateOutputType = {
    id: string | null
    area: string | null
    title: string | null
    position: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
    venueId: string | null
  }

  export type TextCountAggregateOutputType = {
    id: number
    area: number
    title: number
    position: number
    text: number
    createdAt: number
    updatedAt: number
    venueId: number
    _all: number
  }


  export type TextAvgAggregateInputType = {
    position?: true
  }

  export type TextSumAggregateInputType = {
    position?: true
  }

  export type TextMinAggregateInputType = {
    id?: true
    area?: true
    title?: true
    position?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    venueId?: true
  }

  export type TextMaxAggregateInputType = {
    id?: true
    area?: true
    title?: true
    position?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    venueId?: true
  }

  export type TextCountAggregateInputType = {
    id?: true
    area?: true
    title?: true
    position?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    venueId?: true
    _all?: true
  }

  export type TextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Text to aggregate.
     */
    where?: TextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Texts to fetch.
     */
    orderBy?: TextOrderByWithRelationInput | TextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Texts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Texts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Texts
    **/
    _count?: true | TextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TextAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TextSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TextMaxAggregateInputType
  }

  export type GetTextAggregateType<T extends TextAggregateArgs> = {
        [P in keyof T & keyof AggregateText]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateText[P]>
      : GetScalarType<T[P], AggregateText[P]>
  }




  export type TextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextWhereInput
    orderBy?: TextOrderByWithAggregationInput | TextOrderByWithAggregationInput[]
    by: TextScalarFieldEnum[] | TextScalarFieldEnum
    having?: TextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TextCountAggregateInputType | true
    _avg?: TextAvgAggregateInputType
    _sum?: TextSumAggregateInputType
    _min?: TextMinAggregateInputType
    _max?: TextMaxAggregateInputType
  }

  export type TextGroupByOutputType = {
    id: string
    area: string
    title: string | null
    position: number
    text: string
    createdAt: Date
    updatedAt: Date
    venueId: string
    _count: TextCountAggregateOutputType | null
    _avg: TextAvgAggregateOutputType | null
    _sum: TextSumAggregateOutputType | null
    _min: TextMinAggregateOutputType | null
    _max: TextMaxAggregateOutputType | null
  }

  type GetTextGroupByPayload<T extends TextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TextGroupByOutputType[P]>
            : GetScalarType<T[P], TextGroupByOutputType[P]>
        }
      >
    >


  export type TextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area?: boolean
    title?: boolean
    position?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venueId?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["text"]>


  export type TextSelectScalar = {
    id?: boolean
    area?: boolean
    title?: boolean
    position?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venueId?: boolean
  }

  export type TextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $TextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Text"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      area: string
      title: string | null
      position: number
      text: string
      createdAt: Date
      updatedAt: Date
      venueId: string
    }, ExtArgs["result"]["text"]>
    composites: {}
  }

  type TextGetPayload<S extends boolean | null | undefined | TextDefaultArgs> = $Result.GetResult<Prisma.$TextPayload, S>

  type TextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TextFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TextCountAggregateInputType | true
    }

  export interface TextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Text'], meta: { name: 'Text' } }
    /**
     * Find zero or one Text that matches the filter.
     * @param {TextFindUniqueArgs} args - Arguments to find a Text
     * @example
     * // Get one Text
     * const text = await prisma.text.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TextFindUniqueArgs>(args: SelectSubset<T, TextFindUniqueArgs<ExtArgs>>): Prisma__TextClient<$Result.GetResult<Prisma.$TextPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Text that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TextFindUniqueOrThrowArgs} args - Arguments to find a Text
     * @example
     * // Get one Text
     * const text = await prisma.text.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TextFindUniqueOrThrowArgs>(args: SelectSubset<T, TextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TextClient<$Result.GetResult<Prisma.$TextPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Text that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextFindFirstArgs} args - Arguments to find a Text
     * @example
     * // Get one Text
     * const text = await prisma.text.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TextFindFirstArgs>(args?: SelectSubset<T, TextFindFirstArgs<ExtArgs>>): Prisma__TextClient<$Result.GetResult<Prisma.$TextPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Text that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextFindFirstOrThrowArgs} args - Arguments to find a Text
     * @example
     * // Get one Text
     * const text = await prisma.text.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TextFindFirstOrThrowArgs>(args?: SelectSubset<T, TextFindFirstOrThrowArgs<ExtArgs>>): Prisma__TextClient<$Result.GetResult<Prisma.$TextPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Texts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Texts
     * const texts = await prisma.text.findMany()
     * 
     * // Get first 10 Texts
     * const texts = await prisma.text.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const textWithIdOnly = await prisma.text.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TextFindManyArgs>(args?: SelectSubset<T, TextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Text.
     * @param {TextCreateArgs} args - Arguments to create a Text.
     * @example
     * // Create one Text
     * const Text = await prisma.text.create({
     *   data: {
     *     // ... data to create a Text
     *   }
     * })
     * 
     */
    create<T extends TextCreateArgs>(args: SelectSubset<T, TextCreateArgs<ExtArgs>>): Prisma__TextClient<$Result.GetResult<Prisma.$TextPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Texts.
     * @param {TextCreateManyArgs} args - Arguments to create many Texts.
     * @example
     * // Create many Texts
     * const text = await prisma.text.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TextCreateManyArgs>(args?: SelectSubset<T, TextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Text.
     * @param {TextDeleteArgs} args - Arguments to delete one Text.
     * @example
     * // Delete one Text
     * const Text = await prisma.text.delete({
     *   where: {
     *     // ... filter to delete one Text
     *   }
     * })
     * 
     */
    delete<T extends TextDeleteArgs>(args: SelectSubset<T, TextDeleteArgs<ExtArgs>>): Prisma__TextClient<$Result.GetResult<Prisma.$TextPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Text.
     * @param {TextUpdateArgs} args - Arguments to update one Text.
     * @example
     * // Update one Text
     * const text = await prisma.text.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TextUpdateArgs>(args: SelectSubset<T, TextUpdateArgs<ExtArgs>>): Prisma__TextClient<$Result.GetResult<Prisma.$TextPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Texts.
     * @param {TextDeleteManyArgs} args - Arguments to filter Texts to delete.
     * @example
     * // Delete a few Texts
     * const { count } = await prisma.text.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TextDeleteManyArgs>(args?: SelectSubset<T, TextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Texts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Texts
     * const text = await prisma.text.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TextUpdateManyArgs>(args: SelectSubset<T, TextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Text.
     * @param {TextUpsertArgs} args - Arguments to update or create a Text.
     * @example
     * // Update or create a Text
     * const text = await prisma.text.upsert({
     *   create: {
     *     // ... data to create a Text
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Text we want to update
     *   }
     * })
     */
    upsert<T extends TextUpsertArgs>(args: SelectSubset<T, TextUpsertArgs<ExtArgs>>): Prisma__TextClient<$Result.GetResult<Prisma.$TextPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Texts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextCountArgs} args - Arguments to filter Texts to count.
     * @example
     * // Count the number of Texts
     * const count = await prisma.text.count({
     *   where: {
     *     // ... the filter for the Texts we want to count
     *   }
     * })
    **/
    count<T extends TextCountArgs>(
      args?: Subset<T, TextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Text.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TextAggregateArgs>(args: Subset<T, TextAggregateArgs>): Prisma.PrismaPromise<GetTextAggregateType<T>>

    /**
     * Group by Text.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TextGroupByArgs['orderBy'] }
        : { orderBy?: TextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Text model
   */
  readonly fields: TextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Text.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Text model
   */ 
  interface TextFieldRefs {
    readonly id: FieldRef<"Text", 'String'>
    readonly area: FieldRef<"Text", 'String'>
    readonly title: FieldRef<"Text", 'String'>
    readonly position: FieldRef<"Text", 'Int'>
    readonly text: FieldRef<"Text", 'String'>
    readonly createdAt: FieldRef<"Text", 'DateTime'>
    readonly updatedAt: FieldRef<"Text", 'DateTime'>
    readonly venueId: FieldRef<"Text", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Text findUnique
   */
  export type TextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
    /**
     * Filter, which Text to fetch.
     */
    where: TextWhereUniqueInput
  }

  /**
   * Text findUniqueOrThrow
   */
  export type TextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
    /**
     * Filter, which Text to fetch.
     */
    where: TextWhereUniqueInput
  }

  /**
   * Text findFirst
   */
  export type TextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
    /**
     * Filter, which Text to fetch.
     */
    where?: TextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Texts to fetch.
     */
    orderBy?: TextOrderByWithRelationInput | TextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Texts.
     */
    cursor?: TextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Texts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Texts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Texts.
     */
    distinct?: TextScalarFieldEnum | TextScalarFieldEnum[]
  }

  /**
   * Text findFirstOrThrow
   */
  export type TextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
    /**
     * Filter, which Text to fetch.
     */
    where?: TextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Texts to fetch.
     */
    orderBy?: TextOrderByWithRelationInput | TextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Texts.
     */
    cursor?: TextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Texts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Texts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Texts.
     */
    distinct?: TextScalarFieldEnum | TextScalarFieldEnum[]
  }

  /**
   * Text findMany
   */
  export type TextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
    /**
     * Filter, which Texts to fetch.
     */
    where?: TextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Texts to fetch.
     */
    orderBy?: TextOrderByWithRelationInput | TextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Texts.
     */
    cursor?: TextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Texts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Texts.
     */
    skip?: number
    distinct?: TextScalarFieldEnum | TextScalarFieldEnum[]
  }

  /**
   * Text create
   */
  export type TextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
    /**
     * The data needed to create a Text.
     */
    data: XOR<TextCreateInput, TextUncheckedCreateInput>
  }

  /**
   * Text createMany
   */
  export type TextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Texts.
     */
    data: TextCreateManyInput | TextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Text update
   */
  export type TextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
    /**
     * The data needed to update a Text.
     */
    data: XOR<TextUpdateInput, TextUncheckedUpdateInput>
    /**
     * Choose, which Text to update.
     */
    where: TextWhereUniqueInput
  }

  /**
   * Text updateMany
   */
  export type TextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Texts.
     */
    data: XOR<TextUpdateManyMutationInput, TextUncheckedUpdateManyInput>
    /**
     * Filter which Texts to update
     */
    where?: TextWhereInput
  }

  /**
   * Text upsert
   */
  export type TextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
    /**
     * The filter to search for the Text to update in case it exists.
     */
    where: TextWhereUniqueInput
    /**
     * In case the Text found by the `where` argument doesn't exist, create a new Text with this data.
     */
    create: XOR<TextCreateInput, TextUncheckedCreateInput>
    /**
     * In case the Text was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TextUpdateInput, TextUncheckedUpdateInput>
  }

  /**
   * Text delete
   */
  export type TextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
    /**
     * Filter which Text to delete.
     */
    where: TextWhereUniqueInput
  }

  /**
   * Text deleteMany
   */
  export type TextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Texts to delete
     */
    where?: TextWhereInput
  }

  /**
   * Text without action
   */
  export type TextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Text
     */
    select?: TextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    question: string | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
    venueId: string | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    question: string | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
    venueId: string | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    question: number
    response: number
    createdAt: number
    updatedAt: number
    venueId: number
    _all: number
  }


  export type QuestionMinAggregateInputType = {
    id?: true
    question?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    venueId?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    question?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    venueId?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    question?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    venueId?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    question: string
    response: string
    createdAt: Date
    updatedAt: Date
    venueId: string
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venueId?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>


  export type QuestionSelectScalar = {
    id?: boolean
    question?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venueId?: boolean
  }

  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      response: string
      createdAt: Date
      updatedAt: Date
      venueId: string
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */ 
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly question: FieldRef<"Question", 'String'>
    readonly response: FieldRef<"Question", 'String'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
    readonly updatedAt: FieldRef<"Question", 'DateTime'>
    readonly venueId: FieldRef<"Question", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractMinAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    organizationId: string | null
  }

  export type ContractMaxAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    organizationId: string | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    name: number
    title: number
    organizationId: number
    _all: number
  }


  export type ContractMinAggregateInputType = {
    id?: true
    name?: true
    title?: true
    organizationId?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    name?: true
    title?: true
    organizationId?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    name?: true
    title?: true
    organizationId?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: string
    name: string
    title: string
    organizationId: string
    _count: ContractCountAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    clauses?: boolean | Contract$clausesArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>


  export type ContractSelectScalar = {
    id?: boolean
    name?: boolean
    title?: boolean
    organizationId?: boolean
  }

  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    clauses?: boolean | Contract$clausesArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      clauses: Prisma.$ClausePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      title: string
      organizationId: string
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    clauses<T extends Contract$clausesArgs<ExtArgs> = {}>(args?: Subset<T, Contract$clausesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */ 
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'String'>
    readonly name: FieldRef<"Contract", 'String'>
    readonly title: FieldRef<"Contract", 'String'>
    readonly organizationId: FieldRef<"Contract", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
  }

  /**
   * Contract.clauses
   */
  export type Contract$clausesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    where?: ClauseWhereInput
    orderBy?: ClauseOrderByWithRelationInput | ClauseOrderByWithRelationInput[]
    cursor?: ClauseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClauseScalarFieldEnum | ClauseScalarFieldEnum[]
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model Clause
   */

  export type AggregateClause = {
    _count: ClauseCountAggregateOutputType | null
    _avg: ClauseAvgAggregateOutputType | null
    _sum: ClauseSumAggregateOutputType | null
    _min: ClauseMinAggregateOutputType | null
    _max: ClauseMaxAggregateOutputType | null
  }

  export type ClauseAvgAggregateOutputType = {
    position: number | null
  }

  export type ClauseSumAggregateOutputType = {
    position: number | null
  }

  export type ClauseMinAggregateOutputType = {
    id: string | null
    text: string | null
    title: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
    contractId: string | null
  }

  export type ClauseMaxAggregateOutputType = {
    id: string | null
    text: string | null
    title: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
    contractId: string | null
  }

  export type ClauseCountAggregateOutputType = {
    id: number
    text: number
    title: number
    position: number
    createdAt: number
    updatedAt: number
    organizationId: number
    contractId: number
    _all: number
  }


  export type ClauseAvgAggregateInputType = {
    position?: true
  }

  export type ClauseSumAggregateInputType = {
    position?: true
  }

  export type ClauseMinAggregateInputType = {
    id?: true
    text?: true
    title?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
    contractId?: true
  }

  export type ClauseMaxAggregateInputType = {
    id?: true
    text?: true
    title?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
    contractId?: true
  }

  export type ClauseCountAggregateInputType = {
    id?: true
    text?: true
    title?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
    contractId?: true
    _all?: true
  }

  export type ClauseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clause to aggregate.
     */
    where?: ClauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clauses to fetch.
     */
    orderBy?: ClauseOrderByWithRelationInput | ClauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clauses
    **/
    _count?: true | ClauseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClauseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClauseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClauseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClauseMaxAggregateInputType
  }

  export type GetClauseAggregateType<T extends ClauseAggregateArgs> = {
        [P in keyof T & keyof AggregateClause]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClause[P]>
      : GetScalarType<T[P], AggregateClause[P]>
  }




  export type ClauseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClauseWhereInput
    orderBy?: ClauseOrderByWithAggregationInput | ClauseOrderByWithAggregationInput[]
    by: ClauseScalarFieldEnum[] | ClauseScalarFieldEnum
    having?: ClauseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClauseCountAggregateInputType | true
    _avg?: ClauseAvgAggregateInputType
    _sum?: ClauseSumAggregateInputType
    _min?: ClauseMinAggregateInputType
    _max?: ClauseMaxAggregateInputType
  }

  export type ClauseGroupByOutputType = {
    id: string
    text: string
    title: string
    position: number | null
    createdAt: Date
    updatedAt: Date
    organizationId: string | null
    contractId: string | null
    _count: ClauseCountAggregateOutputType | null
    _avg: ClauseAvgAggregateOutputType | null
    _sum: ClauseSumAggregateOutputType | null
    _min: ClauseMinAggregateOutputType | null
    _max: ClauseMaxAggregateOutputType | null
  }

  type GetClauseGroupByPayload<T extends ClauseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClauseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClauseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClauseGroupByOutputType[P]>
            : GetScalarType<T[P], ClauseGroupByOutputType[P]>
        }
      >
    >


  export type ClauseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    title?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    contractId?: boolean
    organization?: boolean | Clause$organizationArgs<ExtArgs>
    Contract?: boolean | Clause$ContractArgs<ExtArgs>
  }, ExtArgs["result"]["clause"]>


  export type ClauseSelectScalar = {
    id?: boolean
    text?: boolean
    title?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    contractId?: boolean
  }

  export type ClauseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Clause$organizationArgs<ExtArgs>
    Contract?: boolean | Clause$ContractArgs<ExtArgs>
  }

  export type $ClausePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clause"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      Contract: Prisma.$ContractPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      title: string
      position: number | null
      createdAt: Date
      updatedAt: Date
      organizationId: string | null
      contractId: string | null
    }, ExtArgs["result"]["clause"]>
    composites: {}
  }

  type ClauseGetPayload<S extends boolean | null | undefined | ClauseDefaultArgs> = $Result.GetResult<Prisma.$ClausePayload, S>

  type ClauseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClauseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClauseCountAggregateInputType | true
    }

  export interface ClauseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clause'], meta: { name: 'Clause' } }
    /**
     * Find zero or one Clause that matches the filter.
     * @param {ClauseFindUniqueArgs} args - Arguments to find a Clause
     * @example
     * // Get one Clause
     * const clause = await prisma.clause.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClauseFindUniqueArgs>(args: SelectSubset<T, ClauseFindUniqueArgs<ExtArgs>>): Prisma__ClauseClient<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clause that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClauseFindUniqueOrThrowArgs} args - Arguments to find a Clause
     * @example
     * // Get one Clause
     * const clause = await prisma.clause.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClauseFindUniqueOrThrowArgs>(args: SelectSubset<T, ClauseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClauseClient<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clause that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauseFindFirstArgs} args - Arguments to find a Clause
     * @example
     * // Get one Clause
     * const clause = await prisma.clause.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClauseFindFirstArgs>(args?: SelectSubset<T, ClauseFindFirstArgs<ExtArgs>>): Prisma__ClauseClient<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clause that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauseFindFirstOrThrowArgs} args - Arguments to find a Clause
     * @example
     * // Get one Clause
     * const clause = await prisma.clause.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClauseFindFirstOrThrowArgs>(args?: SelectSubset<T, ClauseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClauseClient<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clauses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clauses
     * const clauses = await prisma.clause.findMany()
     * 
     * // Get first 10 Clauses
     * const clauses = await prisma.clause.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clauseWithIdOnly = await prisma.clause.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClauseFindManyArgs>(args?: SelectSubset<T, ClauseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clause.
     * @param {ClauseCreateArgs} args - Arguments to create a Clause.
     * @example
     * // Create one Clause
     * const Clause = await prisma.clause.create({
     *   data: {
     *     // ... data to create a Clause
     *   }
     * })
     * 
     */
    create<T extends ClauseCreateArgs>(args: SelectSubset<T, ClauseCreateArgs<ExtArgs>>): Prisma__ClauseClient<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clauses.
     * @param {ClauseCreateManyArgs} args - Arguments to create many Clauses.
     * @example
     * // Create many Clauses
     * const clause = await prisma.clause.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClauseCreateManyArgs>(args?: SelectSubset<T, ClauseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clause.
     * @param {ClauseDeleteArgs} args - Arguments to delete one Clause.
     * @example
     * // Delete one Clause
     * const Clause = await prisma.clause.delete({
     *   where: {
     *     // ... filter to delete one Clause
     *   }
     * })
     * 
     */
    delete<T extends ClauseDeleteArgs>(args: SelectSubset<T, ClauseDeleteArgs<ExtArgs>>): Prisma__ClauseClient<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clause.
     * @param {ClauseUpdateArgs} args - Arguments to update one Clause.
     * @example
     * // Update one Clause
     * const clause = await prisma.clause.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClauseUpdateArgs>(args: SelectSubset<T, ClauseUpdateArgs<ExtArgs>>): Prisma__ClauseClient<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clauses.
     * @param {ClauseDeleteManyArgs} args - Arguments to filter Clauses to delete.
     * @example
     * // Delete a few Clauses
     * const { count } = await prisma.clause.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClauseDeleteManyArgs>(args?: SelectSubset<T, ClauseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clauses
     * const clause = await prisma.clause.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClauseUpdateManyArgs>(args: SelectSubset<T, ClauseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clause.
     * @param {ClauseUpsertArgs} args - Arguments to update or create a Clause.
     * @example
     * // Update or create a Clause
     * const clause = await prisma.clause.upsert({
     *   create: {
     *     // ... data to create a Clause
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clause we want to update
     *   }
     * })
     */
    upsert<T extends ClauseUpsertArgs>(args: SelectSubset<T, ClauseUpsertArgs<ExtArgs>>): Prisma__ClauseClient<$Result.GetResult<Prisma.$ClausePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauseCountArgs} args - Arguments to filter Clauses to count.
     * @example
     * // Count the number of Clauses
     * const count = await prisma.clause.count({
     *   where: {
     *     // ... the filter for the Clauses we want to count
     *   }
     * })
    **/
    count<T extends ClauseCountArgs>(
      args?: Subset<T, ClauseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClauseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clause.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClauseAggregateArgs>(args: Subset<T, ClauseAggregateArgs>): Prisma.PrismaPromise<GetClauseAggregateType<T>>

    /**
     * Group by Clause.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClauseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClauseGroupByArgs['orderBy'] }
        : { orderBy?: ClauseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClauseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClauseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clause model
   */
  readonly fields: ClauseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clause.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClauseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends Clause$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Clause$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Contract<T extends Clause$ContractArgs<ExtArgs> = {}>(args?: Subset<T, Clause$ContractArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clause model
   */ 
  interface ClauseFieldRefs {
    readonly id: FieldRef<"Clause", 'String'>
    readonly text: FieldRef<"Clause", 'String'>
    readonly title: FieldRef<"Clause", 'String'>
    readonly position: FieldRef<"Clause", 'Int'>
    readonly createdAt: FieldRef<"Clause", 'DateTime'>
    readonly updatedAt: FieldRef<"Clause", 'DateTime'>
    readonly organizationId: FieldRef<"Clause", 'String'>
    readonly contractId: FieldRef<"Clause", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Clause findUnique
   */
  export type ClauseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    /**
     * Filter, which Clause to fetch.
     */
    where: ClauseWhereUniqueInput
  }

  /**
   * Clause findUniqueOrThrow
   */
  export type ClauseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    /**
     * Filter, which Clause to fetch.
     */
    where: ClauseWhereUniqueInput
  }

  /**
   * Clause findFirst
   */
  export type ClauseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    /**
     * Filter, which Clause to fetch.
     */
    where?: ClauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clauses to fetch.
     */
    orderBy?: ClauseOrderByWithRelationInput | ClauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clauses.
     */
    cursor?: ClauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clauses.
     */
    distinct?: ClauseScalarFieldEnum | ClauseScalarFieldEnum[]
  }

  /**
   * Clause findFirstOrThrow
   */
  export type ClauseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    /**
     * Filter, which Clause to fetch.
     */
    where?: ClauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clauses to fetch.
     */
    orderBy?: ClauseOrderByWithRelationInput | ClauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clauses.
     */
    cursor?: ClauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clauses.
     */
    distinct?: ClauseScalarFieldEnum | ClauseScalarFieldEnum[]
  }

  /**
   * Clause findMany
   */
  export type ClauseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    /**
     * Filter, which Clauses to fetch.
     */
    where?: ClauseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clauses to fetch.
     */
    orderBy?: ClauseOrderByWithRelationInput | ClauseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clauses.
     */
    cursor?: ClauseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clauses.
     */
    skip?: number
    distinct?: ClauseScalarFieldEnum | ClauseScalarFieldEnum[]
  }

  /**
   * Clause create
   */
  export type ClauseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    /**
     * The data needed to create a Clause.
     */
    data: XOR<ClauseCreateInput, ClauseUncheckedCreateInput>
  }

  /**
   * Clause createMany
   */
  export type ClauseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clauses.
     */
    data: ClauseCreateManyInput | ClauseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clause update
   */
  export type ClauseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    /**
     * The data needed to update a Clause.
     */
    data: XOR<ClauseUpdateInput, ClauseUncheckedUpdateInput>
    /**
     * Choose, which Clause to update.
     */
    where: ClauseWhereUniqueInput
  }

  /**
   * Clause updateMany
   */
  export type ClauseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clauses.
     */
    data: XOR<ClauseUpdateManyMutationInput, ClauseUncheckedUpdateManyInput>
    /**
     * Filter which Clauses to update
     */
    where?: ClauseWhereInput
  }

  /**
   * Clause upsert
   */
  export type ClauseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    /**
     * The filter to search for the Clause to update in case it exists.
     */
    where: ClauseWhereUniqueInput
    /**
     * In case the Clause found by the `where` argument doesn't exist, create a new Clause with this data.
     */
    create: XOR<ClauseCreateInput, ClauseUncheckedCreateInput>
    /**
     * In case the Clause was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClauseUpdateInput, ClauseUncheckedUpdateInput>
  }

  /**
   * Clause delete
   */
  export type ClauseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
    /**
     * Filter which Clause to delete.
     */
    where: ClauseWhereUniqueInput
  }

  /**
   * Clause deleteMany
   */
  export type ClauseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clauses to delete
     */
    where?: ClauseWhereInput
  }

  /**
   * Clause.organization
   */
  export type Clause$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Clause.Contract
   */
  export type Clause$ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
  }

  /**
   * Clause without action
   */
  export type ClauseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clause
     */
    select?: ClauseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClauseInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    workerNumber: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    workerNumber: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    name: string | null
    workerNumber: number | null
    description: string | null
    startHour: Date | null
    endHour: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    proposalId: string | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    workerNumber: number | null
    description: string | null
    startHour: Date | null
    endHour: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    proposalId: string | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    name: number
    workerNumber: number
    description: number
    startHour: number
    endHour: number
    createdAt: number
    updatedAt: number
    proposalId: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    workerNumber?: true
  }

  export type ScheduleSumAggregateInputType = {
    workerNumber?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    name?: true
    workerNumber?: true
    description?: true
    startHour?: true
    endHour?: true
    createdAt?: true
    updatedAt?: true
    proposalId?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    name?: true
    workerNumber?: true
    description?: true
    startHour?: true
    endHour?: true
    createdAt?: true
    updatedAt?: true
    proposalId?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    name?: true
    workerNumber?: true
    description?: true
    startHour?: true
    endHour?: true
    createdAt?: true
    updatedAt?: true
    proposalId?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    name: string
    workerNumber: number
    description: string | null
    startHour: Date
    endHour: Date
    createdAt: Date
    updatedAt: Date
    proposalId: string
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    workerNumber?: boolean
    description?: boolean
    startHour?: boolean
    endHour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proposalId?: boolean
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>


  export type ScheduleSelectScalar = {
    id?: boolean
    name?: boolean
    workerNumber?: boolean
    description?: boolean
    startHour?: boolean
    endHour?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proposalId?: boolean
  }

  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      proposal: Prisma.$ProposalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      workerNumber: number
      description: string | null
      startHour: Date
      endHour: Date
      createdAt: Date
      updatedAt: Date
      proposalId: string
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposal<T extends ProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProposalDefaultArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */ 
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly name: FieldRef<"Schedule", 'String'>
    readonly workerNumber: FieldRef<"Schedule", 'Int'>
    readonly description: FieldRef<"Schedule", 'String'>
    readonly startHour: FieldRef<"Schedule", 'DateTime'>
    readonly endHour: FieldRef<"Schedule", 'DateTime'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
    readonly proposalId: FieldRef<"Schedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    expireIn: 'expireIn',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshTokenId: 'refreshTokenId',
    ipAddress: 'ipAddress',
    isValid: 'isValid',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    avatarUrl: 'avatarUrl'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const UserOrganizationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    organizationId: 'organizationId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type UserOrganizationScalarFieldEnum = (typeof UserOrganizationScalarFieldEnum)[keyof typeof UserOrganizationScalarFieldEnum]


  export const ProposalScalarFieldEnum: {
    id: 'id',
    completeName: 'completeName',
    cpf: 'cpf',
    rg: 'rg',
    street: 'street',
    streetNumber: 'streetNumber',
    neighborhood: 'neighborhood',
    cep: 'cep',
    city: 'city',
    state: 'state',
    type: 'type',
    trafficSource: 'trafficSource',
    guestNumber: 'guestNumber',
    knowsVenue: 'knowsVenue',
    startDate: 'startDate',
    endDate: 'endDate',
    name: 'name',
    email: 'email',
    whatsapp: 'whatsapp',
    description: 'description',
    basePrice: 'basePrice',
    extraHoursQty: 'extraHoursQty',
    extraHourPrice: 'extraHourPrice',
    totalAmount: 'totalAmount',
    termsAccepted: 'termsAccepted',
    approved: 'approved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    contact: 'contact',
    paid: 'paid',
    amountPaid: 'amountPaid',
    venueId: 'venueId'
  };

  export type ProposalScalarFieldEnum = (typeof ProposalScalarFieldEnum)[keyof typeof ProposalScalarFieldEnum]


  export const HistoryScalarFieldEnum: {
    id: 'id',
    action: 'action',
    username: 'username',
    userId: 'userId',
    proposalId: 'proposalId',
    createdAt: 'createdAt'
  };

  export type HistoryScalarFieldEnum = (typeof HistoryScalarFieldEnum)[keyof typeof HistoryScalarFieldEnum]


  export const PersonScalarFieldEnum: {
    id: 'id',
    attendance: 'attendance',
    type: 'type',
    name: 'name',
    email: 'email',
    rg: 'rg',
    proposalId: 'proposalId'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const ProposalServiceScalarFieldEnum: {
    id: 'id',
    proposalId: 'proposalId',
    serviceId: 'serviceId',
    joinedAt: 'joinedAt'
  };

  export type ProposalServiceScalarFieldEnum = (typeof ProposalServiceScalarFieldEnum)[keyof typeof ProposalServiceScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    venueId: 'venueId'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    proposalId: 'proposalId',
    venueId: 'venueId',
    amount: 'amount',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    imageUrl: 'imageUrl'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ProposalCostScalarFieldEnum: {
    id: 'id',
    name: 'name',
    teste: 'teste',
    amount: 'amount',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ProposalCostScalarFieldEnum = (typeof ProposalCostScalarFieldEnum)[keyof typeof ProposalCostScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    amount: 'amount',
    paymentDate: 'paymentDate',
    type: 'type',
    category: 'category',
    recurring: 'recurring',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    venueId: 'venueId'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    venueId: 'venueId',
    proposalId: 'proposalId',
    dateEventId: 'dateEventId',
    content: 'content',
    type: 'type',
    createdAt: 'createdAt',
    isRead: 'isRead'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DateEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    proposalId: 'proposalId',
    venueId: 'venueId',
    type: 'type'
  };

  export type DateEventScalarFieldEnum = (typeof DateEventScalarFieldEnum)[keyof typeof DateEventScalarFieldEnum]


  export const VenueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    street: 'street',
    streetNumber: 'streetNumber',
    complement: 'complement',
    neighborhood: 'neighborhood',
    city: 'city',
    state: 'state',
    checkIn: 'checkIn',
    checkOut: 'checkOut',
    cep: 'cep',
    hasOvernightStay: 'hasOvernightStay',
    createdAt: 'createdAt',
    organizationId: 'organizationId',
    pricingModel: 'pricingModel',
    pricePerPerson: 'pricePerPerson',
    pricePerDay: 'pricePerDay',
    maxGuest: 'maxGuest'
  };

  export type VenueScalarFieldEnum = (typeof VenueScalarFieldEnum)[keyof typeof VenueScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    whatsapp: 'whatsapp',
    venueId: 'venueId'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const OwnerVenueScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    venueId: 'venueId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type OwnerVenueScalarFieldEnum = (typeof OwnerVenueScalarFieldEnum)[keyof typeof OwnerVenueScalarFieldEnum]


  export const OwnerScalarFieldEnum: {
    id: 'id',
    completeName: 'completeName',
    rg: 'rg',
    cpf: 'cpf',
    pix: 'pix',
    street: 'street',
    streetNumber: 'streetNumber',
    complement: 'complement',
    neighborhood: 'neighborhood',
    city: 'city',
    state: 'state',
    bankName: 'bankName',
    bankAgency: 'bankAgency',
    cep: 'cep',
    createdAt: 'createdAt',
    bankAccountNumber: 'bankAccountNumber',
    organizationId: 'organizationId'
  };

  export type OwnerScalarFieldEnum = (typeof OwnerScalarFieldEnum)[keyof typeof OwnerScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    description: 'description',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    responsiveMode: 'responsiveMode',
    tag: 'tag',
    venueId: 'venueId'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const TextScalarFieldEnum: {
    id: 'id',
    area: 'area',
    title: 'title',
    position: 'position',
    text: 'text',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    venueId: 'venueId'
  };

  export type TextScalarFieldEnum = (typeof TextScalarFieldEnum)[keyof typeof TextScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    question: 'question',
    response: 'response',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    venueId: 'venueId'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    name: 'name',
    title: 'title',
    organizationId: 'organizationId'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const ClauseScalarFieldEnum: {
    id: 'id',
    text: 'text',
    title: 'title',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    organizationId: 'organizationId',
    contractId: 'contractId'
  };

  export type ClauseScalarFieldEnum = (typeof ClauseScalarFieldEnum)[keyof typeof ClauseScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    workerNumber: 'workerNumber',
    description: 'description',
    startHour: 'startHour',
    endHour: 'endHour',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    proposalId: 'proposalId'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'ProposalType'
   */
  export type EnumProposalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalType'>
    


  /**
   * Reference to a field of type 'TrafficSource'
   */
  export type EnumTrafficSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrafficSource'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'PersonType'
   */
  export type EnumPersonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonType'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'ProposalName'
   */
  export type EnumProposalNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalName'>
    


  /**
   * Reference to a field of type 'ExpenseType'
   */
  export type EnumExpenseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseType'>
    


  /**
   * Reference to a field of type 'ExpenseCategory'
   */
  export type EnumExpenseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseCategory'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'DateEventType'
   */
  export type EnumDateEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateEventType'>
    


  /**
   * Reference to a field of type 'PricingModel'
   */
  export type EnumPricingModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingModel'>
    
  /**
   * Deep Input Types
   */


  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    expireIn?: IntFilter<"RefreshToken"> | number
    userId?: StringFilter<"RefreshToken"> | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    session?: SessionListRelationFilter
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    expireIn?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    session?: SessionOrderByRelationAggregateInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    expireIn?: IntFilter<"RefreshToken"> | number
    userId?: StringFilter<"RefreshToken"> | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    session?: SessionListRelationFilter
  }, "id">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    expireIn?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    expireIn?: IntWithAggregatesFilter<"RefreshToken"> | number
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshTokenId?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    isValid?: BoolFilter<"Session"> | boolean
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    refreshToken?: XOR<RefreshTokenNullableRelationFilter, RefreshTokenWhereInput> | null
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
    refreshToken?: RefreshTokenOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    refreshTokenId?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    isValid?: BoolFilter<"Session"> | boolean
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    refreshToken?: XOR<RefreshTokenNullableRelationFilter, RefreshTokenWhereInput> | null
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    refreshTokenId?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    isValid?: BoolWithAggregatesFilter<"Session"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    session?: SessionListRelationFilter
    histories?: HistoryListRelationFilter
    refreshToken?: RefreshTokenListRelationFilter
    userOrganizations?: UserOrganizationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    session?: SessionOrderByRelationAggregateInput
    histories?: HistoryOrderByRelationAggregateInput
    refreshToken?: RefreshTokenOrderByRelationAggregateInput
    userOrganizations?: UserOrganizationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    session?: SessionListRelationFilter
    histories?: HistoryListRelationFilter
    refreshToken?: RefreshTokenListRelationFilter
    userOrganizations?: UserOrganizationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    venues?: VenueListRelationFilter
    owners?: OwnerListRelationFilter
    userOrganizations?: UserOrganizationListRelationFilter
    Clause?: ClauseListRelationFilter
    Contract?: ContractListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    venues?: VenueOrderByRelationAggregateInput
    owners?: OwnerOrderByRelationAggregateInput
    userOrganizations?: UserOrganizationOrderByRelationAggregateInput
    Clause?: ClauseOrderByRelationAggregateInput
    Contract?: ContractOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    venues?: VenueListRelationFilter
    owners?: OwnerListRelationFilter
    userOrganizations?: UserOrganizationListRelationFilter
    Clause?: ClauseListRelationFilter
    Contract?: ContractListRelationFilter
  }, "id" | "name">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type UserOrganizationWhereInput = {
    AND?: UserOrganizationWhereInput | UserOrganizationWhereInput[]
    OR?: UserOrganizationWhereInput[]
    NOT?: UserOrganizationWhereInput | UserOrganizationWhereInput[]
    id?: StringFilter<"UserOrganization"> | string
    userId?: StringFilter<"UserOrganization"> | string
    organizationId?: StringFilter<"UserOrganization"> | string
    role?: EnumRoleFilter<"UserOrganization"> | $Enums.Role
    joinedAt?: DateTimeFilter<"UserOrganization"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type UserOrganizationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type UserOrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_organizationId?: UserOrganizationUserIdOrganizationIdCompoundUniqueInput
    AND?: UserOrganizationWhereInput | UserOrganizationWhereInput[]
    OR?: UserOrganizationWhereInput[]
    NOT?: UserOrganizationWhereInput | UserOrganizationWhereInput[]
    userId?: StringFilter<"UserOrganization"> | string
    organizationId?: StringFilter<"UserOrganization"> | string
    role?: EnumRoleFilter<"UserOrganization"> | $Enums.Role
    joinedAt?: DateTimeFilter<"UserOrganization"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id" | "userId_organizationId">

  export type UserOrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: UserOrganizationCountOrderByAggregateInput
    _max?: UserOrganizationMaxOrderByAggregateInput
    _min?: UserOrganizationMinOrderByAggregateInput
  }

  export type UserOrganizationScalarWhereWithAggregatesInput = {
    AND?: UserOrganizationScalarWhereWithAggregatesInput | UserOrganizationScalarWhereWithAggregatesInput[]
    OR?: UserOrganizationScalarWhereWithAggregatesInput[]
    NOT?: UserOrganizationScalarWhereWithAggregatesInput | UserOrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserOrganization"> | string
    userId?: StringWithAggregatesFilter<"UserOrganization"> | string
    organizationId?: StringWithAggregatesFilter<"UserOrganization"> | string
    role?: EnumRoleWithAggregatesFilter<"UserOrganization"> | $Enums.Role
    joinedAt?: DateTimeWithAggregatesFilter<"UserOrganization"> | Date | string
  }

  export type ProposalWhereInput = {
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    id?: StringFilter<"Proposal"> | string
    completeName?: StringNullableFilter<"Proposal"> | string | null
    cpf?: StringNullableFilter<"Proposal"> | string | null
    rg?: StringNullableFilter<"Proposal"> | string | null
    street?: StringNullableFilter<"Proposal"> | string | null
    streetNumber?: StringNullableFilter<"Proposal"> | string | null
    neighborhood?: StringNullableFilter<"Proposal"> | string | null
    cep?: StringNullableFilter<"Proposal"> | string | null
    city?: StringNullableFilter<"Proposal"> | string | null
    state?: StringNullableFilter<"Proposal"> | string | null
    type?: EnumProposalTypeFilter<"Proposal"> | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFilter<"Proposal"> | $Enums.TrafficSource
    guestNumber?: IntFilter<"Proposal"> | number
    knowsVenue?: BoolFilter<"Proposal"> | boolean
    startDate?: DateTimeFilter<"Proposal"> | Date | string
    endDate?: DateTimeFilter<"Proposal"> | Date | string
    name?: StringFilter<"Proposal"> | string
    email?: StringFilter<"Proposal"> | string
    whatsapp?: StringFilter<"Proposal"> | string
    description?: StringFilter<"Proposal"> | string
    basePrice?: FloatFilter<"Proposal"> | number
    extraHoursQty?: IntFilter<"Proposal"> | number
    extraHourPrice?: FloatFilter<"Proposal"> | number
    totalAmount?: FloatFilter<"Proposal"> | number
    termsAccepted?: BoolFilter<"Proposal"> | boolean
    approved?: BoolFilter<"Proposal"> | boolean
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    contact?: BoolNullableFilter<"Proposal"> | boolean | null
    paid?: BoolNullableFilter<"Proposal"> | boolean | null
    amountPaid?: FloatNullableFilter<"Proposal"> | number | null
    venueId?: StringFilter<"Proposal"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
    personList?: PersonListRelationFilter
    histories?: HistoryListRelationFilter
    payments?: PaymentListRelationFilter
    dateEvents?: DateEventListRelationFilter
    proposalCosts?: ProposalCostListRelationFilter
    proposalServices?: ProposalServiceListRelationFilter
    noificationList?: NotificationListRelationFilter
    scheduleList?: ScheduleListRelationFilter
  }

  export type ProposalOrderByWithRelationInput = {
    id?: SortOrder
    completeName?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    rg?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    streetNumber?: SortOrderInput | SortOrder
    neighborhood?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    type?: SortOrder
    trafficSource?: SortOrder
    guestNumber?: SortOrder
    knowsVenue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    name?: SortOrder
    email?: SortOrder
    whatsapp?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    extraHoursQty?: SortOrder
    extraHourPrice?: SortOrder
    totalAmount?: SortOrder
    termsAccepted?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: SortOrderInput | SortOrder
    paid?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    venueId?: SortOrder
    venue?: VenueOrderByWithRelationInput
    personList?: PersonOrderByRelationAggregateInput
    histories?: HistoryOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    dateEvents?: DateEventOrderByRelationAggregateInput
    proposalCosts?: ProposalCostOrderByRelationAggregateInput
    proposalServices?: ProposalServiceOrderByRelationAggregateInput
    noificationList?: NotificationOrderByRelationAggregateInput
    scheduleList?: ScheduleOrderByRelationAggregateInput
  }

  export type ProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    completeName?: StringNullableFilter<"Proposal"> | string | null
    cpf?: StringNullableFilter<"Proposal"> | string | null
    rg?: StringNullableFilter<"Proposal"> | string | null
    street?: StringNullableFilter<"Proposal"> | string | null
    streetNumber?: StringNullableFilter<"Proposal"> | string | null
    neighborhood?: StringNullableFilter<"Proposal"> | string | null
    cep?: StringNullableFilter<"Proposal"> | string | null
    city?: StringNullableFilter<"Proposal"> | string | null
    state?: StringNullableFilter<"Proposal"> | string | null
    type?: EnumProposalTypeFilter<"Proposal"> | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFilter<"Proposal"> | $Enums.TrafficSource
    guestNumber?: IntFilter<"Proposal"> | number
    knowsVenue?: BoolFilter<"Proposal"> | boolean
    startDate?: DateTimeFilter<"Proposal"> | Date | string
    endDate?: DateTimeFilter<"Proposal"> | Date | string
    name?: StringFilter<"Proposal"> | string
    email?: StringFilter<"Proposal"> | string
    whatsapp?: StringFilter<"Proposal"> | string
    description?: StringFilter<"Proposal"> | string
    basePrice?: FloatFilter<"Proposal"> | number
    extraHoursQty?: IntFilter<"Proposal"> | number
    extraHourPrice?: FloatFilter<"Proposal"> | number
    totalAmount?: FloatFilter<"Proposal"> | number
    termsAccepted?: BoolFilter<"Proposal"> | boolean
    approved?: BoolFilter<"Proposal"> | boolean
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    contact?: BoolNullableFilter<"Proposal"> | boolean | null
    paid?: BoolNullableFilter<"Proposal"> | boolean | null
    amountPaid?: FloatNullableFilter<"Proposal"> | number | null
    venueId?: StringFilter<"Proposal"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
    personList?: PersonListRelationFilter
    histories?: HistoryListRelationFilter
    payments?: PaymentListRelationFilter
    dateEvents?: DateEventListRelationFilter
    proposalCosts?: ProposalCostListRelationFilter
    proposalServices?: ProposalServiceListRelationFilter
    noificationList?: NotificationListRelationFilter
    scheduleList?: ScheduleListRelationFilter
  }, "id">

  export type ProposalOrderByWithAggregationInput = {
    id?: SortOrder
    completeName?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    rg?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    streetNumber?: SortOrderInput | SortOrder
    neighborhood?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    type?: SortOrder
    trafficSource?: SortOrder
    guestNumber?: SortOrder
    knowsVenue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    name?: SortOrder
    email?: SortOrder
    whatsapp?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    extraHoursQty?: SortOrder
    extraHourPrice?: SortOrder
    totalAmount?: SortOrder
    termsAccepted?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: SortOrderInput | SortOrder
    paid?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    venueId?: SortOrder
    _count?: ProposalCountOrderByAggregateInput
    _avg?: ProposalAvgOrderByAggregateInput
    _max?: ProposalMaxOrderByAggregateInput
    _min?: ProposalMinOrderByAggregateInput
    _sum?: ProposalSumOrderByAggregateInput
  }

  export type ProposalScalarWhereWithAggregatesInput = {
    AND?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    OR?: ProposalScalarWhereWithAggregatesInput[]
    NOT?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proposal"> | string
    completeName?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    cpf?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    rg?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    street?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    streetNumber?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    neighborhood?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    cep?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    city?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    state?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    type?: EnumProposalTypeWithAggregatesFilter<"Proposal"> | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceWithAggregatesFilter<"Proposal"> | $Enums.TrafficSource
    guestNumber?: IntWithAggregatesFilter<"Proposal"> | number
    knowsVenue?: BoolWithAggregatesFilter<"Proposal"> | boolean
    startDate?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
    name?: StringWithAggregatesFilter<"Proposal"> | string
    email?: StringWithAggregatesFilter<"Proposal"> | string
    whatsapp?: StringWithAggregatesFilter<"Proposal"> | string
    description?: StringWithAggregatesFilter<"Proposal"> | string
    basePrice?: FloatWithAggregatesFilter<"Proposal"> | number
    extraHoursQty?: IntWithAggregatesFilter<"Proposal"> | number
    extraHourPrice?: FloatWithAggregatesFilter<"Proposal"> | number
    totalAmount?: FloatWithAggregatesFilter<"Proposal"> | number
    termsAccepted?: BoolWithAggregatesFilter<"Proposal"> | boolean
    approved?: BoolWithAggregatesFilter<"Proposal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
    contact?: BoolNullableWithAggregatesFilter<"Proposal"> | boolean | null
    paid?: BoolNullableWithAggregatesFilter<"Proposal"> | boolean | null
    amountPaid?: FloatNullableWithAggregatesFilter<"Proposal"> | number | null
    venueId?: StringWithAggregatesFilter<"Proposal"> | string
  }

  export type HistoryWhereInput = {
    AND?: HistoryWhereInput | HistoryWhereInput[]
    OR?: HistoryWhereInput[]
    NOT?: HistoryWhereInput | HistoryWhereInput[]
    id?: StringFilter<"History"> | string
    action?: StringFilter<"History"> | string
    username?: StringNullableFilter<"History"> | string | null
    userId?: StringNullableFilter<"History"> | string | null
    proposalId?: StringFilter<"History"> | string
    createdAt?: DateTimeFilter<"History"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
  }

  export type HistoryOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    username?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    proposalId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    proposal?: ProposalOrderByWithRelationInput
  }

  export type HistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HistoryWhereInput | HistoryWhereInput[]
    OR?: HistoryWhereInput[]
    NOT?: HistoryWhereInput | HistoryWhereInput[]
    action?: StringFilter<"History"> | string
    username?: StringNullableFilter<"History"> | string | null
    userId?: StringNullableFilter<"History"> | string | null
    proposalId?: StringFilter<"History"> | string
    createdAt?: DateTimeFilter<"History"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
  }, "id">

  export type HistoryOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    username?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    proposalId?: SortOrder
    createdAt?: SortOrder
    _count?: HistoryCountOrderByAggregateInput
    _max?: HistoryMaxOrderByAggregateInput
    _min?: HistoryMinOrderByAggregateInput
  }

  export type HistoryScalarWhereWithAggregatesInput = {
    AND?: HistoryScalarWhereWithAggregatesInput | HistoryScalarWhereWithAggregatesInput[]
    OR?: HistoryScalarWhereWithAggregatesInput[]
    NOT?: HistoryScalarWhereWithAggregatesInput | HistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"History"> | string
    action?: StringWithAggregatesFilter<"History"> | string
    username?: StringNullableWithAggregatesFilter<"History"> | string | null
    userId?: StringNullableWithAggregatesFilter<"History"> | string | null
    proposalId?: StringWithAggregatesFilter<"History"> | string
    createdAt?: DateTimeWithAggregatesFilter<"History"> | Date | string
  }

  export type PersonWhereInput = {
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    id?: StringFilter<"Person"> | string
    attendance?: BoolFilter<"Person"> | boolean
    type?: EnumPersonTypeFilter<"Person"> | $Enums.PersonType
    name?: StringFilter<"Person"> | string
    email?: StringNullableFilter<"Person"> | string | null
    rg?: StringNullableFilter<"Person"> | string | null
    proposalId?: StringFilter<"Person"> | string
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    attendance?: SortOrder
    type?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    rg?: SortOrderInput | SortOrder
    proposalId?: SortOrder
    proposal?: ProposalOrderByWithRelationInput
  }

  export type PersonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    attendance?: BoolFilter<"Person"> | boolean
    type?: EnumPersonTypeFilter<"Person"> | $Enums.PersonType
    name?: StringFilter<"Person"> | string
    email?: StringNullableFilter<"Person"> | string | null
    rg?: StringNullableFilter<"Person"> | string | null
    proposalId?: StringFilter<"Person"> | string
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
  }, "id">

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    attendance?: SortOrder
    type?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    rg?: SortOrderInput | SortOrder
    proposalId?: SortOrder
    _count?: PersonCountOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    OR?: PersonScalarWhereWithAggregatesInput[]
    NOT?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Person"> | string
    attendance?: BoolWithAggregatesFilter<"Person"> | boolean
    type?: EnumPersonTypeWithAggregatesFilter<"Person"> | $Enums.PersonType
    name?: StringWithAggregatesFilter<"Person"> | string
    email?: StringNullableWithAggregatesFilter<"Person"> | string | null
    rg?: StringNullableWithAggregatesFilter<"Person"> | string | null
    proposalId?: StringWithAggregatesFilter<"Person"> | string
  }

  export type ProposalServiceWhereInput = {
    AND?: ProposalServiceWhereInput | ProposalServiceWhereInput[]
    OR?: ProposalServiceWhereInput[]
    NOT?: ProposalServiceWhereInput | ProposalServiceWhereInput[]
    id?: StringFilter<"ProposalService"> | string
    proposalId?: StringFilter<"ProposalService"> | string
    serviceId?: StringFilter<"ProposalService"> | string
    joinedAt?: DateTimeFilter<"ProposalService"> | Date | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
  }

  export type ProposalServiceOrderByWithRelationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    serviceId?: SortOrder
    joinedAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    proposal?: ProposalOrderByWithRelationInput
  }

  export type ProposalServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalServiceWhereInput | ProposalServiceWhereInput[]
    OR?: ProposalServiceWhereInput[]
    NOT?: ProposalServiceWhereInput | ProposalServiceWhereInput[]
    proposalId?: StringFilter<"ProposalService"> | string
    serviceId?: StringFilter<"ProposalService"> | string
    joinedAt?: DateTimeFilter<"ProposalService"> | Date | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
  }, "id">

  export type ProposalServiceOrderByWithAggregationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    serviceId?: SortOrder
    joinedAt?: SortOrder
    _count?: ProposalServiceCountOrderByAggregateInput
    _max?: ProposalServiceMaxOrderByAggregateInput
    _min?: ProposalServiceMinOrderByAggregateInput
  }

  export type ProposalServiceScalarWhereWithAggregatesInput = {
    AND?: ProposalServiceScalarWhereWithAggregatesInput | ProposalServiceScalarWhereWithAggregatesInput[]
    OR?: ProposalServiceScalarWhereWithAggregatesInput[]
    NOT?: ProposalServiceScalarWhereWithAggregatesInput | ProposalServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProposalService"> | string
    proposalId?: StringWithAggregatesFilter<"ProposalService"> | string
    serviceId?: StringWithAggregatesFilter<"ProposalService"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ProposalService"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    price?: FloatFilter<"Service"> | number
    venueId?: StringFilter<"Service"> | string
    proposalServices?: ProposalServiceListRelationFilter
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    venueId?: SortOrder
    proposalServices?: ProposalServiceOrderByRelationAggregateInput
    venue?: VenueOrderByWithRelationInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_venueId?: ServiceNameVenueIdCompoundUniqueInput
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    price?: FloatFilter<"Service"> | number
    venueId?: StringFilter<"Service"> | string
    proposalServices?: ProposalServiceListRelationFilter
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id" | "name_venueId">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    venueId?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    price?: FloatWithAggregatesFilter<"Service"> | number
    venueId?: StringWithAggregatesFilter<"Service"> | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    proposalId?: StringFilter<"Payment"> | string
    venueId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"Payment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    imageUrl?: StringNullableFilter<"Payment"> | string | null
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    venueId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    proposal?: ProposalOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    proposalId?: StringFilter<"Payment"> | string
    venueId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"Payment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    imageUrl?: StringNullableFilter<"Payment"> | string | null
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    venueId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    proposalId?: StringWithAggregatesFilter<"Payment"> | string
    venueId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    imageUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type ProposalCostWhereInput = {
    AND?: ProposalCostWhereInput | ProposalCostWhereInput[]
    OR?: ProposalCostWhereInput[]
    NOT?: ProposalCostWhereInput | ProposalCostWhereInput[]
    id?: StringFilter<"ProposalCost"> | string
    name?: EnumProposalNameFilter<"ProposalCost"> | $Enums.ProposalName
    teste?: StringFilter<"ProposalCost"> | string
    amount?: FloatFilter<"ProposalCost"> | number
    updatedAt?: DateTimeFilter<"ProposalCost"> | Date | string
    createdAt?: DateTimeFilter<"ProposalCost"> | Date | string
    proposals?: ProposalListRelationFilter
  }

  export type ProposalCostOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    teste?: SortOrder
    amount?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    proposals?: ProposalOrderByRelationAggregateInput
  }

  export type ProposalCostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalCostWhereInput | ProposalCostWhereInput[]
    OR?: ProposalCostWhereInput[]
    NOT?: ProposalCostWhereInput | ProposalCostWhereInput[]
    name?: EnumProposalNameFilter<"ProposalCost"> | $Enums.ProposalName
    teste?: StringFilter<"ProposalCost"> | string
    amount?: FloatFilter<"ProposalCost"> | number
    updatedAt?: DateTimeFilter<"ProposalCost"> | Date | string
    createdAt?: DateTimeFilter<"ProposalCost"> | Date | string
    proposals?: ProposalListRelationFilter
  }, "id">

  export type ProposalCostOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    teste?: SortOrder
    amount?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: ProposalCostCountOrderByAggregateInput
    _avg?: ProposalCostAvgOrderByAggregateInput
    _max?: ProposalCostMaxOrderByAggregateInput
    _min?: ProposalCostMinOrderByAggregateInput
    _sum?: ProposalCostSumOrderByAggregateInput
  }

  export type ProposalCostScalarWhereWithAggregatesInput = {
    AND?: ProposalCostScalarWhereWithAggregatesInput | ProposalCostScalarWhereWithAggregatesInput[]
    OR?: ProposalCostScalarWhereWithAggregatesInput[]
    NOT?: ProposalCostScalarWhereWithAggregatesInput | ProposalCostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProposalCost"> | string
    name?: EnumProposalNameWithAggregatesFilter<"ProposalCost"> | $Enums.ProposalName
    teste?: StringWithAggregatesFilter<"ProposalCost"> | string
    amount?: FloatWithAggregatesFilter<"ProposalCost"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"ProposalCost"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ProposalCost"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    name?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    paymentDate?: DateTimeFilter<"Expense"> | Date | string
    type?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    recurring?: BoolFilter<"Expense"> | boolean
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    venueId?: StringFilter<"Expense"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    type?: SortOrder
    category?: SortOrder
    recurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
    venue?: VenueOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    name?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    paymentDate?: DateTimeFilter<"Expense"> | Date | string
    type?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    recurring?: BoolFilter<"Expense"> | boolean
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    venueId?: StringFilter<"Expense"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    type?: SortOrder
    category?: SortOrder
    recurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    name?: StringWithAggregatesFilter<"Expense"> | string
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amount?: FloatWithAggregatesFilter<"Expense"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    type?: EnumExpenseTypeWithAggregatesFilter<"Expense"> | $Enums.ExpenseType
    category?: EnumExpenseCategoryWithAggregatesFilter<"Expense"> | $Enums.ExpenseCategory
    recurring?: BoolWithAggregatesFilter<"Expense"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    venueId?: StringWithAggregatesFilter<"Expense"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    venueId?: StringFilter<"Notification"> | string
    proposalId?: StringNullableFilter<"Notification"> | string | null
    dateEventId?: StringNullableFilter<"Notification"> | string | null
    content?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isRead?: BoolFilter<"Notification"> | boolean
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
    proposal?: XOR<ProposalNullableRelationFilter, ProposalWhereInput> | null
    dateEvent?: XOR<DateEventNullableRelationFilter, DateEventWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    venueId?: SortOrder
    proposalId?: SortOrderInput | SortOrder
    dateEventId?: SortOrderInput | SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    venue?: VenueOrderByWithRelationInput
    proposal?: ProposalOrderByWithRelationInput
    dateEvent?: DateEventOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    venueId?: StringFilter<"Notification"> | string
    proposalId?: StringNullableFilter<"Notification"> | string | null
    dateEventId?: StringNullableFilter<"Notification"> | string | null
    content?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isRead?: BoolFilter<"Notification"> | boolean
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
    proposal?: XOR<ProposalNullableRelationFilter, ProposalWhereInput> | null
    dateEvent?: XOR<DateEventNullableRelationFilter, DateEventWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    venueId?: SortOrder
    proposalId?: SortOrderInput | SortOrder
    dateEventId?: SortOrderInput | SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    venueId?: StringWithAggregatesFilter<"Notification"> | string
    proposalId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    dateEventId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    content?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
  }

  export type DateEventWhereInput = {
    AND?: DateEventWhereInput | DateEventWhereInput[]
    OR?: DateEventWhereInput[]
    NOT?: DateEventWhereInput | DateEventWhereInput[]
    id?: StringFilter<"DateEvent"> | string
    title?: StringFilter<"DateEvent"> | string
    startDate?: DateTimeFilter<"DateEvent"> | Date | string
    endDate?: DateTimeFilter<"DateEvent"> | Date | string
    createdAt?: DateTimeFilter<"DateEvent"> | Date | string
    updatedAt?: DateTimeFilter<"DateEvent"> | Date | string
    proposalId?: StringNullableFilter<"DateEvent"> | string | null
    venueId?: StringFilter<"DateEvent"> | string
    type?: EnumDateEventTypeFilter<"DateEvent"> | $Enums.DateEventType
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
    proposal?: XOR<ProposalNullableRelationFilter, ProposalWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type DateEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalId?: SortOrderInput | SortOrder
    venueId?: SortOrder
    type?: SortOrder
    venue?: VenueOrderByWithRelationInput
    proposal?: ProposalOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type DateEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DateEventWhereInput | DateEventWhereInput[]
    OR?: DateEventWhereInput[]
    NOT?: DateEventWhereInput | DateEventWhereInput[]
    title?: StringFilter<"DateEvent"> | string
    startDate?: DateTimeFilter<"DateEvent"> | Date | string
    endDate?: DateTimeFilter<"DateEvent"> | Date | string
    createdAt?: DateTimeFilter<"DateEvent"> | Date | string
    updatedAt?: DateTimeFilter<"DateEvent"> | Date | string
    proposalId?: StringNullableFilter<"DateEvent"> | string | null
    venueId?: StringFilter<"DateEvent"> | string
    type?: EnumDateEventTypeFilter<"DateEvent"> | $Enums.DateEventType
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
    proposal?: XOR<ProposalNullableRelationFilter, ProposalWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id">

  export type DateEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalId?: SortOrderInput | SortOrder
    venueId?: SortOrder
    type?: SortOrder
    _count?: DateEventCountOrderByAggregateInput
    _max?: DateEventMaxOrderByAggregateInput
    _min?: DateEventMinOrderByAggregateInput
  }

  export type DateEventScalarWhereWithAggregatesInput = {
    AND?: DateEventScalarWhereWithAggregatesInput | DateEventScalarWhereWithAggregatesInput[]
    OR?: DateEventScalarWhereWithAggregatesInput[]
    NOT?: DateEventScalarWhereWithAggregatesInput | DateEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DateEvent"> | string
    title?: StringWithAggregatesFilter<"DateEvent"> | string
    startDate?: DateTimeWithAggregatesFilter<"DateEvent"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"DateEvent"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"DateEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DateEvent"> | Date | string
    proposalId?: StringNullableWithAggregatesFilter<"DateEvent"> | string | null
    venueId?: StringWithAggregatesFilter<"DateEvent"> | string
    type?: EnumDateEventTypeWithAggregatesFilter<"DateEvent"> | $Enums.DateEventType
  }

  export type VenueWhereInput = {
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    id?: StringFilter<"Venue"> | string
    name?: StringFilter<"Venue"> | string
    street?: StringFilter<"Venue"> | string
    streetNumber?: StringFilter<"Venue"> | string
    complement?: StringNullableFilter<"Venue"> | string | null
    neighborhood?: StringFilter<"Venue"> | string
    city?: StringFilter<"Venue"> | string
    state?: StringFilter<"Venue"> | string
    checkIn?: StringNullableFilter<"Venue"> | string | null
    checkOut?: StringNullableFilter<"Venue"> | string | null
    cep?: StringFilter<"Venue"> | string
    hasOvernightStay?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    organizationId?: StringFilter<"Venue"> | string
    pricingModel?: EnumPricingModelFilter<"Venue"> | $Enums.PricingModel
    pricePerPerson?: FloatNullableFilter<"Venue"> | number | null
    pricePerDay?: FloatNullableFilter<"Venue"> | number | null
    maxGuest?: IntFilter<"Venue"> | number
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    texts?: TextListRelationFilter
    contacts?: ContactListRelationFilter
    images?: ImageListRelationFilter
    expenses?: ExpenseListRelationFilter
    services?: ServiceListRelationFilter
    Payment?: PaymentListRelationFilter
    questions?: QuestionListRelationFilter
    proposals?: ProposalListRelationFilter
    DateEvent?: DateEventListRelationFilter
    ownerVenue?: OwnerVenueListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type VenueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    complement?: SortOrderInput | SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    checkIn?: SortOrderInput | SortOrder
    checkOut?: SortOrderInput | SortOrder
    cep?: SortOrder
    hasOvernightStay?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    pricingModel?: SortOrder
    pricePerPerson?: SortOrderInput | SortOrder
    pricePerDay?: SortOrderInput | SortOrder
    maxGuest?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    texts?: TextOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    images?: ImageOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    Payment?: PaymentOrderByRelationAggregateInput
    questions?: QuestionOrderByRelationAggregateInput
    proposals?: ProposalOrderByRelationAggregateInput
    DateEvent?: DateEventOrderByRelationAggregateInput
    ownerVenue?: OwnerVenueOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type VenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    street?: StringFilter<"Venue"> | string
    streetNumber?: StringFilter<"Venue"> | string
    complement?: StringNullableFilter<"Venue"> | string | null
    neighborhood?: StringFilter<"Venue"> | string
    city?: StringFilter<"Venue"> | string
    state?: StringFilter<"Venue"> | string
    checkIn?: StringNullableFilter<"Venue"> | string | null
    checkOut?: StringNullableFilter<"Venue"> | string | null
    cep?: StringFilter<"Venue"> | string
    hasOvernightStay?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    organizationId?: StringFilter<"Venue"> | string
    pricingModel?: EnumPricingModelFilter<"Venue"> | $Enums.PricingModel
    pricePerPerson?: FloatNullableFilter<"Venue"> | number | null
    pricePerDay?: FloatNullableFilter<"Venue"> | number | null
    maxGuest?: IntFilter<"Venue"> | number
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    texts?: TextListRelationFilter
    contacts?: ContactListRelationFilter
    images?: ImageListRelationFilter
    expenses?: ExpenseListRelationFilter
    services?: ServiceListRelationFilter
    Payment?: PaymentListRelationFilter
    questions?: QuestionListRelationFilter
    proposals?: ProposalListRelationFilter
    DateEvent?: DateEventListRelationFilter
    ownerVenue?: OwnerVenueListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "name">

  export type VenueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    complement?: SortOrderInput | SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    checkIn?: SortOrderInput | SortOrder
    checkOut?: SortOrderInput | SortOrder
    cep?: SortOrder
    hasOvernightStay?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    pricingModel?: SortOrder
    pricePerPerson?: SortOrderInput | SortOrder
    pricePerDay?: SortOrderInput | SortOrder
    maxGuest?: SortOrder
    _count?: VenueCountOrderByAggregateInput
    _avg?: VenueAvgOrderByAggregateInput
    _max?: VenueMaxOrderByAggregateInput
    _min?: VenueMinOrderByAggregateInput
    _sum?: VenueSumOrderByAggregateInput
  }

  export type VenueScalarWhereWithAggregatesInput = {
    AND?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    OR?: VenueScalarWhereWithAggregatesInput[]
    NOT?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Venue"> | string
    name?: StringWithAggregatesFilter<"Venue"> | string
    street?: StringWithAggregatesFilter<"Venue"> | string
    streetNumber?: StringWithAggregatesFilter<"Venue"> | string
    complement?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    neighborhood?: StringWithAggregatesFilter<"Venue"> | string
    city?: StringWithAggregatesFilter<"Venue"> | string
    state?: StringWithAggregatesFilter<"Venue"> | string
    checkIn?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    checkOut?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    cep?: StringWithAggregatesFilter<"Venue"> | string
    hasOvernightStay?: BoolWithAggregatesFilter<"Venue"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
    organizationId?: StringWithAggregatesFilter<"Venue"> | string
    pricingModel?: EnumPricingModelWithAggregatesFilter<"Venue"> | $Enums.PricingModel
    pricePerPerson?: FloatNullableWithAggregatesFilter<"Venue"> | number | null
    pricePerDay?: FloatNullableWithAggregatesFilter<"Venue"> | number | null
    maxGuest?: IntWithAggregatesFilter<"Venue"> | number
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    role?: StringFilter<"Contact"> | string
    whatsapp?: StringFilter<"Contact"> | string
    venueId?: StringFilter<"Contact"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    whatsapp?: SortOrder
    venueId?: SortOrder
    venue?: VenueOrderByWithRelationInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    role?: StringFilter<"Contact"> | string
    whatsapp?: StringFilter<"Contact"> | string
    venueId?: StringFilter<"Contact"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    whatsapp?: SortOrder
    venueId?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    role?: StringWithAggregatesFilter<"Contact"> | string
    whatsapp?: StringWithAggregatesFilter<"Contact"> | string
    venueId?: StringWithAggregatesFilter<"Contact"> | string
  }

  export type OwnerVenueWhereInput = {
    AND?: OwnerVenueWhereInput | OwnerVenueWhereInput[]
    OR?: OwnerVenueWhereInput[]
    NOT?: OwnerVenueWhereInput | OwnerVenueWhereInput[]
    id?: StringFilter<"OwnerVenue"> | string
    ownerId?: StringFilter<"OwnerVenue"> | string
    venueId?: StringFilter<"OwnerVenue"> | string
    role?: EnumRoleFilter<"OwnerVenue"> | $Enums.Role
    joinedAt?: DateTimeFilter<"OwnerVenue"> | Date | string
    owner?: XOR<OwnerRelationFilter, OwnerWhereInput>
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type OwnerVenueOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    venueId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    owner?: OwnerOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
  }

  export type OwnerVenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ownerId_venueId?: OwnerVenueOwnerIdVenueIdCompoundUniqueInput
    AND?: OwnerVenueWhereInput | OwnerVenueWhereInput[]
    OR?: OwnerVenueWhereInput[]
    NOT?: OwnerVenueWhereInput | OwnerVenueWhereInput[]
    ownerId?: StringFilter<"OwnerVenue"> | string
    venueId?: StringFilter<"OwnerVenue"> | string
    role?: EnumRoleFilter<"OwnerVenue"> | $Enums.Role
    joinedAt?: DateTimeFilter<"OwnerVenue"> | Date | string
    owner?: XOR<OwnerRelationFilter, OwnerWhereInput>
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id" | "ownerId_venueId">

  export type OwnerVenueOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    venueId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: OwnerVenueCountOrderByAggregateInput
    _max?: OwnerVenueMaxOrderByAggregateInput
    _min?: OwnerVenueMinOrderByAggregateInput
  }

  export type OwnerVenueScalarWhereWithAggregatesInput = {
    AND?: OwnerVenueScalarWhereWithAggregatesInput | OwnerVenueScalarWhereWithAggregatesInput[]
    OR?: OwnerVenueScalarWhereWithAggregatesInput[]
    NOT?: OwnerVenueScalarWhereWithAggregatesInput | OwnerVenueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OwnerVenue"> | string
    ownerId?: StringWithAggregatesFilter<"OwnerVenue"> | string
    venueId?: StringWithAggregatesFilter<"OwnerVenue"> | string
    role?: EnumRoleWithAggregatesFilter<"OwnerVenue"> | $Enums.Role
    joinedAt?: DateTimeWithAggregatesFilter<"OwnerVenue"> | Date | string
  }

  export type OwnerWhereInput = {
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    id?: StringFilter<"Owner"> | string
    completeName?: StringFilter<"Owner"> | string
    rg?: StringNullableFilter<"Owner"> | string | null
    cpf?: StringFilter<"Owner"> | string
    pix?: StringFilter<"Owner"> | string
    street?: StringFilter<"Owner"> | string
    streetNumber?: StringFilter<"Owner"> | string
    complement?: StringNullableFilter<"Owner"> | string | null
    neighborhood?: StringFilter<"Owner"> | string
    city?: StringFilter<"Owner"> | string
    state?: StringFilter<"Owner"> | string
    bankName?: StringFilter<"Owner"> | string
    bankAgency?: StringFilter<"Owner"> | string
    cep?: StringFilter<"Owner"> | string
    createdAt?: DateTimeFilter<"Owner"> | Date | string
    bankAccountNumber?: StringFilter<"Owner"> | string
    organizationId?: StringFilter<"Owner"> | string
    ownerVenue?: OwnerVenueListRelationFilter
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type OwnerOrderByWithRelationInput = {
    id?: SortOrder
    completeName?: SortOrder
    rg?: SortOrderInput | SortOrder
    cpf?: SortOrder
    pix?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    complement?: SortOrderInput | SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    bankName?: SortOrder
    bankAgency?: SortOrder
    cep?: SortOrder
    createdAt?: SortOrder
    bankAccountNumber?: SortOrder
    organizationId?: SortOrder
    ownerVenue?: OwnerVenueOrderByRelationAggregateInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type OwnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    completeName?: StringFilter<"Owner"> | string
    rg?: StringNullableFilter<"Owner"> | string | null
    cpf?: StringFilter<"Owner"> | string
    pix?: StringFilter<"Owner"> | string
    street?: StringFilter<"Owner"> | string
    streetNumber?: StringFilter<"Owner"> | string
    complement?: StringNullableFilter<"Owner"> | string | null
    neighborhood?: StringFilter<"Owner"> | string
    city?: StringFilter<"Owner"> | string
    state?: StringFilter<"Owner"> | string
    bankName?: StringFilter<"Owner"> | string
    bankAgency?: StringFilter<"Owner"> | string
    cep?: StringFilter<"Owner"> | string
    createdAt?: DateTimeFilter<"Owner"> | Date | string
    bankAccountNumber?: StringFilter<"Owner"> | string
    organizationId?: StringFilter<"Owner"> | string
    ownerVenue?: OwnerVenueListRelationFilter
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id">

  export type OwnerOrderByWithAggregationInput = {
    id?: SortOrder
    completeName?: SortOrder
    rg?: SortOrderInput | SortOrder
    cpf?: SortOrder
    pix?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    complement?: SortOrderInput | SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    bankName?: SortOrder
    bankAgency?: SortOrder
    cep?: SortOrder
    createdAt?: SortOrder
    bankAccountNumber?: SortOrder
    organizationId?: SortOrder
    _count?: OwnerCountOrderByAggregateInput
    _max?: OwnerMaxOrderByAggregateInput
    _min?: OwnerMinOrderByAggregateInput
  }

  export type OwnerScalarWhereWithAggregatesInput = {
    AND?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    OR?: OwnerScalarWhereWithAggregatesInput[]
    NOT?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Owner"> | string
    completeName?: StringWithAggregatesFilter<"Owner"> | string
    rg?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    cpf?: StringWithAggregatesFilter<"Owner"> | string
    pix?: StringWithAggregatesFilter<"Owner"> | string
    street?: StringWithAggregatesFilter<"Owner"> | string
    streetNumber?: StringWithAggregatesFilter<"Owner"> | string
    complement?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    neighborhood?: StringWithAggregatesFilter<"Owner"> | string
    city?: StringWithAggregatesFilter<"Owner"> | string
    state?: StringWithAggregatesFilter<"Owner"> | string
    bankName?: StringWithAggregatesFilter<"Owner"> | string
    bankAgency?: StringWithAggregatesFilter<"Owner"> | string
    cep?: StringWithAggregatesFilter<"Owner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Owner"> | Date | string
    bankAccountNumber?: StringWithAggregatesFilter<"Owner"> | string
    organizationId?: StringWithAggregatesFilter<"Owner"> | string
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: StringFilter<"Image"> | string
    imageUrl?: StringFilter<"Image"> | string
    description?: StringNullableFilter<"Image"> | string | null
    position?: IntFilter<"Image"> | number
    createdAt?: DateTimeNullableFilter<"Image"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Image"> | Date | string | null
    responsiveMode?: StringNullableFilter<"Image"> | string | null
    tag?: StringNullableFilter<"Image"> | string | null
    venueId?: StringFilter<"Image"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    responsiveMode?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    venueId?: SortOrder
    venue?: VenueOrderByWithRelationInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    imageUrl?: StringFilter<"Image"> | string
    description?: StringNullableFilter<"Image"> | string | null
    position?: IntFilter<"Image"> | number
    createdAt?: DateTimeNullableFilter<"Image"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Image"> | Date | string | null
    responsiveMode?: StringNullableFilter<"Image"> | string | null
    tag?: StringNullableFilter<"Image"> | string | null
    venueId?: StringFilter<"Image"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    responsiveMode?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    venueId?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Image"> | string
    imageUrl?: StringWithAggregatesFilter<"Image"> | string
    description?: StringNullableWithAggregatesFilter<"Image"> | string | null
    position?: IntWithAggregatesFilter<"Image"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"Image"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Image"> | Date | string | null
    responsiveMode?: StringNullableWithAggregatesFilter<"Image"> | string | null
    tag?: StringNullableWithAggregatesFilter<"Image"> | string | null
    venueId?: StringWithAggregatesFilter<"Image"> | string
  }

  export type TextWhereInput = {
    AND?: TextWhereInput | TextWhereInput[]
    OR?: TextWhereInput[]
    NOT?: TextWhereInput | TextWhereInput[]
    id?: StringFilter<"Text"> | string
    area?: StringFilter<"Text"> | string
    title?: StringNullableFilter<"Text"> | string | null
    position?: IntFilter<"Text"> | number
    text?: StringFilter<"Text"> | string
    createdAt?: DateTimeFilter<"Text"> | Date | string
    updatedAt?: DateTimeFilter<"Text"> | Date | string
    venueId?: StringFilter<"Text"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type TextOrderByWithRelationInput = {
    id?: SortOrder
    area?: SortOrder
    title?: SortOrderInput | SortOrder
    position?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
    venue?: VenueOrderByWithRelationInput
  }

  export type TextWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TextWhereInput | TextWhereInput[]
    OR?: TextWhereInput[]
    NOT?: TextWhereInput | TextWhereInput[]
    area?: StringFilter<"Text"> | string
    title?: StringNullableFilter<"Text"> | string | null
    position?: IntFilter<"Text"> | number
    text?: StringFilter<"Text"> | string
    createdAt?: DateTimeFilter<"Text"> | Date | string
    updatedAt?: DateTimeFilter<"Text"> | Date | string
    venueId?: StringFilter<"Text"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type TextOrderByWithAggregationInput = {
    id?: SortOrder
    area?: SortOrder
    title?: SortOrderInput | SortOrder
    position?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
    _count?: TextCountOrderByAggregateInput
    _avg?: TextAvgOrderByAggregateInput
    _max?: TextMaxOrderByAggregateInput
    _min?: TextMinOrderByAggregateInput
    _sum?: TextSumOrderByAggregateInput
  }

  export type TextScalarWhereWithAggregatesInput = {
    AND?: TextScalarWhereWithAggregatesInput | TextScalarWhereWithAggregatesInput[]
    OR?: TextScalarWhereWithAggregatesInput[]
    NOT?: TextScalarWhereWithAggregatesInput | TextScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Text"> | string
    area?: StringWithAggregatesFilter<"Text"> | string
    title?: StringNullableWithAggregatesFilter<"Text"> | string | null
    position?: IntWithAggregatesFilter<"Text"> | number
    text?: StringWithAggregatesFilter<"Text"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Text"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Text"> | Date | string
    venueId?: StringWithAggregatesFilter<"Text"> | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    question?: StringFilter<"Question"> | string
    response?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    venueId?: StringFilter<"Question"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
    venue?: VenueOrderByWithRelationInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    question?: StringFilter<"Question"> | string
    response?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    venueId?: StringFilter<"Question"> | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    question?: StringWithAggregatesFilter<"Question"> | string
    response?: StringWithAggregatesFilter<"Question"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    venueId?: StringWithAggregatesFilter<"Question"> | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: StringFilter<"Contract"> | string
    name?: StringFilter<"Contract"> | string
    title?: StringFilter<"Contract"> | string
    organizationId?: StringFilter<"Contract"> | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    clauses?: ClauseListRelationFilter
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    clauses?: ClauseOrderByRelationAggregateInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    name?: StringFilter<"Contract"> | string
    title?: StringFilter<"Contract"> | string
    organizationId?: StringFilter<"Contract"> | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    clauses?: ClauseListRelationFilter
  }, "id">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    organizationId?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contract"> | string
    name?: StringWithAggregatesFilter<"Contract"> | string
    title?: StringWithAggregatesFilter<"Contract"> | string
    organizationId?: StringWithAggregatesFilter<"Contract"> | string
  }

  export type ClauseWhereInput = {
    AND?: ClauseWhereInput | ClauseWhereInput[]
    OR?: ClauseWhereInput[]
    NOT?: ClauseWhereInput | ClauseWhereInput[]
    id?: StringFilter<"Clause"> | string
    text?: StringFilter<"Clause"> | string
    title?: StringFilter<"Clause"> | string
    position?: IntNullableFilter<"Clause"> | number | null
    createdAt?: DateTimeFilter<"Clause"> | Date | string
    updatedAt?: DateTimeFilter<"Clause"> | Date | string
    organizationId?: StringNullableFilter<"Clause"> | string | null
    contractId?: StringNullableFilter<"Clause"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    Contract?: XOR<ContractNullableRelationFilter, ContractWhereInput> | null
  }

  export type ClauseOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    title?: SortOrder
    position?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    contractId?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    Contract?: ContractOrderByWithRelationInput
  }

  export type ClauseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClauseWhereInput | ClauseWhereInput[]
    OR?: ClauseWhereInput[]
    NOT?: ClauseWhereInput | ClauseWhereInput[]
    text?: StringFilter<"Clause"> | string
    title?: StringFilter<"Clause"> | string
    position?: IntNullableFilter<"Clause"> | number | null
    createdAt?: DateTimeFilter<"Clause"> | Date | string
    updatedAt?: DateTimeFilter<"Clause"> | Date | string
    organizationId?: StringNullableFilter<"Clause"> | string | null
    contractId?: StringNullableFilter<"Clause"> | string | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    Contract?: XOR<ContractNullableRelationFilter, ContractWhereInput> | null
  }, "id">

  export type ClauseOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    title?: SortOrder
    position?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    contractId?: SortOrderInput | SortOrder
    _count?: ClauseCountOrderByAggregateInput
    _avg?: ClauseAvgOrderByAggregateInput
    _max?: ClauseMaxOrderByAggregateInput
    _min?: ClauseMinOrderByAggregateInput
    _sum?: ClauseSumOrderByAggregateInput
  }

  export type ClauseScalarWhereWithAggregatesInput = {
    AND?: ClauseScalarWhereWithAggregatesInput | ClauseScalarWhereWithAggregatesInput[]
    OR?: ClauseScalarWhereWithAggregatesInput[]
    NOT?: ClauseScalarWhereWithAggregatesInput | ClauseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Clause"> | string
    text?: StringWithAggregatesFilter<"Clause"> | string
    title?: StringWithAggregatesFilter<"Clause"> | string
    position?: IntNullableWithAggregatesFilter<"Clause"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Clause"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Clause"> | Date | string
    organizationId?: StringNullableWithAggregatesFilter<"Clause"> | string | null
    contractId?: StringNullableWithAggregatesFilter<"Clause"> | string | null
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    workerNumber?: IntFilter<"Schedule"> | number
    description?: StringNullableFilter<"Schedule"> | string | null
    startHour?: DateTimeFilter<"Schedule"> | Date | string
    endHour?: DateTimeFilter<"Schedule"> | Date | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    proposalId?: StringFilter<"Schedule"> | string
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    workerNumber?: SortOrder
    description?: SortOrderInput | SortOrder
    startHour?: SortOrder
    endHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalId?: SortOrder
    proposal?: ProposalOrderByWithRelationInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    name?: StringFilter<"Schedule"> | string
    workerNumber?: IntFilter<"Schedule"> | number
    description?: StringNullableFilter<"Schedule"> | string | null
    startHour?: DateTimeFilter<"Schedule"> | Date | string
    endHour?: DateTimeFilter<"Schedule"> | Date | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    proposalId?: StringFilter<"Schedule"> | string
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    workerNumber?: SortOrder
    description?: SortOrderInput | SortOrder
    startHour?: SortOrder
    endHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalId?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _avg?: ScheduleAvgOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
    _sum?: ScheduleSumOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    name?: StringWithAggregatesFilter<"Schedule"> | string
    workerNumber?: IntWithAggregatesFilter<"Schedule"> | number
    description?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    startHour?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    endHour?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    proposalId?: StringWithAggregatesFilter<"Schedule"> | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    expireIn: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokenInput
    session?: SessionCreateNestedManyWithoutRefreshTokenInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    expireIn: number
    userId: string
    createdAt?: Date | string
    session?: SessionUncheckedCreateNestedManyWithoutRefreshTokenInput
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expireIn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokenNestedInput
    session?: SessionUpdateManyWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expireIn?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUncheckedUpdateManyWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    expireIn: number
    userId: string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expireIn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expireIn?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    ipAddress?: string | null
    isValid?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutSessionInput
    refreshToken?: RefreshTokenCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshTokenId: string
    ipAddress?: string | null
    isValid?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionNestedInput
    refreshToken?: RefreshTokenUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    refreshTokenId: string
    ipAddress?: string | null
    isValid?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
    session?: SessionCreateNestedManyWithoutUserInput
    histories?: HistoryCreateNestedManyWithoutUserInput
    refreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    userOrganizations?: UserOrganizationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    histories?: HistoryUncheckedCreateNestedManyWithoutUserInput
    refreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    userOrganizations?: UserOrganizationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUpdateManyWithoutUserNestedInput
    histories?: HistoryUpdateManyWithoutUserNestedInput
    refreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    userOrganizations?: UserOrganizationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutUserNestedInput
    refreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    userOrganizations?: UserOrganizationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    venues?: VenueCreateNestedManyWithoutOrganizationInput
    owners?: OwnerCreateNestedManyWithoutOrganizationInput
    userOrganizations?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Clause?: ClauseCreateNestedManyWithoutOrganizationInput
    Contract?: ContractCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutOrganizationInput
    owners?: OwnerUncheckedCreateNestedManyWithoutOrganizationInput
    userOrganizations?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Clause?: ClauseUncheckedCreateNestedManyWithoutOrganizationInput
    Contract?: ContractUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutOrganizationNestedInput
    owners?: OwnerUpdateManyWithoutOrganizationNestedInput
    userOrganizations?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Clause?: ClauseUpdateManyWithoutOrganizationNestedInput
    Contract?: ContractUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutOrganizationNestedInput
    owners?: OwnerUncheckedUpdateManyWithoutOrganizationNestedInput
    userOrganizations?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Clause?: ClauseUncheckedUpdateManyWithoutOrganizationNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationCreateInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutUserOrganizationsInput
    organization: OrganizationCreateNestedOneWithoutUserOrganizationsInput
  }

  export type UserOrganizationUncheckedCreateInput = {
    id?: string
    userId: string
    organizationId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type UserOrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserOrganizationsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutUserOrganizationsNestedInput
  }

  export type UserOrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationCreateManyInput = {
    id?: string
    userId: string
    organizationId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type UserOrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCreateInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venue: VenueCreateNestedOneWithoutProposalsInput
    personList?: PersonCreateNestedManyWithoutProposalInput
    histories?: HistoryCreateNestedManyWithoutProposalInput
    payments?: PaymentCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceCreateNestedManyWithoutProposalInput
    noificationList?: NotificationCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venueId: string
    personList?: PersonUncheckedCreateNestedManyWithoutProposalInput
    histories?: HistoryUncheckedCreateNestedManyWithoutProposalInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventUncheckedCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostUncheckedCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutProposalInput
    noificationList?: NotificationUncheckedCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venue?: VenueUpdateOneRequiredWithoutProposalsNestedInput
    personList?: PersonUpdateManyWithoutProposalNestedInput
    histories?: HistoryUpdateManyWithoutProposalNestedInput
    payments?: PaymentUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
    personList?: PersonUncheckedUpdateManyWithoutProposalNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutProposalNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUncheckedUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUncheckedUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUncheckedUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalCreateManyInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venueId: string
  }

  export type ProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type HistoryCreateInput = {
    id?: string
    action: string
    username?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutHistoriesInput
    proposal: ProposalCreateNestedOneWithoutHistoriesInput
  }

  export type HistoryUncheckedCreateInput = {
    id?: string
    action: string
    username?: string | null
    userId?: string | null
    proposalId: string
    createdAt?: Date | string
  }

  export type HistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutHistoriesNestedInput
    proposal?: ProposalUpdateOneRequiredWithoutHistoriesNestedInput
  }

  export type HistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    proposalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryCreateManyInput = {
    id?: string
    action: string
    username?: string | null
    userId?: string | null
    proposalId: string
    createdAt?: Date | string
  }

  export type HistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    proposalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonCreateInput = {
    id?: string
    attendance?: boolean
    type: $Enums.PersonType
    name: string
    email?: string | null
    rg?: string | null
    proposal: ProposalCreateNestedOneWithoutPersonListInput
  }

  export type PersonUncheckedCreateInput = {
    id?: string
    attendance?: boolean
    type: $Enums.PersonType
    name: string
    email?: string | null
    rg?: string | null
    proposalId: string
  }

  export type PersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: ProposalUpdateOneRequiredWithoutPersonListNestedInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    proposalId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonCreateManyInput = {
    id?: string
    attendance?: boolean
    type: $Enums.PersonType
    name: string
    email?: string | null
    rg?: string | null
    proposalId: string
  }

  export type PersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    proposalId?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalServiceCreateInput = {
    id?: string
    joinedAt?: Date | string
    service: ServiceCreateNestedOneWithoutProposalServicesInput
    proposal: ProposalCreateNestedOneWithoutProposalServicesInput
  }

  export type ProposalServiceUncheckedCreateInput = {
    id?: string
    proposalId: string
    serviceId: string
    joinedAt?: Date | string
  }

  export type ProposalServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutProposalServicesNestedInput
    proposal?: ProposalUpdateOneRequiredWithoutProposalServicesNestedInput
  }

  export type ProposalServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalServiceCreateManyInput = {
    id?: string
    proposalId: string
    serviceId: string
    joinedAt?: Date | string
  }

  export type ProposalServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    price: number
    proposalServices?: ProposalServiceCreateNestedManyWithoutServiceInput
    venue: VenueCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    venueId: string
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    proposalServices?: ProposalServiceUpdateManyWithoutServiceNestedInput
    venue?: VenueUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    venueId?: StringFieldUpdateOperationsInput | string
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    price: number
    venueId: string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    proposal: ProposalCreateNestedOneWithoutPaymentsInput
    venue: VenueCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    proposalId: string
    venueId: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: ProposalUpdateOneRequiredWithoutPaymentsNestedInput
    venue?: VenueUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    proposalId: string
    venueId: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProposalCostCreateInput = {
    id?: string
    name: $Enums.ProposalName
    teste: string
    amount: number
    updatedAt?: Date | string
    createdAt?: Date | string
    proposals?: ProposalCreateNestedManyWithoutProposalCostsInput
  }

  export type ProposalCostUncheckedCreateInput = {
    id?: string
    name: $Enums.ProposalName
    teste: string
    amount: number
    updatedAt?: Date | string
    createdAt?: Date | string
    proposals?: ProposalUncheckedCreateNestedManyWithoutProposalCostsInput
  }

  export type ProposalCostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumProposalNameFieldUpdateOperationsInput | $Enums.ProposalName
    teste?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposals?: ProposalUpdateManyWithoutProposalCostsNestedInput
  }

  export type ProposalCostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumProposalNameFieldUpdateOperationsInput | $Enums.ProposalName
    teste?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposals?: ProposalUncheckedUpdateManyWithoutProposalCostsNestedInput
  }

  export type ProposalCostCreateManyInput = {
    id?: string
    name: $Enums.ProposalName
    teste: string
    amount: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ProposalCostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumProposalNameFieldUpdateOperationsInput | $Enums.ProposalName
    teste?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumProposalNameFieldUpdateOperationsInput | $Enums.ProposalName
    teste?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    name: string
    description?: string | null
    amount: number
    paymentDate: Date | string
    type: $Enums.ExpenseType
    category: $Enums.ExpenseCategory
    recurring: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    amount: number
    paymentDate: Date | string
    type: $Enums.ExpenseType
    category: $Enums.ExpenseCategory
    recurring: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    venueId: string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    recurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    recurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    amount: number
    paymentDate: Date | string
    type: $Enums.ExpenseType
    category: $Enums.ExpenseCategory
    recurring: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    venueId: string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    recurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    recurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
    venue: VenueCreateNestedOneWithoutNotificationsInput
    proposal?: ProposalCreateNestedOneWithoutNoificationListInput
    dateEvent?: DateEventCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    venueId: string
    proposalId?: string | null
    dateEventId?: string | null
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    venue?: VenueUpdateOneRequiredWithoutNotificationsNestedInput
    proposal?: ProposalUpdateOneWithoutNoificationListNestedInput
    dateEvent?: DateEventUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    dateEventId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationCreateManyInput = {
    id?: string
    venueId: string
    proposalId?: string | null
    dateEventId?: string | null
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    dateEventId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DateEventCreateInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.DateEventType
    venue: VenueCreateNestedOneWithoutDateEventInput
    proposal?: ProposalCreateNestedOneWithoutDateEventsInput
    notifications?: NotificationCreateNestedManyWithoutDateEventInput
  }

  export type DateEventUncheckedCreateInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalId?: string | null
    venueId: string
    type: $Enums.DateEventType
    notifications?: NotificationUncheckedCreateNestedManyWithoutDateEventInput
  }

  export type DateEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
    venue?: VenueUpdateOneRequiredWithoutDateEventNestedInput
    proposal?: ProposalUpdateOneWithoutDateEventsNestedInput
    notifications?: NotificationUpdateManyWithoutDateEventNestedInput
  }

  export type DateEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
    notifications?: NotificationUncheckedUpdateManyWithoutDateEventNestedInput
  }

  export type DateEventCreateManyInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalId?: string | null
    venueId: string
    type: $Enums.DateEventType
  }

  export type DateEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
  }

  export type DateEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
  }

  export type VenueCreateInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateManyInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
  }

  export type VenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
  }

  export type VenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
  }

  export type ContactCreateInput = {
    id?: string
    name: string
    role: string
    whatsapp: string
    venue: VenueCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    whatsapp: string
    venueId: string
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    venue?: VenueUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateManyInput = {
    id?: string
    name: string
    role: string
    whatsapp: string
    venueId: string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerVenueCreateInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutOwnerVenueInput
    venue: VenueCreateNestedOneWithoutOwnerVenueInput
  }

  export type OwnerVenueUncheckedCreateInput = {
    id?: string
    ownerId: string
    venueId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type OwnerVenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutOwnerVenueNestedInput
    venue?: VenueUpdateOneRequiredWithoutOwnerVenueNestedInput
  }

  export type OwnerVenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerVenueCreateManyInput = {
    id?: string
    ownerId: string
    venueId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type OwnerVenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerVenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerCreateInput = {
    id?: string
    completeName: string
    rg?: string | null
    cpf: string
    pix: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    bankName: string
    bankAgency: string
    cep: string
    createdAt?: Date | string
    bankAccountNumber: string
    ownerVenue?: OwnerVenueCreateNestedManyWithoutOwnerInput
    organization: OrganizationCreateNestedOneWithoutOwnersInput
  }

  export type OwnerUncheckedCreateInput = {
    id?: string
    completeName: string
    rg?: string | null
    cpf: string
    pix: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    bankName: string
    bankAgency: string
    cep: string
    createdAt?: Date | string
    bankAccountNumber: string
    organizationId: string
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: StringFieldUpdateOperationsInput | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: StringFieldUpdateOperationsInput | string
    pix?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAgency?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    ownerVenue?: OwnerVenueUpdateManyWithoutOwnerNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutOwnersNestedInput
  }

  export type OwnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: StringFieldUpdateOperationsInput | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: StringFieldUpdateOperationsInput | string
    pix?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAgency?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerCreateManyInput = {
    id?: string
    completeName: string
    rg?: string | null
    cpf: string
    pix: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    bankName: string
    bankAgency: string
    cep: string
    createdAt?: Date | string
    bankAccountNumber: string
    organizationId: string
  }

  export type OwnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: StringFieldUpdateOperationsInput | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: StringFieldUpdateOperationsInput | string
    pix?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAgency?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: StringFieldUpdateOperationsInput | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: StringFieldUpdateOperationsInput | string
    pix?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAgency?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateInput = {
    id?: string
    imageUrl: string
    description?: string | null
    position: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    responsiveMode?: string | null
    tag?: string | null
    venue: VenueCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateInput = {
    id?: string
    imageUrl: string
    description?: string | null
    position: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    responsiveMode?: string | null
    tag?: string | null
    venueId: string
  }

  export type ImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsiveMode?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: VenueUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsiveMode?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateManyInput = {
    id?: string
    imageUrl: string
    description?: string | null
    position: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    responsiveMode?: string | null
    tag?: string | null
    venueId: string
  }

  export type ImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsiveMode?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsiveMode?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type TextCreateInput = {
    id?: string
    area: string
    title?: string | null
    position?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutTextsInput
  }

  export type TextUncheckedCreateInput = {
    id?: string
    area: string
    title?: string | null
    position?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venueId: string
  }

  export type TextUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutTextsNestedInput
  }

  export type TextUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type TextCreateManyInput = {
    id?: string
    area: string
    title?: string | null
    position?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venueId: string
  }

  export type TextUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionCreateInput = {
    id?: string
    question: string
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    question: string
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venueId: string
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionCreateManyInput = {
    id?: string
    question: string
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venueId: string
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type ContractCreateInput = {
    id?: string
    name: string
    title: string
    organization: OrganizationCreateNestedOneWithoutContractInput
    clauses?: ClauseCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: string
    name: string
    title: string
    organizationId: string
    clauses?: ClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutContractNestedInput
    clauses?: ClauseUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    clauses?: ClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateManyInput = {
    id?: string
    name: string
    title: string
    organizationId: string
  }

  export type ContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type ClauseCreateInput = {
    id?: string
    text: string
    title: string
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutClauseInput
    Contract?: ContractCreateNestedOneWithoutClausesInput
  }

  export type ClauseUncheckedCreateInput = {
    id?: string
    text: string
    title: string
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId?: string | null
    contractId?: string | null
  }

  export type ClauseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutClauseNestedInput
    Contract?: ContractUpdateOneWithoutClausesNestedInput
  }

  export type ClauseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClauseCreateManyInput = {
    id?: string
    text: string
    title: string
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId?: string | null
    contractId?: string | null
  }

  export type ClauseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClauseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleCreateInput = {
    id?: string
    name: string
    workerNumber: number
    description?: string | null
    startHour: Date | string
    endHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposal: ProposalCreateNestedOneWithoutScheduleListInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    name: string
    workerNumber: number
    description?: string | null
    startHour: Date | string
    endHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalId: string
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workerNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startHour?: DateTimeFieldUpdateOperationsInput | Date | string
    endHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: ProposalUpdateOneRequiredWithoutScheduleListNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workerNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startHour?: DateTimeFieldUpdateOperationsInput | Date | string
    endHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleCreateManyInput = {
    id?: string
    name: string
    workerNumber: number
    description?: string | null
    startHour: Date | string
    endHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalId: string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workerNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startHour?: DateTimeFieldUpdateOperationsInput | Date | string
    endHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workerNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startHour?: DateTimeFieldUpdateOperationsInput | Date | string
    endHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    expireIn?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    expireIn?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    expireIn?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    expireIn?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    expireIn?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type RefreshTokenNullableRelationFilter = {
    is?: RefreshTokenWhereInput | null
    isNot?: RefreshTokenWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenId?: SortOrder
    ipAddress?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenId?: SortOrder
    ipAddress?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenId?: SortOrder
    ipAddress?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type HistoryListRelationFilter = {
    every?: HistoryWhereInput
    some?: HistoryWhereInput
    none?: HistoryWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type UserOrganizationListRelationFilter = {
    every?: UserOrganizationWhereInput
    some?: UserOrganizationWhereInput
    none?: UserOrganizationWhereInput
  }

  export type HistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrganizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
  }

  export type VenueListRelationFilter = {
    every?: VenueWhereInput
    some?: VenueWhereInput
    none?: VenueWhereInput
  }

  export type OwnerListRelationFilter = {
    every?: OwnerWhereInput
    some?: OwnerWhereInput
    none?: OwnerWhereInput
  }

  export type ClauseListRelationFilter = {
    every?: ClauseWhereInput
    some?: ClauseWhereInput
    none?: ClauseWhereInput
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type VenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OwnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClauseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type UserOrganizationUserIdOrganizationIdCompoundUniqueInput = {
    userId: string
    organizationId: string
  }

  export type UserOrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type UserOrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type UserOrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumProposalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalType | EnumProposalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalType[]
    notIn?: $Enums.ProposalType[]
    not?: NestedEnumProposalTypeFilter<$PrismaModel> | $Enums.ProposalType
  }

  export type EnumTrafficSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficSource | EnumTrafficSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TrafficSource[]
    notIn?: $Enums.TrafficSource[]
    not?: NestedEnumTrafficSourceFilter<$PrismaModel> | $Enums.TrafficSource
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VenueRelationFilter = {
    is?: VenueWhereInput
    isNot?: VenueWhereInput
  }

  export type PersonListRelationFilter = {
    every?: PersonWhereInput
    some?: PersonWhereInput
    none?: PersonWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type DateEventListRelationFilter = {
    every?: DateEventWhereInput
    some?: DateEventWhereInput
    none?: DateEventWhereInput
  }

  export type ProposalCostListRelationFilter = {
    every?: ProposalCostWhereInput
    some?: ProposalCostWhereInput
    none?: ProposalCostWhereInput
  }

  export type ProposalServiceListRelationFilter = {
    every?: ProposalServiceWhereInput
    some?: ProposalServiceWhereInput
    none?: ProposalServiceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type PersonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DateEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalCostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalCountOrderByAggregateInput = {
    id?: SortOrder
    completeName?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    neighborhood?: SortOrder
    cep?: SortOrder
    city?: SortOrder
    state?: SortOrder
    type?: SortOrder
    trafficSource?: SortOrder
    guestNumber?: SortOrder
    knowsVenue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    name?: SortOrder
    email?: SortOrder
    whatsapp?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    extraHoursQty?: SortOrder
    extraHourPrice?: SortOrder
    totalAmount?: SortOrder
    termsAccepted?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: SortOrder
    paid?: SortOrder
    amountPaid?: SortOrder
    venueId?: SortOrder
  }

  export type ProposalAvgOrderByAggregateInput = {
    guestNumber?: SortOrder
    basePrice?: SortOrder
    extraHoursQty?: SortOrder
    extraHourPrice?: SortOrder
    totalAmount?: SortOrder
    amountPaid?: SortOrder
  }

  export type ProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    completeName?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    neighborhood?: SortOrder
    cep?: SortOrder
    city?: SortOrder
    state?: SortOrder
    type?: SortOrder
    trafficSource?: SortOrder
    guestNumber?: SortOrder
    knowsVenue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    name?: SortOrder
    email?: SortOrder
    whatsapp?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    extraHoursQty?: SortOrder
    extraHourPrice?: SortOrder
    totalAmount?: SortOrder
    termsAccepted?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: SortOrder
    paid?: SortOrder
    amountPaid?: SortOrder
    venueId?: SortOrder
  }

  export type ProposalMinOrderByAggregateInput = {
    id?: SortOrder
    completeName?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    neighborhood?: SortOrder
    cep?: SortOrder
    city?: SortOrder
    state?: SortOrder
    type?: SortOrder
    trafficSource?: SortOrder
    guestNumber?: SortOrder
    knowsVenue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    name?: SortOrder
    email?: SortOrder
    whatsapp?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    extraHoursQty?: SortOrder
    extraHourPrice?: SortOrder
    totalAmount?: SortOrder
    termsAccepted?: SortOrder
    approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: SortOrder
    paid?: SortOrder
    amountPaid?: SortOrder
    venueId?: SortOrder
  }

  export type ProposalSumOrderByAggregateInput = {
    guestNumber?: SortOrder
    basePrice?: SortOrder
    extraHoursQty?: SortOrder
    extraHourPrice?: SortOrder
    totalAmount?: SortOrder
    amountPaid?: SortOrder
  }

  export type EnumProposalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalType | EnumProposalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalType[]
    notIn?: $Enums.ProposalType[]
    not?: NestedEnumProposalTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProposalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalTypeFilter<$PrismaModel>
    _max?: NestedEnumProposalTypeFilter<$PrismaModel>
  }

  export type EnumTrafficSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficSource | EnumTrafficSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TrafficSource[]
    notIn?: $Enums.TrafficSource[]
    not?: NestedEnumTrafficSourceWithAggregatesFilter<$PrismaModel> | $Enums.TrafficSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrafficSourceFilter<$PrismaModel>
    _max?: NestedEnumTrafficSourceFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ProposalRelationFilter = {
    is?: ProposalWhereInput
    isNot?: ProposalWhereInput
  }

  export type HistoryCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    proposalId?: SortOrder
    createdAt?: SortOrder
  }

  export type HistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    proposalId?: SortOrder
    createdAt?: SortOrder
  }

  export type HistoryMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    proposalId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPersonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[]
    notIn?: $Enums.PersonType[]
    not?: NestedEnumPersonTypeFilter<$PrismaModel> | $Enums.PersonType
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    attendance?: SortOrder
    type?: SortOrder
    name?: SortOrder
    email?: SortOrder
    rg?: SortOrder
    proposalId?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    attendance?: SortOrder
    type?: SortOrder
    name?: SortOrder
    email?: SortOrder
    rg?: SortOrder
    proposalId?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    attendance?: SortOrder
    type?: SortOrder
    name?: SortOrder
    email?: SortOrder
    rg?: SortOrder
    proposalId?: SortOrder
  }

  export type EnumPersonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[]
    notIn?: $Enums.PersonType[]
    not?: NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel> | $Enums.PersonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonTypeFilter<$PrismaModel>
    _max?: NestedEnumPersonTypeFilter<$PrismaModel>
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ProposalServiceCountOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    serviceId?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProposalServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    serviceId?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProposalServiceMinOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    serviceId?: SortOrder
    joinedAt?: SortOrder
  }

  export type ServiceNameVenueIdCompoundUniqueInput = {
    name: string
    venueId: string
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    venueId?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    venueId?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    venueId?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | null
    notIn?: $Enums.PaymentMethod[] | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    venueId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageUrl?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    venueId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageUrl?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    venueId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imageUrl?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | null
    notIn?: $Enums.PaymentMethod[] | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type EnumProposalNameFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalName | EnumProposalNameFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalName[]
    notIn?: $Enums.ProposalName[]
    not?: NestedEnumProposalNameFilter<$PrismaModel> | $Enums.ProposalName
  }

  export type ProposalListRelationFilter = {
    every?: ProposalWhereInput
    some?: ProposalWhereInput
    none?: ProposalWhereInput
  }

  export type ProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalCostCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    teste?: SortOrder
    amount?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProposalCostAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ProposalCostMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    teste?: SortOrder
    amount?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProposalCostMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    teste?: SortOrder
    amount?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProposalCostSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumProposalNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalName | EnumProposalNameFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalName[]
    notIn?: $Enums.ProposalName[]
    not?: NestedEnumProposalNameWithAggregatesFilter<$PrismaModel> | $Enums.ProposalName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalNameFilter<$PrismaModel>
    _max?: NestedEnumProposalNameFilter<$PrismaModel>
  }

  export type EnumExpenseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[]
    notIn?: $Enums.ExpenseType[]
    not?: NestedEnumExpenseTypeFilter<$PrismaModel> | $Enums.ExpenseType
  }

  export type EnumExpenseCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[]
    notIn?: $Enums.ExpenseCategory[]
    not?: NestedEnumExpenseCategoryFilter<$PrismaModel> | $Enums.ExpenseCategory
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    type?: SortOrder
    category?: SortOrder
    recurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    type?: SortOrder
    category?: SortOrder
    recurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    type?: SortOrder
    category?: SortOrder
    recurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumExpenseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[]
    notIn?: $Enums.ExpenseType[]
    not?: NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseTypeFilter<$PrismaModel>
    _max?: NestedEnumExpenseTypeFilter<$PrismaModel>
  }

  export type EnumExpenseCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[]
    notIn?: $Enums.ExpenseCategory[]
    not?: NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type ProposalNullableRelationFilter = {
    is?: ProposalWhereInput | null
    isNot?: ProposalWhereInput | null
  }

  export type DateEventNullableRelationFilter = {
    is?: DateEventWhereInput | null
    isNot?: DateEventWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    proposalId?: SortOrder
    dateEventId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    proposalId?: SortOrder
    dateEventId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    proposalId?: SortOrder
    dateEventId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumDateEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DateEventType | EnumDateEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DateEventType[]
    notIn?: $Enums.DateEventType[]
    not?: NestedEnumDateEventTypeFilter<$PrismaModel> | $Enums.DateEventType
  }

  export type DateEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalId?: SortOrder
    venueId?: SortOrder
    type?: SortOrder
  }

  export type DateEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalId?: SortOrder
    venueId?: SortOrder
    type?: SortOrder
  }

  export type DateEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalId?: SortOrder
    venueId?: SortOrder
    type?: SortOrder
  }

  export type EnumDateEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DateEventType | EnumDateEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DateEventType[]
    notIn?: $Enums.DateEventType[]
    not?: NestedEnumDateEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.DateEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDateEventTypeFilter<$PrismaModel>
    _max?: NestedEnumDateEventTypeFilter<$PrismaModel>
  }

  export type EnumPricingModelFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[]
    notIn?: $Enums.PricingModel[]
    not?: NestedEnumPricingModelFilter<$PrismaModel> | $Enums.PricingModel
  }

  export type TextListRelationFilter = {
    every?: TextWhereInput
    some?: TextWhereInput
    none?: TextWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type OwnerVenueListRelationFilter = {
    every?: OwnerVenueWhereInput
    some?: OwnerVenueWhereInput
    none?: OwnerVenueWhereInput
  }

  export type TextOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OwnerVenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    complement?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    cep?: SortOrder
    hasOvernightStay?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    pricingModel?: SortOrder
    pricePerPerson?: SortOrder
    pricePerDay?: SortOrder
    maxGuest?: SortOrder
  }

  export type VenueAvgOrderByAggregateInput = {
    pricePerPerson?: SortOrder
    pricePerDay?: SortOrder
    maxGuest?: SortOrder
  }

  export type VenueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    complement?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    cep?: SortOrder
    hasOvernightStay?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    pricingModel?: SortOrder
    pricePerPerson?: SortOrder
    pricePerDay?: SortOrder
    maxGuest?: SortOrder
  }

  export type VenueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    complement?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    cep?: SortOrder
    hasOvernightStay?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    pricingModel?: SortOrder
    pricePerPerson?: SortOrder
    pricePerDay?: SortOrder
    maxGuest?: SortOrder
  }

  export type VenueSumOrderByAggregateInput = {
    pricePerPerson?: SortOrder
    pricePerDay?: SortOrder
    maxGuest?: SortOrder
  }

  export type EnumPricingModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[]
    notIn?: $Enums.PricingModel[]
    not?: NestedEnumPricingModelWithAggregatesFilter<$PrismaModel> | $Enums.PricingModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingModelFilter<$PrismaModel>
    _max?: NestedEnumPricingModelFilter<$PrismaModel>
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    whatsapp?: SortOrder
    venueId?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    whatsapp?: SortOrder
    venueId?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    whatsapp?: SortOrder
    venueId?: SortOrder
  }

  export type OwnerRelationFilter = {
    is?: OwnerWhereInput
    isNot?: OwnerWhereInput
  }

  export type OwnerVenueOwnerIdVenueIdCompoundUniqueInput = {
    ownerId: string
    venueId: string
  }

  export type OwnerVenueCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    venueId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type OwnerVenueMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    venueId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type OwnerVenueMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    venueId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type OwnerCountOrderByAggregateInput = {
    id?: SortOrder
    completeName?: SortOrder
    rg?: SortOrder
    cpf?: SortOrder
    pix?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    complement?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    bankName?: SortOrder
    bankAgency?: SortOrder
    cep?: SortOrder
    createdAt?: SortOrder
    bankAccountNumber?: SortOrder
    organizationId?: SortOrder
  }

  export type OwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    completeName?: SortOrder
    rg?: SortOrder
    cpf?: SortOrder
    pix?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    complement?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    bankName?: SortOrder
    bankAgency?: SortOrder
    cep?: SortOrder
    createdAt?: SortOrder
    bankAccountNumber?: SortOrder
    organizationId?: SortOrder
  }

  export type OwnerMinOrderByAggregateInput = {
    id?: SortOrder
    completeName?: SortOrder
    rg?: SortOrder
    cpf?: SortOrder
    pix?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    complement?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    bankName?: SortOrder
    bankAgency?: SortOrder
    cep?: SortOrder
    createdAt?: SortOrder
    bankAccountNumber?: SortOrder
    organizationId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responsiveMode?: SortOrder
    tag?: SortOrder
    venueId?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responsiveMode?: SortOrder
    tag?: SortOrder
    venueId?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responsiveMode?: SortOrder
    tag?: SortOrder
    venueId?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TextCountOrderByAggregateInput = {
    id?: SortOrder
    area?: SortOrder
    title?: SortOrder
    position?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
  }

  export type TextAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type TextMaxOrderByAggregateInput = {
    id?: SortOrder
    area?: SortOrder
    title?: SortOrder
    position?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
  }

  export type TextMinOrderByAggregateInput = {
    id?: SortOrder
    area?: SortOrder
    title?: SortOrder
    position?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
  }

  export type TextSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venueId?: SortOrder
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    organizationId?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    organizationId?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    organizationId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type OrganizationNullableRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type ContractNullableRelationFilter = {
    is?: ContractWhereInput | null
    isNot?: ContractWhereInput | null
  }

  export type ClauseCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    title?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    contractId?: SortOrder
  }

  export type ClauseAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ClauseMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    title?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    contractId?: SortOrder
  }

  export type ClauseMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    title?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    contractId?: SortOrder
  }

  export type ClauseSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    workerNumber?: SortOrder
    description?: SortOrder
    startHour?: SortOrder
    endHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalId?: SortOrder
  }

  export type ScheduleAvgOrderByAggregateInput = {
    workerNumber?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    workerNumber?: SortOrder
    description?: SortOrder
    startHour?: SortOrder
    endHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalId?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    workerNumber?: SortOrder
    description?: SortOrder
    startHour?: SortOrder
    endHour?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalId?: SortOrder
  }

  export type ScheduleSumOrderByAggregateInput = {
    workerNumber?: SortOrder
  }

  export type UserCreateNestedOneWithoutRefreshTokenInput = {
    create?: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokenInput
    connect?: UserWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutRefreshTokenInput = {
    create?: XOR<SessionCreateWithoutRefreshTokenInput, SessionUncheckedCreateWithoutRefreshTokenInput> | SessionCreateWithoutRefreshTokenInput[] | SessionUncheckedCreateWithoutRefreshTokenInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutRefreshTokenInput | SessionCreateOrConnectWithoutRefreshTokenInput[]
    createMany?: SessionCreateManyRefreshTokenInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutRefreshTokenInput = {
    create?: XOR<SessionCreateWithoutRefreshTokenInput, SessionUncheckedCreateWithoutRefreshTokenInput> | SessionCreateWithoutRefreshTokenInput[] | SessionUncheckedCreateWithoutRefreshTokenInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutRefreshTokenInput | SessionCreateOrConnectWithoutRefreshTokenInput[]
    createMany?: SessionCreateManyRefreshTokenInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutRefreshTokenNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokenInput
    upsert?: UserUpsertWithoutRefreshTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokenInput, UserUpdateWithoutRefreshTokenInput>, UserUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type SessionUpdateManyWithoutRefreshTokenNestedInput = {
    create?: XOR<SessionCreateWithoutRefreshTokenInput, SessionUncheckedCreateWithoutRefreshTokenInput> | SessionCreateWithoutRefreshTokenInput[] | SessionUncheckedCreateWithoutRefreshTokenInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutRefreshTokenInput | SessionCreateOrConnectWithoutRefreshTokenInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutRefreshTokenInput | SessionUpsertWithWhereUniqueWithoutRefreshTokenInput[]
    createMany?: SessionCreateManyRefreshTokenInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutRefreshTokenInput | SessionUpdateWithWhereUniqueWithoutRefreshTokenInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutRefreshTokenInput | SessionUpdateManyWithWhereWithoutRefreshTokenInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutRefreshTokenNestedInput = {
    create?: XOR<SessionCreateWithoutRefreshTokenInput, SessionUncheckedCreateWithoutRefreshTokenInput> | SessionCreateWithoutRefreshTokenInput[] | SessionUncheckedCreateWithoutRefreshTokenInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutRefreshTokenInput | SessionCreateOrConnectWithoutRefreshTokenInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutRefreshTokenInput | SessionUpsertWithWhereUniqueWithoutRefreshTokenInput[]
    createMany?: SessionCreateManyRefreshTokenInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutRefreshTokenInput | SessionUpdateWithWhereUniqueWithoutRefreshTokenInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutRefreshTokenInput | SessionUpdateManyWithWhereWithoutRefreshTokenInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    connect?: UserWhereUniqueInput
  }

  export type RefreshTokenCreateNestedOneWithoutSessionInput = {
    create?: XOR<RefreshTokenCreateWithoutSessionInput, RefreshTokenUncheckedCreateWithoutSessionInput>
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutSessionInput
    connect?: RefreshTokenWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    upsert?: UserUpsertWithoutSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionInput, UserUpdateWithoutSessionInput>, UserUncheckedUpdateWithoutSessionInput>
  }

  export type RefreshTokenUpdateOneWithoutSessionNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutSessionInput, RefreshTokenUncheckedCreateWithoutSessionInput>
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutSessionInput
    upsert?: RefreshTokenUpsertWithoutSessionInput
    disconnect?: RefreshTokenWhereInput | boolean
    delete?: RefreshTokenWhereInput | boolean
    connect?: RefreshTokenWhereUniqueInput
    update?: XOR<XOR<RefreshTokenUpdateToOneWithWhereWithoutSessionInput, RefreshTokenUpdateWithoutSessionInput>, RefreshTokenUncheckedUpdateWithoutSessionInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type HistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput> | HistoryCreateWithoutUserInput[] | HistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutUserInput | HistoryCreateOrConnectWithoutUserInput[]
    createMany?: HistoryCreateManyUserInputEnvelope
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserOrganizationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserOrganizationCreateWithoutUserInput, UserOrganizationUncheckedCreateWithoutUserInput> | UserOrganizationCreateWithoutUserInput[] | UserOrganizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutUserInput | UserOrganizationCreateOrConnectWithoutUserInput[]
    createMany?: UserOrganizationCreateManyUserInputEnvelope
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type HistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput> | HistoryCreateWithoutUserInput[] | HistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutUserInput | HistoryCreateOrConnectWithoutUserInput[]
    createMany?: HistoryCreateManyUserInputEnvelope
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserOrganizationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserOrganizationCreateWithoutUserInput, UserOrganizationUncheckedCreateWithoutUserInput> | UserOrganizationCreateWithoutUserInput[] | UserOrganizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutUserInput | UserOrganizationCreateOrConnectWithoutUserInput[]
    createMany?: UserOrganizationCreateManyUserInputEnvelope
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type HistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput> | HistoryCreateWithoutUserInput[] | HistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutUserInput | HistoryCreateOrConnectWithoutUserInput[]
    upsert?: HistoryUpsertWithWhereUniqueWithoutUserInput | HistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HistoryCreateManyUserInputEnvelope
    set?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    disconnect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    delete?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    update?: HistoryUpdateWithWhereUniqueWithoutUserInput | HistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HistoryUpdateManyWithWhereWithoutUserInput | HistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HistoryScalarWhereInput | HistoryScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserOrganizationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserOrganizationCreateWithoutUserInput, UserOrganizationUncheckedCreateWithoutUserInput> | UserOrganizationCreateWithoutUserInput[] | UserOrganizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutUserInput | UserOrganizationCreateOrConnectWithoutUserInput[]
    upsert?: UserOrganizationUpsertWithWhereUniqueWithoutUserInput | UserOrganizationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserOrganizationCreateManyUserInputEnvelope
    set?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    disconnect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    delete?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    update?: UserOrganizationUpdateWithWhereUniqueWithoutUserInput | UserOrganizationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserOrganizationUpdateManyWithWhereWithoutUserInput | UserOrganizationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type HistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput> | HistoryCreateWithoutUserInput[] | HistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutUserInput | HistoryCreateOrConnectWithoutUserInput[]
    upsert?: HistoryUpsertWithWhereUniqueWithoutUserInput | HistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HistoryCreateManyUserInputEnvelope
    set?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    disconnect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    delete?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    update?: HistoryUpdateWithWhereUniqueWithoutUserInput | HistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HistoryUpdateManyWithWhereWithoutUserInput | HistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HistoryScalarWhereInput | HistoryScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserOrganizationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserOrganizationCreateWithoutUserInput, UserOrganizationUncheckedCreateWithoutUserInput> | UserOrganizationCreateWithoutUserInput[] | UserOrganizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutUserInput | UserOrganizationCreateOrConnectWithoutUserInput[]
    upsert?: UserOrganizationUpsertWithWhereUniqueWithoutUserInput | UserOrganizationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserOrganizationCreateManyUserInputEnvelope
    set?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    disconnect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    delete?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    update?: UserOrganizationUpdateWithWhereUniqueWithoutUserInput | UserOrganizationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserOrganizationUpdateManyWithWhereWithoutUserInput | UserOrganizationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
  }

  export type VenueCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<VenueCreateWithoutOrganizationInput, VenueUncheckedCreateWithoutOrganizationInput> | VenueCreateWithoutOrganizationInput[] | VenueUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutOrganizationInput | VenueCreateOrConnectWithoutOrganizationInput[]
    createMany?: VenueCreateManyOrganizationInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type OwnerCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OwnerCreateWithoutOrganizationInput, OwnerUncheckedCreateWithoutOrganizationInput> | OwnerCreateWithoutOrganizationInput[] | OwnerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutOrganizationInput | OwnerCreateOrConnectWithoutOrganizationInput[]
    createMany?: OwnerCreateManyOrganizationInputEnvelope
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
  }

  export type UserOrganizationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput> | UserOrganizationCreateWithoutOrganizationInput[] | UserOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutOrganizationInput | UserOrganizationCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserOrganizationCreateManyOrganizationInputEnvelope
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
  }

  export type ClauseCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ClauseCreateWithoutOrganizationInput, ClauseUncheckedCreateWithoutOrganizationInput> | ClauseCreateWithoutOrganizationInput[] | ClauseUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ClauseCreateOrConnectWithoutOrganizationInput | ClauseCreateOrConnectWithoutOrganizationInput[]
    createMany?: ClauseCreateManyOrganizationInputEnvelope
    connect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ContractCreateWithoutOrganizationInput, ContractUncheckedCreateWithoutOrganizationInput> | ContractCreateWithoutOrganizationInput[] | ContractUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutOrganizationInput | ContractCreateOrConnectWithoutOrganizationInput[]
    createMany?: ContractCreateManyOrganizationInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type VenueUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<VenueCreateWithoutOrganizationInput, VenueUncheckedCreateWithoutOrganizationInput> | VenueCreateWithoutOrganizationInput[] | VenueUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutOrganizationInput | VenueCreateOrConnectWithoutOrganizationInput[]
    createMany?: VenueCreateManyOrganizationInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type OwnerUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OwnerCreateWithoutOrganizationInput, OwnerUncheckedCreateWithoutOrganizationInput> | OwnerCreateWithoutOrganizationInput[] | OwnerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutOrganizationInput | OwnerCreateOrConnectWithoutOrganizationInput[]
    createMany?: OwnerCreateManyOrganizationInputEnvelope
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
  }

  export type UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput> | UserOrganizationCreateWithoutOrganizationInput[] | UserOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutOrganizationInput | UserOrganizationCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserOrganizationCreateManyOrganizationInputEnvelope
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
  }

  export type ClauseUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ClauseCreateWithoutOrganizationInput, ClauseUncheckedCreateWithoutOrganizationInput> | ClauseCreateWithoutOrganizationInput[] | ClauseUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ClauseCreateOrConnectWithoutOrganizationInput | ClauseCreateOrConnectWithoutOrganizationInput[]
    createMany?: ClauseCreateManyOrganizationInputEnvelope
    connect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ContractCreateWithoutOrganizationInput, ContractUncheckedCreateWithoutOrganizationInput> | ContractCreateWithoutOrganizationInput[] | ContractUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutOrganizationInput | ContractCreateOrConnectWithoutOrganizationInput[]
    createMany?: ContractCreateManyOrganizationInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type VenueUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<VenueCreateWithoutOrganizationInput, VenueUncheckedCreateWithoutOrganizationInput> | VenueCreateWithoutOrganizationInput[] | VenueUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutOrganizationInput | VenueCreateOrConnectWithoutOrganizationInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutOrganizationInput | VenueUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: VenueCreateManyOrganizationInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutOrganizationInput | VenueUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutOrganizationInput | VenueUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type OwnerUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OwnerCreateWithoutOrganizationInput, OwnerUncheckedCreateWithoutOrganizationInput> | OwnerCreateWithoutOrganizationInput[] | OwnerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutOrganizationInput | OwnerCreateOrConnectWithoutOrganizationInput[]
    upsert?: OwnerUpsertWithWhereUniqueWithoutOrganizationInput | OwnerUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OwnerCreateManyOrganizationInputEnvelope
    set?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    disconnect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    delete?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    update?: OwnerUpdateWithWhereUniqueWithoutOrganizationInput | OwnerUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OwnerUpdateManyWithWhereWithoutOrganizationInput | OwnerUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
  }

  export type UserOrganizationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput> | UserOrganizationCreateWithoutOrganizationInput[] | UserOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutOrganizationInput | UserOrganizationCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserOrganizationUpsertWithWhereUniqueWithoutOrganizationInput | UserOrganizationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserOrganizationCreateManyOrganizationInputEnvelope
    set?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    disconnect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    delete?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    update?: UserOrganizationUpdateWithWhereUniqueWithoutOrganizationInput | UserOrganizationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserOrganizationUpdateManyWithWhereWithoutOrganizationInput | UserOrganizationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
  }

  export type ClauseUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ClauseCreateWithoutOrganizationInput, ClauseUncheckedCreateWithoutOrganizationInput> | ClauseCreateWithoutOrganizationInput[] | ClauseUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ClauseCreateOrConnectWithoutOrganizationInput | ClauseCreateOrConnectWithoutOrganizationInput[]
    upsert?: ClauseUpsertWithWhereUniqueWithoutOrganizationInput | ClauseUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ClauseCreateManyOrganizationInputEnvelope
    set?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    disconnect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    delete?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    connect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    update?: ClauseUpdateWithWhereUniqueWithoutOrganizationInput | ClauseUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ClauseUpdateManyWithWhereWithoutOrganizationInput | ClauseUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ClauseScalarWhereInput | ClauseScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ContractCreateWithoutOrganizationInput, ContractUncheckedCreateWithoutOrganizationInput> | ContractCreateWithoutOrganizationInput[] | ContractUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutOrganizationInput | ContractCreateOrConnectWithoutOrganizationInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutOrganizationInput | ContractUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ContractCreateManyOrganizationInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutOrganizationInput | ContractUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutOrganizationInput | ContractUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type VenueUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<VenueCreateWithoutOrganizationInput, VenueUncheckedCreateWithoutOrganizationInput> | VenueCreateWithoutOrganizationInput[] | VenueUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutOrganizationInput | VenueCreateOrConnectWithoutOrganizationInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutOrganizationInput | VenueUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: VenueCreateManyOrganizationInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutOrganizationInput | VenueUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutOrganizationInput | VenueUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type OwnerUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OwnerCreateWithoutOrganizationInput, OwnerUncheckedCreateWithoutOrganizationInput> | OwnerCreateWithoutOrganizationInput[] | OwnerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutOrganizationInput | OwnerCreateOrConnectWithoutOrganizationInput[]
    upsert?: OwnerUpsertWithWhereUniqueWithoutOrganizationInput | OwnerUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OwnerCreateManyOrganizationInputEnvelope
    set?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    disconnect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    delete?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    update?: OwnerUpdateWithWhereUniqueWithoutOrganizationInput | OwnerUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OwnerUpdateManyWithWhereWithoutOrganizationInput | OwnerUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
  }

  export type UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput> | UserOrganizationCreateWithoutOrganizationInput[] | UserOrganizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserOrganizationCreateOrConnectWithoutOrganizationInput | UserOrganizationCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserOrganizationUpsertWithWhereUniqueWithoutOrganizationInput | UserOrganizationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserOrganizationCreateManyOrganizationInputEnvelope
    set?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    disconnect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    delete?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    connect?: UserOrganizationWhereUniqueInput | UserOrganizationWhereUniqueInput[]
    update?: UserOrganizationUpdateWithWhereUniqueWithoutOrganizationInput | UserOrganizationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserOrganizationUpdateManyWithWhereWithoutOrganizationInput | UserOrganizationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
  }

  export type ClauseUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ClauseCreateWithoutOrganizationInput, ClauseUncheckedCreateWithoutOrganizationInput> | ClauseCreateWithoutOrganizationInput[] | ClauseUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ClauseCreateOrConnectWithoutOrganizationInput | ClauseCreateOrConnectWithoutOrganizationInput[]
    upsert?: ClauseUpsertWithWhereUniqueWithoutOrganizationInput | ClauseUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ClauseCreateManyOrganizationInputEnvelope
    set?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    disconnect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    delete?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    connect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    update?: ClauseUpdateWithWhereUniqueWithoutOrganizationInput | ClauseUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ClauseUpdateManyWithWhereWithoutOrganizationInput | ClauseUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ClauseScalarWhereInput | ClauseScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ContractCreateWithoutOrganizationInput, ContractUncheckedCreateWithoutOrganizationInput> | ContractCreateWithoutOrganizationInput[] | ContractUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutOrganizationInput | ContractCreateOrConnectWithoutOrganizationInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutOrganizationInput | ContractUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ContractCreateManyOrganizationInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutOrganizationInput | ContractUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutOrganizationInput | ContractUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserOrganizationsInput = {
    create?: XOR<UserCreateWithoutUserOrganizationsInput, UserUncheckedCreateWithoutUserOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserOrganizationsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutUserOrganizationsInput = {
    create?: XOR<OrganizationCreateWithoutUserOrganizationsInput, OrganizationUncheckedCreateWithoutUserOrganizationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserOrganizationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type UserUpdateOneRequiredWithoutUserOrganizationsNestedInput = {
    create?: XOR<UserCreateWithoutUserOrganizationsInput, UserUncheckedCreateWithoutUserOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserOrganizationsInput
    upsert?: UserUpsertWithoutUserOrganizationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserOrganizationsInput, UserUpdateWithoutUserOrganizationsInput>, UserUncheckedUpdateWithoutUserOrganizationsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutUserOrganizationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutUserOrganizationsInput, OrganizationUncheckedCreateWithoutUserOrganizationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserOrganizationsInput
    upsert?: OrganizationUpsertWithoutUserOrganizationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUserOrganizationsInput, OrganizationUpdateWithoutUserOrganizationsInput>, OrganizationUncheckedUpdateWithoutUserOrganizationsInput>
  }

  export type VenueCreateNestedOneWithoutProposalsInput = {
    create?: XOR<VenueCreateWithoutProposalsInput, VenueUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutProposalsInput
    connect?: VenueWhereUniqueInput
  }

  export type PersonCreateNestedManyWithoutProposalInput = {
    create?: XOR<PersonCreateWithoutProposalInput, PersonUncheckedCreateWithoutProposalInput> | PersonCreateWithoutProposalInput[] | PersonUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutProposalInput | PersonCreateOrConnectWithoutProposalInput[]
    createMany?: PersonCreateManyProposalInputEnvelope
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
  }

  export type HistoryCreateNestedManyWithoutProposalInput = {
    create?: XOR<HistoryCreateWithoutProposalInput, HistoryUncheckedCreateWithoutProposalInput> | HistoryCreateWithoutProposalInput[] | HistoryUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutProposalInput | HistoryCreateOrConnectWithoutProposalInput[]
    createMany?: HistoryCreateManyProposalInputEnvelope
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutProposalInput = {
    create?: XOR<PaymentCreateWithoutProposalInput, PaymentUncheckedCreateWithoutProposalInput> | PaymentCreateWithoutProposalInput[] | PaymentUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProposalInput | PaymentCreateOrConnectWithoutProposalInput[]
    createMany?: PaymentCreateManyProposalInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DateEventCreateNestedManyWithoutProposalInput = {
    create?: XOR<DateEventCreateWithoutProposalInput, DateEventUncheckedCreateWithoutProposalInput> | DateEventCreateWithoutProposalInput[] | DateEventUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: DateEventCreateOrConnectWithoutProposalInput | DateEventCreateOrConnectWithoutProposalInput[]
    createMany?: DateEventCreateManyProposalInputEnvelope
    connect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
  }

  export type ProposalCostCreateNestedManyWithoutProposalsInput = {
    create?: XOR<ProposalCostCreateWithoutProposalsInput, ProposalCostUncheckedCreateWithoutProposalsInput> | ProposalCostCreateWithoutProposalsInput[] | ProposalCostUncheckedCreateWithoutProposalsInput[]
    connectOrCreate?: ProposalCostCreateOrConnectWithoutProposalsInput | ProposalCostCreateOrConnectWithoutProposalsInput[]
    connect?: ProposalCostWhereUniqueInput | ProposalCostWhereUniqueInput[]
  }

  export type ProposalServiceCreateNestedManyWithoutProposalInput = {
    create?: XOR<ProposalServiceCreateWithoutProposalInput, ProposalServiceUncheckedCreateWithoutProposalInput> | ProposalServiceCreateWithoutProposalInput[] | ProposalServiceUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalServiceCreateOrConnectWithoutProposalInput | ProposalServiceCreateOrConnectWithoutProposalInput[]
    createMany?: ProposalServiceCreateManyProposalInputEnvelope
    connect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutProposalInput = {
    create?: XOR<NotificationCreateWithoutProposalInput, NotificationUncheckedCreateWithoutProposalInput> | NotificationCreateWithoutProposalInput[] | NotificationUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProposalInput | NotificationCreateOrConnectWithoutProposalInput[]
    createMany?: NotificationCreateManyProposalInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutProposalInput = {
    create?: XOR<ScheduleCreateWithoutProposalInput, ScheduleUncheckedCreateWithoutProposalInput> | ScheduleCreateWithoutProposalInput[] | ScheduleUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProposalInput | ScheduleCreateOrConnectWithoutProposalInput[]
    createMany?: ScheduleCreateManyProposalInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type PersonUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<PersonCreateWithoutProposalInput, PersonUncheckedCreateWithoutProposalInput> | PersonCreateWithoutProposalInput[] | PersonUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutProposalInput | PersonCreateOrConnectWithoutProposalInput[]
    createMany?: PersonCreateManyProposalInputEnvelope
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
  }

  export type HistoryUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<HistoryCreateWithoutProposalInput, HistoryUncheckedCreateWithoutProposalInput> | HistoryCreateWithoutProposalInput[] | HistoryUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutProposalInput | HistoryCreateOrConnectWithoutProposalInput[]
    createMany?: HistoryCreateManyProposalInputEnvelope
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<PaymentCreateWithoutProposalInput, PaymentUncheckedCreateWithoutProposalInput> | PaymentCreateWithoutProposalInput[] | PaymentUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProposalInput | PaymentCreateOrConnectWithoutProposalInput[]
    createMany?: PaymentCreateManyProposalInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DateEventUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<DateEventCreateWithoutProposalInput, DateEventUncheckedCreateWithoutProposalInput> | DateEventCreateWithoutProposalInput[] | DateEventUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: DateEventCreateOrConnectWithoutProposalInput | DateEventCreateOrConnectWithoutProposalInput[]
    createMany?: DateEventCreateManyProposalInputEnvelope
    connect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
  }

  export type ProposalCostUncheckedCreateNestedManyWithoutProposalsInput = {
    create?: XOR<ProposalCostCreateWithoutProposalsInput, ProposalCostUncheckedCreateWithoutProposalsInput> | ProposalCostCreateWithoutProposalsInput[] | ProposalCostUncheckedCreateWithoutProposalsInput[]
    connectOrCreate?: ProposalCostCreateOrConnectWithoutProposalsInput | ProposalCostCreateOrConnectWithoutProposalsInput[]
    connect?: ProposalCostWhereUniqueInput | ProposalCostWhereUniqueInput[]
  }

  export type ProposalServiceUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<ProposalServiceCreateWithoutProposalInput, ProposalServiceUncheckedCreateWithoutProposalInput> | ProposalServiceCreateWithoutProposalInput[] | ProposalServiceUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalServiceCreateOrConnectWithoutProposalInput | ProposalServiceCreateOrConnectWithoutProposalInput[]
    createMany?: ProposalServiceCreateManyProposalInputEnvelope
    connect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<NotificationCreateWithoutProposalInput, NotificationUncheckedCreateWithoutProposalInput> | NotificationCreateWithoutProposalInput[] | NotificationUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProposalInput | NotificationCreateOrConnectWithoutProposalInput[]
    createMany?: NotificationCreateManyProposalInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<ScheduleCreateWithoutProposalInput, ScheduleUncheckedCreateWithoutProposalInput> | ScheduleCreateWithoutProposalInput[] | ScheduleUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProposalInput | ScheduleCreateOrConnectWithoutProposalInput[]
    createMany?: ScheduleCreateManyProposalInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type EnumProposalTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProposalType
  }

  export type EnumTrafficSourceFieldUpdateOperationsInput = {
    set?: $Enums.TrafficSource
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VenueUpdateOneRequiredWithoutProposalsNestedInput = {
    create?: XOR<VenueCreateWithoutProposalsInput, VenueUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutProposalsInput
    upsert?: VenueUpsertWithoutProposalsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutProposalsInput, VenueUpdateWithoutProposalsInput>, VenueUncheckedUpdateWithoutProposalsInput>
  }

  export type PersonUpdateManyWithoutProposalNestedInput = {
    create?: XOR<PersonCreateWithoutProposalInput, PersonUncheckedCreateWithoutProposalInput> | PersonCreateWithoutProposalInput[] | PersonUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutProposalInput | PersonCreateOrConnectWithoutProposalInput[]
    upsert?: PersonUpsertWithWhereUniqueWithoutProposalInput | PersonUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: PersonCreateManyProposalInputEnvelope
    set?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    disconnect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    delete?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    update?: PersonUpdateWithWhereUniqueWithoutProposalInput | PersonUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: PersonUpdateManyWithWhereWithoutProposalInput | PersonUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: PersonScalarWhereInput | PersonScalarWhereInput[]
  }

  export type HistoryUpdateManyWithoutProposalNestedInput = {
    create?: XOR<HistoryCreateWithoutProposalInput, HistoryUncheckedCreateWithoutProposalInput> | HistoryCreateWithoutProposalInput[] | HistoryUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutProposalInput | HistoryCreateOrConnectWithoutProposalInput[]
    upsert?: HistoryUpsertWithWhereUniqueWithoutProposalInput | HistoryUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: HistoryCreateManyProposalInputEnvelope
    set?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    disconnect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    delete?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    update?: HistoryUpdateWithWhereUniqueWithoutProposalInput | HistoryUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: HistoryUpdateManyWithWhereWithoutProposalInput | HistoryUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: HistoryScalarWhereInput | HistoryScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutProposalNestedInput = {
    create?: XOR<PaymentCreateWithoutProposalInput, PaymentUncheckedCreateWithoutProposalInput> | PaymentCreateWithoutProposalInput[] | PaymentUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProposalInput | PaymentCreateOrConnectWithoutProposalInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutProposalInput | PaymentUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: PaymentCreateManyProposalInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutProposalInput | PaymentUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutProposalInput | PaymentUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DateEventUpdateManyWithoutProposalNestedInput = {
    create?: XOR<DateEventCreateWithoutProposalInput, DateEventUncheckedCreateWithoutProposalInput> | DateEventCreateWithoutProposalInput[] | DateEventUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: DateEventCreateOrConnectWithoutProposalInput | DateEventCreateOrConnectWithoutProposalInput[]
    upsert?: DateEventUpsertWithWhereUniqueWithoutProposalInput | DateEventUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: DateEventCreateManyProposalInputEnvelope
    set?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    disconnect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    delete?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    connect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    update?: DateEventUpdateWithWhereUniqueWithoutProposalInput | DateEventUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: DateEventUpdateManyWithWhereWithoutProposalInput | DateEventUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: DateEventScalarWhereInput | DateEventScalarWhereInput[]
  }

  export type ProposalCostUpdateManyWithoutProposalsNestedInput = {
    create?: XOR<ProposalCostCreateWithoutProposalsInput, ProposalCostUncheckedCreateWithoutProposalsInput> | ProposalCostCreateWithoutProposalsInput[] | ProposalCostUncheckedCreateWithoutProposalsInput[]
    connectOrCreate?: ProposalCostCreateOrConnectWithoutProposalsInput | ProposalCostCreateOrConnectWithoutProposalsInput[]
    upsert?: ProposalCostUpsertWithWhereUniqueWithoutProposalsInput | ProposalCostUpsertWithWhereUniqueWithoutProposalsInput[]
    set?: ProposalCostWhereUniqueInput | ProposalCostWhereUniqueInput[]
    disconnect?: ProposalCostWhereUniqueInput | ProposalCostWhereUniqueInput[]
    delete?: ProposalCostWhereUniqueInput | ProposalCostWhereUniqueInput[]
    connect?: ProposalCostWhereUniqueInput | ProposalCostWhereUniqueInput[]
    update?: ProposalCostUpdateWithWhereUniqueWithoutProposalsInput | ProposalCostUpdateWithWhereUniqueWithoutProposalsInput[]
    updateMany?: ProposalCostUpdateManyWithWhereWithoutProposalsInput | ProposalCostUpdateManyWithWhereWithoutProposalsInput[]
    deleteMany?: ProposalCostScalarWhereInput | ProposalCostScalarWhereInput[]
  }

  export type ProposalServiceUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ProposalServiceCreateWithoutProposalInput, ProposalServiceUncheckedCreateWithoutProposalInput> | ProposalServiceCreateWithoutProposalInput[] | ProposalServiceUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalServiceCreateOrConnectWithoutProposalInput | ProposalServiceCreateOrConnectWithoutProposalInput[]
    upsert?: ProposalServiceUpsertWithWhereUniqueWithoutProposalInput | ProposalServiceUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ProposalServiceCreateManyProposalInputEnvelope
    set?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    disconnect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    delete?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    connect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    update?: ProposalServiceUpdateWithWhereUniqueWithoutProposalInput | ProposalServiceUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ProposalServiceUpdateManyWithWhereWithoutProposalInput | ProposalServiceUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ProposalServiceScalarWhereInput | ProposalServiceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutProposalNestedInput = {
    create?: XOR<NotificationCreateWithoutProposalInput, NotificationUncheckedCreateWithoutProposalInput> | NotificationCreateWithoutProposalInput[] | NotificationUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProposalInput | NotificationCreateOrConnectWithoutProposalInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutProposalInput | NotificationUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: NotificationCreateManyProposalInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutProposalInput | NotificationUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutProposalInput | NotificationUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ScheduleCreateWithoutProposalInput, ScheduleUncheckedCreateWithoutProposalInput> | ScheduleCreateWithoutProposalInput[] | ScheduleUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProposalInput | ScheduleCreateOrConnectWithoutProposalInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutProposalInput | ScheduleUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ScheduleCreateManyProposalInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutProposalInput | ScheduleUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutProposalInput | ScheduleUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type PersonUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<PersonCreateWithoutProposalInput, PersonUncheckedCreateWithoutProposalInput> | PersonCreateWithoutProposalInput[] | PersonUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutProposalInput | PersonCreateOrConnectWithoutProposalInput[]
    upsert?: PersonUpsertWithWhereUniqueWithoutProposalInput | PersonUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: PersonCreateManyProposalInputEnvelope
    set?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    disconnect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    delete?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    update?: PersonUpdateWithWhereUniqueWithoutProposalInput | PersonUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: PersonUpdateManyWithWhereWithoutProposalInput | PersonUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: PersonScalarWhereInput | PersonScalarWhereInput[]
  }

  export type HistoryUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<HistoryCreateWithoutProposalInput, HistoryUncheckedCreateWithoutProposalInput> | HistoryCreateWithoutProposalInput[] | HistoryUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: HistoryCreateOrConnectWithoutProposalInput | HistoryCreateOrConnectWithoutProposalInput[]
    upsert?: HistoryUpsertWithWhereUniqueWithoutProposalInput | HistoryUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: HistoryCreateManyProposalInputEnvelope
    set?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    disconnect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    delete?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    connect?: HistoryWhereUniqueInput | HistoryWhereUniqueInput[]
    update?: HistoryUpdateWithWhereUniqueWithoutProposalInput | HistoryUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: HistoryUpdateManyWithWhereWithoutProposalInput | HistoryUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: HistoryScalarWhereInput | HistoryScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<PaymentCreateWithoutProposalInput, PaymentUncheckedCreateWithoutProposalInput> | PaymentCreateWithoutProposalInput[] | PaymentUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProposalInput | PaymentCreateOrConnectWithoutProposalInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutProposalInput | PaymentUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: PaymentCreateManyProposalInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutProposalInput | PaymentUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutProposalInput | PaymentUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DateEventUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<DateEventCreateWithoutProposalInput, DateEventUncheckedCreateWithoutProposalInput> | DateEventCreateWithoutProposalInput[] | DateEventUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: DateEventCreateOrConnectWithoutProposalInput | DateEventCreateOrConnectWithoutProposalInput[]
    upsert?: DateEventUpsertWithWhereUniqueWithoutProposalInput | DateEventUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: DateEventCreateManyProposalInputEnvelope
    set?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    disconnect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    delete?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    connect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    update?: DateEventUpdateWithWhereUniqueWithoutProposalInput | DateEventUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: DateEventUpdateManyWithWhereWithoutProposalInput | DateEventUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: DateEventScalarWhereInput | DateEventScalarWhereInput[]
  }

  export type ProposalCostUncheckedUpdateManyWithoutProposalsNestedInput = {
    create?: XOR<ProposalCostCreateWithoutProposalsInput, ProposalCostUncheckedCreateWithoutProposalsInput> | ProposalCostCreateWithoutProposalsInput[] | ProposalCostUncheckedCreateWithoutProposalsInput[]
    connectOrCreate?: ProposalCostCreateOrConnectWithoutProposalsInput | ProposalCostCreateOrConnectWithoutProposalsInput[]
    upsert?: ProposalCostUpsertWithWhereUniqueWithoutProposalsInput | ProposalCostUpsertWithWhereUniqueWithoutProposalsInput[]
    set?: ProposalCostWhereUniqueInput | ProposalCostWhereUniqueInput[]
    disconnect?: ProposalCostWhereUniqueInput | ProposalCostWhereUniqueInput[]
    delete?: ProposalCostWhereUniqueInput | ProposalCostWhereUniqueInput[]
    connect?: ProposalCostWhereUniqueInput | ProposalCostWhereUniqueInput[]
    update?: ProposalCostUpdateWithWhereUniqueWithoutProposalsInput | ProposalCostUpdateWithWhereUniqueWithoutProposalsInput[]
    updateMany?: ProposalCostUpdateManyWithWhereWithoutProposalsInput | ProposalCostUpdateManyWithWhereWithoutProposalsInput[]
    deleteMany?: ProposalCostScalarWhereInput | ProposalCostScalarWhereInput[]
  }

  export type ProposalServiceUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ProposalServiceCreateWithoutProposalInput, ProposalServiceUncheckedCreateWithoutProposalInput> | ProposalServiceCreateWithoutProposalInput[] | ProposalServiceUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalServiceCreateOrConnectWithoutProposalInput | ProposalServiceCreateOrConnectWithoutProposalInput[]
    upsert?: ProposalServiceUpsertWithWhereUniqueWithoutProposalInput | ProposalServiceUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ProposalServiceCreateManyProposalInputEnvelope
    set?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    disconnect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    delete?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    connect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    update?: ProposalServiceUpdateWithWhereUniqueWithoutProposalInput | ProposalServiceUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ProposalServiceUpdateManyWithWhereWithoutProposalInput | ProposalServiceUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ProposalServiceScalarWhereInput | ProposalServiceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<NotificationCreateWithoutProposalInput, NotificationUncheckedCreateWithoutProposalInput> | NotificationCreateWithoutProposalInput[] | NotificationUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProposalInput | NotificationCreateOrConnectWithoutProposalInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutProposalInput | NotificationUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: NotificationCreateManyProposalInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutProposalInput | NotificationUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutProposalInput | NotificationUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ScheduleCreateWithoutProposalInput, ScheduleUncheckedCreateWithoutProposalInput> | ScheduleCreateWithoutProposalInput[] | ScheduleUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProposalInput | ScheduleCreateOrConnectWithoutProposalInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutProposalInput | ScheduleUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ScheduleCreateManyProposalInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutProposalInput | ScheduleUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutProposalInput | ScheduleUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHistoriesInput = {
    create?: XOR<UserCreateWithoutHistoriesInput, UserUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoriesInput
    connect?: UserWhereUniqueInput
  }

  export type ProposalCreateNestedOneWithoutHistoriesInput = {
    create?: XOR<ProposalCreateWithoutHistoriesInput, ProposalUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutHistoriesInput
    connect?: ProposalWhereUniqueInput
  }

  export type UserUpdateOneWithoutHistoriesNestedInput = {
    create?: XOR<UserCreateWithoutHistoriesInput, UserUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoriesInput
    upsert?: UserUpsertWithoutHistoriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHistoriesInput, UserUpdateWithoutHistoriesInput>, UserUncheckedUpdateWithoutHistoriesInput>
  }

  export type ProposalUpdateOneRequiredWithoutHistoriesNestedInput = {
    create?: XOR<ProposalCreateWithoutHistoriesInput, ProposalUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutHistoriesInput
    upsert?: ProposalUpsertWithoutHistoriesInput
    connect?: ProposalWhereUniqueInput
    update?: XOR<XOR<ProposalUpdateToOneWithWhereWithoutHistoriesInput, ProposalUpdateWithoutHistoriesInput>, ProposalUncheckedUpdateWithoutHistoriesInput>
  }

  export type ProposalCreateNestedOneWithoutPersonListInput = {
    create?: XOR<ProposalCreateWithoutPersonListInput, ProposalUncheckedCreateWithoutPersonListInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutPersonListInput
    connect?: ProposalWhereUniqueInput
  }

  export type EnumPersonTypeFieldUpdateOperationsInput = {
    set?: $Enums.PersonType
  }

  export type ProposalUpdateOneRequiredWithoutPersonListNestedInput = {
    create?: XOR<ProposalCreateWithoutPersonListInput, ProposalUncheckedCreateWithoutPersonListInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutPersonListInput
    upsert?: ProposalUpsertWithoutPersonListInput
    connect?: ProposalWhereUniqueInput
    update?: XOR<XOR<ProposalUpdateToOneWithWhereWithoutPersonListInput, ProposalUpdateWithoutPersonListInput>, ProposalUncheckedUpdateWithoutPersonListInput>
  }

  export type ServiceCreateNestedOneWithoutProposalServicesInput = {
    create?: XOR<ServiceCreateWithoutProposalServicesInput, ServiceUncheckedCreateWithoutProposalServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProposalServicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type ProposalCreateNestedOneWithoutProposalServicesInput = {
    create?: XOR<ProposalCreateWithoutProposalServicesInput, ProposalUncheckedCreateWithoutProposalServicesInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutProposalServicesInput
    connect?: ProposalWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutProposalServicesNestedInput = {
    create?: XOR<ServiceCreateWithoutProposalServicesInput, ServiceUncheckedCreateWithoutProposalServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProposalServicesInput
    upsert?: ServiceUpsertWithoutProposalServicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutProposalServicesInput, ServiceUpdateWithoutProposalServicesInput>, ServiceUncheckedUpdateWithoutProposalServicesInput>
  }

  export type ProposalUpdateOneRequiredWithoutProposalServicesNestedInput = {
    create?: XOR<ProposalCreateWithoutProposalServicesInput, ProposalUncheckedCreateWithoutProposalServicesInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutProposalServicesInput
    upsert?: ProposalUpsertWithoutProposalServicesInput
    connect?: ProposalWhereUniqueInput
    update?: XOR<XOR<ProposalUpdateToOneWithWhereWithoutProposalServicesInput, ProposalUpdateWithoutProposalServicesInput>, ProposalUncheckedUpdateWithoutProposalServicesInput>
  }

  export type ProposalServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<ProposalServiceCreateWithoutServiceInput, ProposalServiceUncheckedCreateWithoutServiceInput> | ProposalServiceCreateWithoutServiceInput[] | ProposalServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProposalServiceCreateOrConnectWithoutServiceInput | ProposalServiceCreateOrConnectWithoutServiceInput[]
    createMany?: ProposalServiceCreateManyServiceInputEnvelope
    connect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
  }

  export type VenueCreateNestedOneWithoutServicesInput = {
    create?: XOR<VenueCreateWithoutServicesInput, VenueUncheckedCreateWithoutServicesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutServicesInput
    connect?: VenueWhereUniqueInput
  }

  export type ProposalServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ProposalServiceCreateWithoutServiceInput, ProposalServiceUncheckedCreateWithoutServiceInput> | ProposalServiceCreateWithoutServiceInput[] | ProposalServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProposalServiceCreateOrConnectWithoutServiceInput | ProposalServiceCreateOrConnectWithoutServiceInput[]
    createMany?: ProposalServiceCreateManyServiceInputEnvelope
    connect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
  }

  export type ProposalServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ProposalServiceCreateWithoutServiceInput, ProposalServiceUncheckedCreateWithoutServiceInput> | ProposalServiceCreateWithoutServiceInput[] | ProposalServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProposalServiceCreateOrConnectWithoutServiceInput | ProposalServiceCreateOrConnectWithoutServiceInput[]
    upsert?: ProposalServiceUpsertWithWhereUniqueWithoutServiceInput | ProposalServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ProposalServiceCreateManyServiceInputEnvelope
    set?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    disconnect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    delete?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    connect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    update?: ProposalServiceUpdateWithWhereUniqueWithoutServiceInput | ProposalServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ProposalServiceUpdateManyWithWhereWithoutServiceInput | ProposalServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ProposalServiceScalarWhereInput | ProposalServiceScalarWhereInput[]
  }

  export type VenueUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<VenueCreateWithoutServicesInput, VenueUncheckedCreateWithoutServicesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutServicesInput
    upsert?: VenueUpsertWithoutServicesInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutServicesInput, VenueUpdateWithoutServicesInput>, VenueUncheckedUpdateWithoutServicesInput>
  }

  export type ProposalServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ProposalServiceCreateWithoutServiceInput, ProposalServiceUncheckedCreateWithoutServiceInput> | ProposalServiceCreateWithoutServiceInput[] | ProposalServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProposalServiceCreateOrConnectWithoutServiceInput | ProposalServiceCreateOrConnectWithoutServiceInput[]
    upsert?: ProposalServiceUpsertWithWhereUniqueWithoutServiceInput | ProposalServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ProposalServiceCreateManyServiceInputEnvelope
    set?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    disconnect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    delete?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    connect?: ProposalServiceWhereUniqueInput | ProposalServiceWhereUniqueInput[]
    update?: ProposalServiceUpdateWithWhereUniqueWithoutServiceInput | ProposalServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ProposalServiceUpdateManyWithWhereWithoutServiceInput | ProposalServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ProposalServiceScalarWhereInput | ProposalServiceScalarWhereInput[]
  }

  export type ProposalCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ProposalCreateWithoutPaymentsInput, ProposalUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutPaymentsInput
    connect?: ProposalWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutPaymentInput = {
    create?: XOR<VenueCreateWithoutPaymentInput, VenueUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: VenueCreateOrConnectWithoutPaymentInput
    connect?: VenueWhereUniqueInput
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type ProposalUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ProposalCreateWithoutPaymentsInput, ProposalUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutPaymentsInput
    upsert?: ProposalUpsertWithoutPaymentsInput
    connect?: ProposalWhereUniqueInput
    update?: XOR<XOR<ProposalUpdateToOneWithWhereWithoutPaymentsInput, ProposalUpdateWithoutPaymentsInput>, ProposalUncheckedUpdateWithoutPaymentsInput>
  }

  export type VenueUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<VenueCreateWithoutPaymentInput, VenueUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: VenueCreateOrConnectWithoutPaymentInput
    upsert?: VenueUpsertWithoutPaymentInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutPaymentInput, VenueUpdateWithoutPaymentInput>, VenueUncheckedUpdateWithoutPaymentInput>
  }

  export type ProposalCreateNestedManyWithoutProposalCostsInput = {
    create?: XOR<ProposalCreateWithoutProposalCostsInput, ProposalUncheckedCreateWithoutProposalCostsInput> | ProposalCreateWithoutProposalCostsInput[] | ProposalUncheckedCreateWithoutProposalCostsInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutProposalCostsInput | ProposalCreateOrConnectWithoutProposalCostsInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutProposalCostsInput = {
    create?: XOR<ProposalCreateWithoutProposalCostsInput, ProposalUncheckedCreateWithoutProposalCostsInput> | ProposalCreateWithoutProposalCostsInput[] | ProposalUncheckedCreateWithoutProposalCostsInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutProposalCostsInput | ProposalCreateOrConnectWithoutProposalCostsInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type EnumProposalNameFieldUpdateOperationsInput = {
    set?: $Enums.ProposalName
  }

  export type ProposalUpdateManyWithoutProposalCostsNestedInput = {
    create?: XOR<ProposalCreateWithoutProposalCostsInput, ProposalUncheckedCreateWithoutProposalCostsInput> | ProposalCreateWithoutProposalCostsInput[] | ProposalUncheckedCreateWithoutProposalCostsInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutProposalCostsInput | ProposalCreateOrConnectWithoutProposalCostsInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutProposalCostsInput | ProposalUpsertWithWhereUniqueWithoutProposalCostsInput[]
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutProposalCostsInput | ProposalUpdateWithWhereUniqueWithoutProposalCostsInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutProposalCostsInput | ProposalUpdateManyWithWhereWithoutProposalCostsInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutProposalCostsNestedInput = {
    create?: XOR<ProposalCreateWithoutProposalCostsInput, ProposalUncheckedCreateWithoutProposalCostsInput> | ProposalCreateWithoutProposalCostsInput[] | ProposalUncheckedCreateWithoutProposalCostsInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutProposalCostsInput | ProposalCreateOrConnectWithoutProposalCostsInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutProposalCostsInput | ProposalUpsertWithWhereUniqueWithoutProposalCostsInput[]
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutProposalCostsInput | ProposalUpdateWithWhereUniqueWithoutProposalCostsInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutProposalCostsInput | ProposalUpdateManyWithWhereWithoutProposalCostsInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type VenueCreateNestedOneWithoutExpensesInput = {
    create?: XOR<VenueCreateWithoutExpensesInput, VenueUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutExpensesInput
    connect?: VenueWhereUniqueInput
  }

  export type EnumExpenseTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseType
  }

  export type EnumExpenseCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseCategory
  }

  export type VenueUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<VenueCreateWithoutExpensesInput, VenueUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutExpensesInput
    upsert?: VenueUpsertWithoutExpensesInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutExpensesInput, VenueUpdateWithoutExpensesInput>, VenueUncheckedUpdateWithoutExpensesInput>
  }

  export type VenueCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<VenueCreateWithoutNotificationsInput, VenueUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutNotificationsInput
    connect?: VenueWhereUniqueInput
  }

  export type ProposalCreateNestedOneWithoutNoificationListInput = {
    create?: XOR<ProposalCreateWithoutNoificationListInput, ProposalUncheckedCreateWithoutNoificationListInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutNoificationListInput
    connect?: ProposalWhereUniqueInput
  }

  export type DateEventCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<DateEventCreateWithoutNotificationsInput, DateEventUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: DateEventCreateOrConnectWithoutNotificationsInput
    connect?: DateEventWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type VenueUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<VenueCreateWithoutNotificationsInput, VenueUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutNotificationsInput
    upsert?: VenueUpsertWithoutNotificationsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutNotificationsInput, VenueUpdateWithoutNotificationsInput>, VenueUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProposalUpdateOneWithoutNoificationListNestedInput = {
    create?: XOR<ProposalCreateWithoutNoificationListInput, ProposalUncheckedCreateWithoutNoificationListInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutNoificationListInput
    upsert?: ProposalUpsertWithoutNoificationListInput
    disconnect?: ProposalWhereInput | boolean
    delete?: ProposalWhereInput | boolean
    connect?: ProposalWhereUniqueInput
    update?: XOR<XOR<ProposalUpdateToOneWithWhereWithoutNoificationListInput, ProposalUpdateWithoutNoificationListInput>, ProposalUncheckedUpdateWithoutNoificationListInput>
  }

  export type DateEventUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<DateEventCreateWithoutNotificationsInput, DateEventUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: DateEventCreateOrConnectWithoutNotificationsInput
    upsert?: DateEventUpsertWithoutNotificationsInput
    disconnect?: DateEventWhereInput | boolean
    delete?: DateEventWhereInput | boolean
    connect?: DateEventWhereUniqueInput
    update?: XOR<XOR<DateEventUpdateToOneWithWhereWithoutNotificationsInput, DateEventUpdateWithoutNotificationsInput>, DateEventUncheckedUpdateWithoutNotificationsInput>
  }

  export type VenueCreateNestedOneWithoutDateEventInput = {
    create?: XOR<VenueCreateWithoutDateEventInput, VenueUncheckedCreateWithoutDateEventInput>
    connectOrCreate?: VenueCreateOrConnectWithoutDateEventInput
    connect?: VenueWhereUniqueInput
  }

  export type ProposalCreateNestedOneWithoutDateEventsInput = {
    create?: XOR<ProposalCreateWithoutDateEventsInput, ProposalUncheckedCreateWithoutDateEventsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutDateEventsInput
    connect?: ProposalWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutDateEventInput = {
    create?: XOR<NotificationCreateWithoutDateEventInput, NotificationUncheckedCreateWithoutDateEventInput> | NotificationCreateWithoutDateEventInput[] | NotificationUncheckedCreateWithoutDateEventInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDateEventInput | NotificationCreateOrConnectWithoutDateEventInput[]
    createMany?: NotificationCreateManyDateEventInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutDateEventInput = {
    create?: XOR<NotificationCreateWithoutDateEventInput, NotificationUncheckedCreateWithoutDateEventInput> | NotificationCreateWithoutDateEventInput[] | NotificationUncheckedCreateWithoutDateEventInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDateEventInput | NotificationCreateOrConnectWithoutDateEventInput[]
    createMany?: NotificationCreateManyDateEventInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumDateEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.DateEventType
  }

  export type VenueUpdateOneRequiredWithoutDateEventNestedInput = {
    create?: XOR<VenueCreateWithoutDateEventInput, VenueUncheckedCreateWithoutDateEventInput>
    connectOrCreate?: VenueCreateOrConnectWithoutDateEventInput
    upsert?: VenueUpsertWithoutDateEventInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutDateEventInput, VenueUpdateWithoutDateEventInput>, VenueUncheckedUpdateWithoutDateEventInput>
  }

  export type ProposalUpdateOneWithoutDateEventsNestedInput = {
    create?: XOR<ProposalCreateWithoutDateEventsInput, ProposalUncheckedCreateWithoutDateEventsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutDateEventsInput
    upsert?: ProposalUpsertWithoutDateEventsInput
    disconnect?: ProposalWhereInput | boolean
    delete?: ProposalWhereInput | boolean
    connect?: ProposalWhereUniqueInput
    update?: XOR<XOR<ProposalUpdateToOneWithWhereWithoutDateEventsInput, ProposalUpdateWithoutDateEventsInput>, ProposalUncheckedUpdateWithoutDateEventsInput>
  }

  export type NotificationUpdateManyWithoutDateEventNestedInput = {
    create?: XOR<NotificationCreateWithoutDateEventInput, NotificationUncheckedCreateWithoutDateEventInput> | NotificationCreateWithoutDateEventInput[] | NotificationUncheckedCreateWithoutDateEventInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDateEventInput | NotificationCreateOrConnectWithoutDateEventInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDateEventInput | NotificationUpsertWithWhereUniqueWithoutDateEventInput[]
    createMany?: NotificationCreateManyDateEventInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDateEventInput | NotificationUpdateWithWhereUniqueWithoutDateEventInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDateEventInput | NotificationUpdateManyWithWhereWithoutDateEventInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutDateEventNestedInput = {
    create?: XOR<NotificationCreateWithoutDateEventInput, NotificationUncheckedCreateWithoutDateEventInput> | NotificationCreateWithoutDateEventInput[] | NotificationUncheckedCreateWithoutDateEventInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDateEventInput | NotificationCreateOrConnectWithoutDateEventInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDateEventInput | NotificationUpsertWithWhereUniqueWithoutDateEventInput[]
    createMany?: NotificationCreateManyDateEventInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDateEventInput | NotificationUpdateWithWhereUniqueWithoutDateEventInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDateEventInput | NotificationUpdateManyWithWhereWithoutDateEventInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutVenuesInput = {
    create?: XOR<OrganizationCreateWithoutVenuesInput, OrganizationUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutVenuesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TextCreateNestedManyWithoutVenueInput = {
    create?: XOR<TextCreateWithoutVenueInput, TextUncheckedCreateWithoutVenueInput> | TextCreateWithoutVenueInput[] | TextUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TextCreateOrConnectWithoutVenueInput | TextCreateOrConnectWithoutVenueInput[]
    createMany?: TextCreateManyVenueInputEnvelope
    connect?: TextWhereUniqueInput | TextWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutVenueInput = {
    create?: XOR<ContactCreateWithoutVenueInput, ContactUncheckedCreateWithoutVenueInput> | ContactCreateWithoutVenueInput[] | ContactUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutVenueInput | ContactCreateOrConnectWithoutVenueInput[]
    createMany?: ContactCreateManyVenueInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ImageCreateNestedManyWithoutVenueInput = {
    create?: XOR<ImageCreateWithoutVenueInput, ImageUncheckedCreateWithoutVenueInput> | ImageCreateWithoutVenueInput[] | ImageUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutVenueInput | ImageCreateOrConnectWithoutVenueInput[]
    createMany?: ImageCreateManyVenueInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutVenueInput = {
    create?: XOR<ExpenseCreateWithoutVenueInput, ExpenseUncheckedCreateWithoutVenueInput> | ExpenseCreateWithoutVenueInput[] | ExpenseUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutVenueInput | ExpenseCreateOrConnectWithoutVenueInput[]
    createMany?: ExpenseCreateManyVenueInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutVenueInput = {
    create?: XOR<ServiceCreateWithoutVenueInput, ServiceUncheckedCreateWithoutVenueInput> | ServiceCreateWithoutVenueInput[] | ServiceUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutVenueInput | ServiceCreateOrConnectWithoutVenueInput[]
    createMany?: ServiceCreateManyVenueInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutVenueInput = {
    create?: XOR<PaymentCreateWithoutVenueInput, PaymentUncheckedCreateWithoutVenueInput> | PaymentCreateWithoutVenueInput[] | PaymentUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVenueInput | PaymentCreateOrConnectWithoutVenueInput[]
    createMany?: PaymentCreateManyVenueInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type QuestionCreateNestedManyWithoutVenueInput = {
    create?: XOR<QuestionCreateWithoutVenueInput, QuestionUncheckedCreateWithoutVenueInput> | QuestionCreateWithoutVenueInput[] | QuestionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutVenueInput | QuestionCreateOrConnectWithoutVenueInput[]
    createMany?: QuestionCreateManyVenueInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ProposalCreateNestedManyWithoutVenueInput = {
    create?: XOR<ProposalCreateWithoutVenueInput, ProposalUncheckedCreateWithoutVenueInput> | ProposalCreateWithoutVenueInput[] | ProposalUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutVenueInput | ProposalCreateOrConnectWithoutVenueInput[]
    createMany?: ProposalCreateManyVenueInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type DateEventCreateNestedManyWithoutVenueInput = {
    create?: XOR<DateEventCreateWithoutVenueInput, DateEventUncheckedCreateWithoutVenueInput> | DateEventCreateWithoutVenueInput[] | DateEventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: DateEventCreateOrConnectWithoutVenueInput | DateEventCreateOrConnectWithoutVenueInput[]
    createMany?: DateEventCreateManyVenueInputEnvelope
    connect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
  }

  export type OwnerVenueCreateNestedManyWithoutVenueInput = {
    create?: XOR<OwnerVenueCreateWithoutVenueInput, OwnerVenueUncheckedCreateWithoutVenueInput> | OwnerVenueCreateWithoutVenueInput[] | OwnerVenueUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: OwnerVenueCreateOrConnectWithoutVenueInput | OwnerVenueCreateOrConnectWithoutVenueInput[]
    createMany?: OwnerVenueCreateManyVenueInputEnvelope
    connect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutVenueInput = {
    create?: XOR<NotificationCreateWithoutVenueInput, NotificationUncheckedCreateWithoutVenueInput> | NotificationCreateWithoutVenueInput[] | NotificationUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVenueInput | NotificationCreateOrConnectWithoutVenueInput[]
    createMany?: NotificationCreateManyVenueInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TextUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<TextCreateWithoutVenueInput, TextUncheckedCreateWithoutVenueInput> | TextCreateWithoutVenueInput[] | TextUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TextCreateOrConnectWithoutVenueInput | TextCreateOrConnectWithoutVenueInput[]
    createMany?: TextCreateManyVenueInputEnvelope
    connect?: TextWhereUniqueInput | TextWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ContactCreateWithoutVenueInput, ContactUncheckedCreateWithoutVenueInput> | ContactCreateWithoutVenueInput[] | ContactUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutVenueInput | ContactCreateOrConnectWithoutVenueInput[]
    createMany?: ContactCreateManyVenueInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ImageCreateWithoutVenueInput, ImageUncheckedCreateWithoutVenueInput> | ImageCreateWithoutVenueInput[] | ImageUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutVenueInput | ImageCreateOrConnectWithoutVenueInput[]
    createMany?: ImageCreateManyVenueInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ExpenseCreateWithoutVenueInput, ExpenseUncheckedCreateWithoutVenueInput> | ExpenseCreateWithoutVenueInput[] | ExpenseUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutVenueInput | ExpenseCreateOrConnectWithoutVenueInput[]
    createMany?: ExpenseCreateManyVenueInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ServiceCreateWithoutVenueInput, ServiceUncheckedCreateWithoutVenueInput> | ServiceCreateWithoutVenueInput[] | ServiceUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutVenueInput | ServiceCreateOrConnectWithoutVenueInput[]
    createMany?: ServiceCreateManyVenueInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<PaymentCreateWithoutVenueInput, PaymentUncheckedCreateWithoutVenueInput> | PaymentCreateWithoutVenueInput[] | PaymentUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVenueInput | PaymentCreateOrConnectWithoutVenueInput[]
    createMany?: PaymentCreateManyVenueInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<QuestionCreateWithoutVenueInput, QuestionUncheckedCreateWithoutVenueInput> | QuestionCreateWithoutVenueInput[] | QuestionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutVenueInput | QuestionCreateOrConnectWithoutVenueInput[]
    createMany?: QuestionCreateManyVenueInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ProposalCreateWithoutVenueInput, ProposalUncheckedCreateWithoutVenueInput> | ProposalCreateWithoutVenueInput[] | ProposalUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutVenueInput | ProposalCreateOrConnectWithoutVenueInput[]
    createMany?: ProposalCreateManyVenueInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type DateEventUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<DateEventCreateWithoutVenueInput, DateEventUncheckedCreateWithoutVenueInput> | DateEventCreateWithoutVenueInput[] | DateEventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: DateEventCreateOrConnectWithoutVenueInput | DateEventCreateOrConnectWithoutVenueInput[]
    createMany?: DateEventCreateManyVenueInputEnvelope
    connect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
  }

  export type OwnerVenueUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<OwnerVenueCreateWithoutVenueInput, OwnerVenueUncheckedCreateWithoutVenueInput> | OwnerVenueCreateWithoutVenueInput[] | OwnerVenueUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: OwnerVenueCreateOrConnectWithoutVenueInput | OwnerVenueCreateOrConnectWithoutVenueInput[]
    createMany?: OwnerVenueCreateManyVenueInputEnvelope
    connect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<NotificationCreateWithoutVenueInput, NotificationUncheckedCreateWithoutVenueInput> | NotificationCreateWithoutVenueInput[] | NotificationUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVenueInput | NotificationCreateOrConnectWithoutVenueInput[]
    createMany?: NotificationCreateManyVenueInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumPricingModelFieldUpdateOperationsInput = {
    set?: $Enums.PricingModel
  }

  export type OrganizationUpdateOneRequiredWithoutVenuesNestedInput = {
    create?: XOR<OrganizationCreateWithoutVenuesInput, OrganizationUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutVenuesInput
    upsert?: OrganizationUpsertWithoutVenuesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutVenuesInput, OrganizationUpdateWithoutVenuesInput>, OrganizationUncheckedUpdateWithoutVenuesInput>
  }

  export type TextUpdateManyWithoutVenueNestedInput = {
    create?: XOR<TextCreateWithoutVenueInput, TextUncheckedCreateWithoutVenueInput> | TextCreateWithoutVenueInput[] | TextUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TextCreateOrConnectWithoutVenueInput | TextCreateOrConnectWithoutVenueInput[]
    upsert?: TextUpsertWithWhereUniqueWithoutVenueInput | TextUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: TextCreateManyVenueInputEnvelope
    set?: TextWhereUniqueInput | TextWhereUniqueInput[]
    disconnect?: TextWhereUniqueInput | TextWhereUniqueInput[]
    delete?: TextWhereUniqueInput | TextWhereUniqueInput[]
    connect?: TextWhereUniqueInput | TextWhereUniqueInput[]
    update?: TextUpdateWithWhereUniqueWithoutVenueInput | TextUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: TextUpdateManyWithWhereWithoutVenueInput | TextUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: TextScalarWhereInput | TextScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ContactCreateWithoutVenueInput, ContactUncheckedCreateWithoutVenueInput> | ContactCreateWithoutVenueInput[] | ContactUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutVenueInput | ContactCreateOrConnectWithoutVenueInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutVenueInput | ContactUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ContactCreateManyVenueInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutVenueInput | ContactUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutVenueInput | ContactUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ImageUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ImageCreateWithoutVenueInput, ImageUncheckedCreateWithoutVenueInput> | ImageCreateWithoutVenueInput[] | ImageUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutVenueInput | ImageCreateOrConnectWithoutVenueInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutVenueInput | ImageUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ImageCreateManyVenueInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutVenueInput | ImageUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutVenueInput | ImageUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ExpenseCreateWithoutVenueInput, ExpenseUncheckedCreateWithoutVenueInput> | ExpenseCreateWithoutVenueInput[] | ExpenseUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutVenueInput | ExpenseCreateOrConnectWithoutVenueInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutVenueInput | ExpenseUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ExpenseCreateManyVenueInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutVenueInput | ExpenseUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutVenueInput | ExpenseUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ServiceCreateWithoutVenueInput, ServiceUncheckedCreateWithoutVenueInput> | ServiceCreateWithoutVenueInput[] | ServiceUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutVenueInput | ServiceCreateOrConnectWithoutVenueInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutVenueInput | ServiceUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ServiceCreateManyVenueInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutVenueInput | ServiceUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutVenueInput | ServiceUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutVenueNestedInput = {
    create?: XOR<PaymentCreateWithoutVenueInput, PaymentUncheckedCreateWithoutVenueInput> | PaymentCreateWithoutVenueInput[] | PaymentUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVenueInput | PaymentCreateOrConnectWithoutVenueInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutVenueInput | PaymentUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: PaymentCreateManyVenueInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutVenueInput | PaymentUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutVenueInput | PaymentUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type QuestionUpdateManyWithoutVenueNestedInput = {
    create?: XOR<QuestionCreateWithoutVenueInput, QuestionUncheckedCreateWithoutVenueInput> | QuestionCreateWithoutVenueInput[] | QuestionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutVenueInput | QuestionCreateOrConnectWithoutVenueInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutVenueInput | QuestionUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: QuestionCreateManyVenueInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutVenueInput | QuestionUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutVenueInput | QuestionUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ProposalUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ProposalCreateWithoutVenueInput, ProposalUncheckedCreateWithoutVenueInput> | ProposalCreateWithoutVenueInput[] | ProposalUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutVenueInput | ProposalCreateOrConnectWithoutVenueInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutVenueInput | ProposalUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ProposalCreateManyVenueInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutVenueInput | ProposalUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutVenueInput | ProposalUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type DateEventUpdateManyWithoutVenueNestedInput = {
    create?: XOR<DateEventCreateWithoutVenueInput, DateEventUncheckedCreateWithoutVenueInput> | DateEventCreateWithoutVenueInput[] | DateEventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: DateEventCreateOrConnectWithoutVenueInput | DateEventCreateOrConnectWithoutVenueInput[]
    upsert?: DateEventUpsertWithWhereUniqueWithoutVenueInput | DateEventUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: DateEventCreateManyVenueInputEnvelope
    set?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    disconnect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    delete?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    connect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    update?: DateEventUpdateWithWhereUniqueWithoutVenueInput | DateEventUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: DateEventUpdateManyWithWhereWithoutVenueInput | DateEventUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: DateEventScalarWhereInput | DateEventScalarWhereInput[]
  }

  export type OwnerVenueUpdateManyWithoutVenueNestedInput = {
    create?: XOR<OwnerVenueCreateWithoutVenueInput, OwnerVenueUncheckedCreateWithoutVenueInput> | OwnerVenueCreateWithoutVenueInput[] | OwnerVenueUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: OwnerVenueCreateOrConnectWithoutVenueInput | OwnerVenueCreateOrConnectWithoutVenueInput[]
    upsert?: OwnerVenueUpsertWithWhereUniqueWithoutVenueInput | OwnerVenueUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: OwnerVenueCreateManyVenueInputEnvelope
    set?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    disconnect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    delete?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    connect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    update?: OwnerVenueUpdateWithWhereUniqueWithoutVenueInput | OwnerVenueUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: OwnerVenueUpdateManyWithWhereWithoutVenueInput | OwnerVenueUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: OwnerVenueScalarWhereInput | OwnerVenueScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutVenueNestedInput = {
    create?: XOR<NotificationCreateWithoutVenueInput, NotificationUncheckedCreateWithoutVenueInput> | NotificationCreateWithoutVenueInput[] | NotificationUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVenueInput | NotificationCreateOrConnectWithoutVenueInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutVenueInput | NotificationUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: NotificationCreateManyVenueInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutVenueInput | NotificationUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutVenueInput | NotificationUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TextUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<TextCreateWithoutVenueInput, TextUncheckedCreateWithoutVenueInput> | TextCreateWithoutVenueInput[] | TextUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TextCreateOrConnectWithoutVenueInput | TextCreateOrConnectWithoutVenueInput[]
    upsert?: TextUpsertWithWhereUniqueWithoutVenueInput | TextUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: TextCreateManyVenueInputEnvelope
    set?: TextWhereUniqueInput | TextWhereUniqueInput[]
    disconnect?: TextWhereUniqueInput | TextWhereUniqueInput[]
    delete?: TextWhereUniqueInput | TextWhereUniqueInput[]
    connect?: TextWhereUniqueInput | TextWhereUniqueInput[]
    update?: TextUpdateWithWhereUniqueWithoutVenueInput | TextUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: TextUpdateManyWithWhereWithoutVenueInput | TextUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: TextScalarWhereInput | TextScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ContactCreateWithoutVenueInput, ContactUncheckedCreateWithoutVenueInput> | ContactCreateWithoutVenueInput[] | ContactUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutVenueInput | ContactCreateOrConnectWithoutVenueInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutVenueInput | ContactUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ContactCreateManyVenueInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutVenueInput | ContactUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutVenueInput | ContactUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ImageCreateWithoutVenueInput, ImageUncheckedCreateWithoutVenueInput> | ImageCreateWithoutVenueInput[] | ImageUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutVenueInput | ImageCreateOrConnectWithoutVenueInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutVenueInput | ImageUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ImageCreateManyVenueInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutVenueInput | ImageUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutVenueInput | ImageUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ExpenseCreateWithoutVenueInput, ExpenseUncheckedCreateWithoutVenueInput> | ExpenseCreateWithoutVenueInput[] | ExpenseUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutVenueInput | ExpenseCreateOrConnectWithoutVenueInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutVenueInput | ExpenseUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ExpenseCreateManyVenueInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutVenueInput | ExpenseUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutVenueInput | ExpenseUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ServiceCreateWithoutVenueInput, ServiceUncheckedCreateWithoutVenueInput> | ServiceCreateWithoutVenueInput[] | ServiceUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutVenueInput | ServiceCreateOrConnectWithoutVenueInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutVenueInput | ServiceUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ServiceCreateManyVenueInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutVenueInput | ServiceUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutVenueInput | ServiceUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<PaymentCreateWithoutVenueInput, PaymentUncheckedCreateWithoutVenueInput> | PaymentCreateWithoutVenueInput[] | PaymentUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVenueInput | PaymentCreateOrConnectWithoutVenueInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutVenueInput | PaymentUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: PaymentCreateManyVenueInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutVenueInput | PaymentUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutVenueInput | PaymentUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<QuestionCreateWithoutVenueInput, QuestionUncheckedCreateWithoutVenueInput> | QuestionCreateWithoutVenueInput[] | QuestionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutVenueInput | QuestionCreateOrConnectWithoutVenueInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutVenueInput | QuestionUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: QuestionCreateManyVenueInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutVenueInput | QuestionUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutVenueInput | QuestionUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ProposalCreateWithoutVenueInput, ProposalUncheckedCreateWithoutVenueInput> | ProposalCreateWithoutVenueInput[] | ProposalUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutVenueInput | ProposalCreateOrConnectWithoutVenueInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutVenueInput | ProposalUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ProposalCreateManyVenueInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutVenueInput | ProposalUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutVenueInput | ProposalUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type DateEventUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<DateEventCreateWithoutVenueInput, DateEventUncheckedCreateWithoutVenueInput> | DateEventCreateWithoutVenueInput[] | DateEventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: DateEventCreateOrConnectWithoutVenueInput | DateEventCreateOrConnectWithoutVenueInput[]
    upsert?: DateEventUpsertWithWhereUniqueWithoutVenueInput | DateEventUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: DateEventCreateManyVenueInputEnvelope
    set?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    disconnect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    delete?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    connect?: DateEventWhereUniqueInput | DateEventWhereUniqueInput[]
    update?: DateEventUpdateWithWhereUniqueWithoutVenueInput | DateEventUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: DateEventUpdateManyWithWhereWithoutVenueInput | DateEventUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: DateEventScalarWhereInput | DateEventScalarWhereInput[]
  }

  export type OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<OwnerVenueCreateWithoutVenueInput, OwnerVenueUncheckedCreateWithoutVenueInput> | OwnerVenueCreateWithoutVenueInput[] | OwnerVenueUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: OwnerVenueCreateOrConnectWithoutVenueInput | OwnerVenueCreateOrConnectWithoutVenueInput[]
    upsert?: OwnerVenueUpsertWithWhereUniqueWithoutVenueInput | OwnerVenueUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: OwnerVenueCreateManyVenueInputEnvelope
    set?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    disconnect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    delete?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    connect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    update?: OwnerVenueUpdateWithWhereUniqueWithoutVenueInput | OwnerVenueUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: OwnerVenueUpdateManyWithWhereWithoutVenueInput | OwnerVenueUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: OwnerVenueScalarWhereInput | OwnerVenueScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<NotificationCreateWithoutVenueInput, NotificationUncheckedCreateWithoutVenueInput> | NotificationCreateWithoutVenueInput[] | NotificationUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVenueInput | NotificationCreateOrConnectWithoutVenueInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutVenueInput | NotificationUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: NotificationCreateManyVenueInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutVenueInput | NotificationUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutVenueInput | NotificationUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type VenueCreateNestedOneWithoutContactsInput = {
    create?: XOR<VenueCreateWithoutContactsInput, VenueUncheckedCreateWithoutContactsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutContactsInput
    connect?: VenueWhereUniqueInput
  }

  export type VenueUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<VenueCreateWithoutContactsInput, VenueUncheckedCreateWithoutContactsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutContactsInput
    upsert?: VenueUpsertWithoutContactsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutContactsInput, VenueUpdateWithoutContactsInput>, VenueUncheckedUpdateWithoutContactsInput>
  }

  export type OwnerCreateNestedOneWithoutOwnerVenueInput = {
    create?: XOR<OwnerCreateWithoutOwnerVenueInput, OwnerUncheckedCreateWithoutOwnerVenueInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutOwnerVenueInput
    connect?: OwnerWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutOwnerVenueInput = {
    create?: XOR<VenueCreateWithoutOwnerVenueInput, VenueUncheckedCreateWithoutOwnerVenueInput>
    connectOrCreate?: VenueCreateOrConnectWithoutOwnerVenueInput
    connect?: VenueWhereUniqueInput
  }

  export type OwnerUpdateOneRequiredWithoutOwnerVenueNestedInput = {
    create?: XOR<OwnerCreateWithoutOwnerVenueInput, OwnerUncheckedCreateWithoutOwnerVenueInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutOwnerVenueInput
    upsert?: OwnerUpsertWithoutOwnerVenueInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutOwnerVenueInput, OwnerUpdateWithoutOwnerVenueInput>, OwnerUncheckedUpdateWithoutOwnerVenueInput>
  }

  export type VenueUpdateOneRequiredWithoutOwnerVenueNestedInput = {
    create?: XOR<VenueCreateWithoutOwnerVenueInput, VenueUncheckedCreateWithoutOwnerVenueInput>
    connectOrCreate?: VenueCreateOrConnectWithoutOwnerVenueInput
    upsert?: VenueUpsertWithoutOwnerVenueInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutOwnerVenueInput, VenueUpdateWithoutOwnerVenueInput>, VenueUncheckedUpdateWithoutOwnerVenueInput>
  }

  export type OwnerVenueCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OwnerVenueCreateWithoutOwnerInput, OwnerVenueUncheckedCreateWithoutOwnerInput> | OwnerVenueCreateWithoutOwnerInput[] | OwnerVenueUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerVenueCreateOrConnectWithoutOwnerInput | OwnerVenueCreateOrConnectWithoutOwnerInput[]
    createMany?: OwnerVenueCreateManyOwnerInputEnvelope
    connect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutOwnersInput = {
    create?: XOR<OrganizationCreateWithoutOwnersInput, OrganizationUncheckedCreateWithoutOwnersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OwnerVenueUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OwnerVenueCreateWithoutOwnerInput, OwnerVenueUncheckedCreateWithoutOwnerInput> | OwnerVenueCreateWithoutOwnerInput[] | OwnerVenueUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerVenueCreateOrConnectWithoutOwnerInput | OwnerVenueCreateOrConnectWithoutOwnerInput[]
    createMany?: OwnerVenueCreateManyOwnerInputEnvelope
    connect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
  }

  export type OwnerVenueUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OwnerVenueCreateWithoutOwnerInput, OwnerVenueUncheckedCreateWithoutOwnerInput> | OwnerVenueCreateWithoutOwnerInput[] | OwnerVenueUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerVenueCreateOrConnectWithoutOwnerInput | OwnerVenueCreateOrConnectWithoutOwnerInput[]
    upsert?: OwnerVenueUpsertWithWhereUniqueWithoutOwnerInput | OwnerVenueUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OwnerVenueCreateManyOwnerInputEnvelope
    set?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    disconnect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    delete?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    connect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    update?: OwnerVenueUpdateWithWhereUniqueWithoutOwnerInput | OwnerVenueUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OwnerVenueUpdateManyWithWhereWithoutOwnerInput | OwnerVenueUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OwnerVenueScalarWhereInput | OwnerVenueScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutOwnersNestedInput = {
    create?: XOR<OrganizationCreateWithoutOwnersInput, OrganizationUncheckedCreateWithoutOwnersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnersInput
    upsert?: OrganizationUpsertWithoutOwnersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOwnersInput, OrganizationUpdateWithoutOwnersInput>, OrganizationUncheckedUpdateWithoutOwnersInput>
  }

  export type OwnerVenueUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OwnerVenueCreateWithoutOwnerInput, OwnerVenueUncheckedCreateWithoutOwnerInput> | OwnerVenueCreateWithoutOwnerInput[] | OwnerVenueUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerVenueCreateOrConnectWithoutOwnerInput | OwnerVenueCreateOrConnectWithoutOwnerInput[]
    upsert?: OwnerVenueUpsertWithWhereUniqueWithoutOwnerInput | OwnerVenueUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OwnerVenueCreateManyOwnerInputEnvelope
    set?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    disconnect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    delete?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    connect?: OwnerVenueWhereUniqueInput | OwnerVenueWhereUniqueInput[]
    update?: OwnerVenueUpdateWithWhereUniqueWithoutOwnerInput | OwnerVenueUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OwnerVenueUpdateManyWithWhereWithoutOwnerInput | OwnerVenueUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OwnerVenueScalarWhereInput | OwnerVenueScalarWhereInput[]
  }

  export type VenueCreateNestedOneWithoutImagesInput = {
    create?: XOR<VenueCreateWithoutImagesInput, VenueUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutImagesInput
    connect?: VenueWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type VenueUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<VenueCreateWithoutImagesInput, VenueUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutImagesInput
    upsert?: VenueUpsertWithoutImagesInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutImagesInput, VenueUpdateWithoutImagesInput>, VenueUncheckedUpdateWithoutImagesInput>
  }

  export type VenueCreateNestedOneWithoutTextsInput = {
    create?: XOR<VenueCreateWithoutTextsInput, VenueUncheckedCreateWithoutTextsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutTextsInput
    connect?: VenueWhereUniqueInput
  }

  export type VenueUpdateOneRequiredWithoutTextsNestedInput = {
    create?: XOR<VenueCreateWithoutTextsInput, VenueUncheckedCreateWithoutTextsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutTextsInput
    upsert?: VenueUpsertWithoutTextsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutTextsInput, VenueUpdateWithoutTextsInput>, VenueUncheckedUpdateWithoutTextsInput>
  }

  export type VenueCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<VenueCreateWithoutQuestionsInput, VenueUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutQuestionsInput
    connect?: VenueWhereUniqueInput
  }

  export type VenueUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<VenueCreateWithoutQuestionsInput, VenueUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutQuestionsInput
    upsert?: VenueUpsertWithoutQuestionsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutQuestionsInput, VenueUpdateWithoutQuestionsInput>, VenueUncheckedUpdateWithoutQuestionsInput>
  }

  export type OrganizationCreateNestedOneWithoutContractInput = {
    create?: XOR<OrganizationCreateWithoutContractInput, OrganizationUncheckedCreateWithoutContractInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutContractInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ClauseCreateNestedManyWithoutContractInput = {
    create?: XOR<ClauseCreateWithoutContractInput, ClauseUncheckedCreateWithoutContractInput> | ClauseCreateWithoutContractInput[] | ClauseUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ClauseCreateOrConnectWithoutContractInput | ClauseCreateOrConnectWithoutContractInput[]
    createMany?: ClauseCreateManyContractInputEnvelope
    connect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
  }

  export type ClauseUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ClauseCreateWithoutContractInput, ClauseUncheckedCreateWithoutContractInput> | ClauseCreateWithoutContractInput[] | ClauseUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ClauseCreateOrConnectWithoutContractInput | ClauseCreateOrConnectWithoutContractInput[]
    createMany?: ClauseCreateManyContractInputEnvelope
    connect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutContractNestedInput = {
    create?: XOR<OrganizationCreateWithoutContractInput, OrganizationUncheckedCreateWithoutContractInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutContractInput
    upsert?: OrganizationUpsertWithoutContractInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutContractInput, OrganizationUpdateWithoutContractInput>, OrganizationUncheckedUpdateWithoutContractInput>
  }

  export type ClauseUpdateManyWithoutContractNestedInput = {
    create?: XOR<ClauseCreateWithoutContractInput, ClauseUncheckedCreateWithoutContractInput> | ClauseCreateWithoutContractInput[] | ClauseUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ClauseCreateOrConnectWithoutContractInput | ClauseCreateOrConnectWithoutContractInput[]
    upsert?: ClauseUpsertWithWhereUniqueWithoutContractInput | ClauseUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ClauseCreateManyContractInputEnvelope
    set?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    disconnect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    delete?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    connect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    update?: ClauseUpdateWithWhereUniqueWithoutContractInput | ClauseUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ClauseUpdateManyWithWhereWithoutContractInput | ClauseUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ClauseScalarWhereInput | ClauseScalarWhereInput[]
  }

  export type ClauseUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ClauseCreateWithoutContractInput, ClauseUncheckedCreateWithoutContractInput> | ClauseCreateWithoutContractInput[] | ClauseUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ClauseCreateOrConnectWithoutContractInput | ClauseCreateOrConnectWithoutContractInput[]
    upsert?: ClauseUpsertWithWhereUniqueWithoutContractInput | ClauseUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ClauseCreateManyContractInputEnvelope
    set?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    disconnect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    delete?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    connect?: ClauseWhereUniqueInput | ClauseWhereUniqueInput[]
    update?: ClauseUpdateWithWhereUniqueWithoutContractInput | ClauseUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ClauseUpdateManyWithWhereWithoutContractInput | ClauseUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ClauseScalarWhereInput | ClauseScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutClauseInput = {
    create?: XOR<OrganizationCreateWithoutClauseInput, OrganizationUncheckedCreateWithoutClauseInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutClauseInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ContractCreateNestedOneWithoutClausesInput = {
    create?: XOR<ContractCreateWithoutClausesInput, ContractUncheckedCreateWithoutClausesInput>
    connectOrCreate?: ContractCreateOrConnectWithoutClausesInput
    connect?: ContractWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationUpdateOneWithoutClauseNestedInput = {
    create?: XOR<OrganizationCreateWithoutClauseInput, OrganizationUncheckedCreateWithoutClauseInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutClauseInput
    upsert?: OrganizationUpsertWithoutClauseInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutClauseInput, OrganizationUpdateWithoutClauseInput>, OrganizationUncheckedUpdateWithoutClauseInput>
  }

  export type ContractUpdateOneWithoutClausesNestedInput = {
    create?: XOR<ContractCreateWithoutClausesInput, ContractUncheckedCreateWithoutClausesInput>
    connectOrCreate?: ContractCreateOrConnectWithoutClausesInput
    upsert?: ContractUpsertWithoutClausesInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutClausesInput, ContractUpdateWithoutClausesInput>, ContractUncheckedUpdateWithoutClausesInput>
  }

  export type ProposalCreateNestedOneWithoutScheduleListInput = {
    create?: XOR<ProposalCreateWithoutScheduleListInput, ProposalUncheckedCreateWithoutScheduleListInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutScheduleListInput
    connect?: ProposalWhereUniqueInput
  }

  export type ProposalUpdateOneRequiredWithoutScheduleListNestedInput = {
    create?: XOR<ProposalCreateWithoutScheduleListInput, ProposalUncheckedCreateWithoutScheduleListInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutScheduleListInput
    upsert?: ProposalUpsertWithoutScheduleListInput
    connect?: ProposalWhereUniqueInput
    update?: XOR<XOR<ProposalUpdateToOneWithWhereWithoutScheduleListInput, ProposalUpdateWithoutScheduleListInput>, ProposalUncheckedUpdateWithoutScheduleListInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumProposalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalType | EnumProposalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalType[]
    notIn?: $Enums.ProposalType[]
    not?: NestedEnumProposalTypeFilter<$PrismaModel> | $Enums.ProposalType
  }

  export type NestedEnumTrafficSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficSource | EnumTrafficSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TrafficSource[]
    notIn?: $Enums.TrafficSource[]
    not?: NestedEnumTrafficSourceFilter<$PrismaModel> | $Enums.TrafficSource
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProposalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalType | EnumProposalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalType[]
    notIn?: $Enums.ProposalType[]
    not?: NestedEnumProposalTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProposalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalTypeFilter<$PrismaModel>
    _max?: NestedEnumProposalTypeFilter<$PrismaModel>
  }

  export type NestedEnumTrafficSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficSource | EnumTrafficSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TrafficSource[]
    notIn?: $Enums.TrafficSource[]
    not?: NestedEnumTrafficSourceWithAggregatesFilter<$PrismaModel> | $Enums.TrafficSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrafficSourceFilter<$PrismaModel>
    _max?: NestedEnumTrafficSourceFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumPersonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[]
    notIn?: $Enums.PersonType[]
    not?: NestedEnumPersonTypeFilter<$PrismaModel> | $Enums.PersonType
  }

  export type NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[]
    notIn?: $Enums.PersonType[]
    not?: NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel> | $Enums.PersonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonTypeFilter<$PrismaModel>
    _max?: NestedEnumPersonTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | null
    notIn?: $Enums.PaymentMethod[] | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | null
    notIn?: $Enums.PaymentMethod[] | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumProposalNameFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalName | EnumProposalNameFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalName[]
    notIn?: $Enums.ProposalName[]
    not?: NestedEnumProposalNameFilter<$PrismaModel> | $Enums.ProposalName
  }

  export type NestedEnumProposalNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalName | EnumProposalNameFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalName[]
    notIn?: $Enums.ProposalName[]
    not?: NestedEnumProposalNameWithAggregatesFilter<$PrismaModel> | $Enums.ProposalName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalNameFilter<$PrismaModel>
    _max?: NestedEnumProposalNameFilter<$PrismaModel>
  }

  export type NestedEnumExpenseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[]
    notIn?: $Enums.ExpenseType[]
    not?: NestedEnumExpenseTypeFilter<$PrismaModel> | $Enums.ExpenseType
  }

  export type NestedEnumExpenseCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[]
    notIn?: $Enums.ExpenseCategory[]
    not?: NestedEnumExpenseCategoryFilter<$PrismaModel> | $Enums.ExpenseCategory
  }

  export type NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[]
    notIn?: $Enums.ExpenseType[]
    not?: NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseTypeFilter<$PrismaModel>
    _max?: NestedEnumExpenseTypeFilter<$PrismaModel>
  }

  export type NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[]
    notIn?: $Enums.ExpenseCategory[]
    not?: NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumDateEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DateEventType | EnumDateEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DateEventType[]
    notIn?: $Enums.DateEventType[]
    not?: NestedEnumDateEventTypeFilter<$PrismaModel> | $Enums.DateEventType
  }

  export type NestedEnumDateEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DateEventType | EnumDateEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DateEventType[]
    notIn?: $Enums.DateEventType[]
    not?: NestedEnumDateEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.DateEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDateEventTypeFilter<$PrismaModel>
    _max?: NestedEnumDateEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumPricingModelFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[]
    notIn?: $Enums.PricingModel[]
    not?: NestedEnumPricingModelFilter<$PrismaModel> | $Enums.PricingModel
  }

  export type NestedEnumPricingModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[]
    notIn?: $Enums.PricingModel[]
    not?: NestedEnumPricingModelWithAggregatesFilter<$PrismaModel> | $Enums.PricingModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingModelFilter<$PrismaModel>
    _max?: NestedEnumPricingModelFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutRefreshTokenInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
    session?: SessionCreateNestedManyWithoutUserInput
    histories?: HistoryCreateNestedManyWithoutUserInput
    userOrganizations?: UserOrganizationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokenInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    histories?: HistoryUncheckedCreateNestedManyWithoutUserInput
    userOrganizations?: UserOrganizationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
  }

  export type SessionCreateWithoutRefreshTokenInput = {
    id?: string
    ipAddress?: string | null
    isValid?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutRefreshTokenInput = {
    id?: string
    userId: string
    ipAddress?: string | null
    isValid?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SessionCreateOrConnectWithoutRefreshTokenInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutRefreshTokenInput, SessionUncheckedCreateWithoutRefreshTokenInput>
  }

  export type SessionCreateManyRefreshTokenInputEnvelope = {
    data: SessionCreateManyRefreshTokenInput | SessionCreateManyRefreshTokenInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRefreshTokenInput = {
    update: XOR<UserUpdateWithoutRefreshTokenInput, UserUncheckedUpdateWithoutRefreshTokenInput>
    create: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokenInput, UserUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type UserUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUpdateManyWithoutUserNestedInput
    histories?: HistoryUpdateManyWithoutUserNestedInput
    userOrganizations?: UserOrganizationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutUserNestedInput
    userOrganizations?: UserOrganizationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutRefreshTokenInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutRefreshTokenInput, SessionUncheckedUpdateWithoutRefreshTokenInput>
    create: XOR<SessionCreateWithoutRefreshTokenInput, SessionUncheckedCreateWithoutRefreshTokenInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutRefreshTokenInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutRefreshTokenInput, SessionUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type SessionUpdateManyWithWhereWithoutRefreshTokenInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutRefreshTokenInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshTokenId?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    isValid?: BoolFilter<"Session"> | boolean
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserCreateWithoutSessionInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
    histories?: HistoryCreateNestedManyWithoutUserInput
    refreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    userOrganizations?: UserOrganizationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
    histories?: HistoryUncheckedCreateNestedManyWithoutUserInput
    refreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    userOrganizations?: UserOrganizationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
  }

  export type RefreshTokenCreateWithoutSessionInput = {
    id?: string
    expireIn: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokenInput
  }

  export type RefreshTokenUncheckedCreateWithoutSessionInput = {
    id?: string
    expireIn: number
    userId: string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutSessionInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutSessionInput, RefreshTokenUncheckedCreateWithoutSessionInput>
  }

  export type UserUpsertWithoutSessionInput = {
    update: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
  }

  export type UserUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    histories?: HistoryUpdateManyWithoutUserNestedInput
    refreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    userOrganizations?: UserOrganizationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    histories?: HistoryUncheckedUpdateManyWithoutUserNestedInput
    refreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    userOrganizations?: UserOrganizationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RefreshTokenUpsertWithoutSessionInput = {
    update: XOR<RefreshTokenUpdateWithoutSessionInput, RefreshTokenUncheckedUpdateWithoutSessionInput>
    create: XOR<RefreshTokenCreateWithoutSessionInput, RefreshTokenUncheckedCreateWithoutSessionInput>
    where?: RefreshTokenWhereInput
  }

  export type RefreshTokenUpdateToOneWithWhereWithoutSessionInput = {
    where?: RefreshTokenWhereInput
    data: XOR<RefreshTokenUpdateWithoutSessionInput, RefreshTokenUncheckedUpdateWithoutSessionInput>
  }

  export type RefreshTokenUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    expireIn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    expireIn?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    ipAddress?: string | null
    isValid?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
    refreshToken?: RefreshTokenCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshTokenId: string
    ipAddress?: string | null
    isValid?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HistoryCreateWithoutUserInput = {
    id?: string
    action: string
    username?: string | null
    createdAt?: Date | string
    proposal: ProposalCreateNestedOneWithoutHistoriesInput
  }

  export type HistoryUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    username?: string | null
    proposalId: string
    createdAt?: Date | string
  }

  export type HistoryCreateOrConnectWithoutUserInput = {
    where: HistoryWhereUniqueInput
    create: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput>
  }

  export type HistoryCreateManyUserInputEnvelope = {
    data: HistoryCreateManyUserInput | HistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    expireIn: number
    createdAt?: Date | string
    session?: SessionCreateNestedManyWithoutRefreshTokenInput
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    expireIn: number
    createdAt?: Date | string
    session?: SessionUncheckedCreateNestedManyWithoutRefreshTokenInput
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserOrganizationCreateWithoutUserInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUserOrganizationsInput
  }

  export type UserOrganizationUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type UserOrganizationCreateOrConnectWithoutUserInput = {
    where: UserOrganizationWhereUniqueInput
    create: XOR<UserOrganizationCreateWithoutUserInput, UserOrganizationUncheckedCreateWithoutUserInput>
  }

  export type UserOrganizationCreateManyUserInputEnvelope = {
    data: UserOrganizationCreateManyUserInput | UserOrganizationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type HistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: HistoryWhereUniqueInput
    update: XOR<HistoryUpdateWithoutUserInput, HistoryUncheckedUpdateWithoutUserInput>
    create: XOR<HistoryCreateWithoutUserInput, HistoryUncheckedCreateWithoutUserInput>
  }

  export type HistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: HistoryWhereUniqueInput
    data: XOR<HistoryUpdateWithoutUserInput, HistoryUncheckedUpdateWithoutUserInput>
  }

  export type HistoryUpdateManyWithWhereWithoutUserInput = {
    where: HistoryScalarWhereInput
    data: XOR<HistoryUpdateManyMutationInput, HistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type HistoryScalarWhereInput = {
    AND?: HistoryScalarWhereInput | HistoryScalarWhereInput[]
    OR?: HistoryScalarWhereInput[]
    NOT?: HistoryScalarWhereInput | HistoryScalarWhereInput[]
    id?: StringFilter<"History"> | string
    action?: StringFilter<"History"> | string
    username?: StringNullableFilter<"History"> | string | null
    userId?: StringNullableFilter<"History"> | string | null
    proposalId?: StringFilter<"History"> | string
    createdAt?: DateTimeFilter<"History"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    expireIn?: IntFilter<"RefreshToken"> | number
    userId?: StringFilter<"RefreshToken"> | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type UserOrganizationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserOrganizationWhereUniqueInput
    update: XOR<UserOrganizationUpdateWithoutUserInput, UserOrganizationUncheckedUpdateWithoutUserInput>
    create: XOR<UserOrganizationCreateWithoutUserInput, UserOrganizationUncheckedCreateWithoutUserInput>
  }

  export type UserOrganizationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserOrganizationWhereUniqueInput
    data: XOR<UserOrganizationUpdateWithoutUserInput, UserOrganizationUncheckedUpdateWithoutUserInput>
  }

  export type UserOrganizationUpdateManyWithWhereWithoutUserInput = {
    where: UserOrganizationScalarWhereInput
    data: XOR<UserOrganizationUpdateManyMutationInput, UserOrganizationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserOrganizationScalarWhereInput = {
    AND?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
    OR?: UserOrganizationScalarWhereInput[]
    NOT?: UserOrganizationScalarWhereInput | UserOrganizationScalarWhereInput[]
    id?: StringFilter<"UserOrganization"> | string
    userId?: StringFilter<"UserOrganization"> | string
    organizationId?: StringFilter<"UserOrganization"> | string
    role?: EnumRoleFilter<"UserOrganization"> | $Enums.Role
    joinedAt?: DateTimeFilter<"UserOrganization"> | Date | string
  }

  export type VenueCreateWithoutOrganizationInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutOrganizationInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutOrganizationInput, VenueUncheckedCreateWithoutOrganizationInput>
  }

  export type VenueCreateManyOrganizationInputEnvelope = {
    data: VenueCreateManyOrganizationInput | VenueCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OwnerCreateWithoutOrganizationInput = {
    id?: string
    completeName: string
    rg?: string | null
    cpf: string
    pix: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    bankName: string
    bankAgency: string
    cep: string
    createdAt?: Date | string
    bankAccountNumber: string
    ownerVenue?: OwnerVenueCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutOrganizationInput = {
    id?: string
    completeName: string
    rg?: string | null
    cpf: string
    pix: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    bankName: string
    bankAgency: string
    cep: string
    createdAt?: Date | string
    bankAccountNumber: string
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutOrganizationInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutOrganizationInput, OwnerUncheckedCreateWithoutOrganizationInput>
  }

  export type OwnerCreateManyOrganizationInputEnvelope = {
    data: OwnerCreateManyOrganizationInput | OwnerCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserOrganizationCreateWithoutOrganizationInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutUserOrganizationsInput
  }

  export type UserOrganizationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type UserOrganizationCreateOrConnectWithoutOrganizationInput = {
    where: UserOrganizationWhereUniqueInput
    create: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type UserOrganizationCreateManyOrganizationInputEnvelope = {
    data: UserOrganizationCreateManyOrganizationInput | UserOrganizationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ClauseCreateWithoutOrganizationInput = {
    id?: string
    text: string
    title: string
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Contract?: ContractCreateNestedOneWithoutClausesInput
  }

  export type ClauseUncheckedCreateWithoutOrganizationInput = {
    id?: string
    text: string
    title: string
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contractId?: string | null
  }

  export type ClauseCreateOrConnectWithoutOrganizationInput = {
    where: ClauseWhereUniqueInput
    create: XOR<ClauseCreateWithoutOrganizationInput, ClauseUncheckedCreateWithoutOrganizationInput>
  }

  export type ClauseCreateManyOrganizationInputEnvelope = {
    data: ClauseCreateManyOrganizationInput | ClauseCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutOrganizationInput = {
    id?: string
    name: string
    title: string
    clauses?: ClauseCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    title: string
    clauses?: ClauseUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutOrganizationInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutOrganizationInput, ContractUncheckedCreateWithoutOrganizationInput>
  }

  export type ContractCreateManyOrganizationInputEnvelope = {
    data: ContractCreateManyOrganizationInput | ContractCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type VenueUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: VenueWhereUniqueInput
    update: XOR<VenueUpdateWithoutOrganizationInput, VenueUncheckedUpdateWithoutOrganizationInput>
    create: XOR<VenueCreateWithoutOrganizationInput, VenueUncheckedCreateWithoutOrganizationInput>
  }

  export type VenueUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: VenueWhereUniqueInput
    data: XOR<VenueUpdateWithoutOrganizationInput, VenueUncheckedUpdateWithoutOrganizationInput>
  }

  export type VenueUpdateManyWithWhereWithoutOrganizationInput = {
    where: VenueScalarWhereInput
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type VenueScalarWhereInput = {
    AND?: VenueScalarWhereInput | VenueScalarWhereInput[]
    OR?: VenueScalarWhereInput[]
    NOT?: VenueScalarWhereInput | VenueScalarWhereInput[]
    id?: StringFilter<"Venue"> | string
    name?: StringFilter<"Venue"> | string
    street?: StringFilter<"Venue"> | string
    streetNumber?: StringFilter<"Venue"> | string
    complement?: StringNullableFilter<"Venue"> | string | null
    neighborhood?: StringFilter<"Venue"> | string
    city?: StringFilter<"Venue"> | string
    state?: StringFilter<"Venue"> | string
    checkIn?: StringNullableFilter<"Venue"> | string | null
    checkOut?: StringNullableFilter<"Venue"> | string | null
    cep?: StringFilter<"Venue"> | string
    hasOvernightStay?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    organizationId?: StringFilter<"Venue"> | string
    pricingModel?: EnumPricingModelFilter<"Venue"> | $Enums.PricingModel
    pricePerPerson?: FloatNullableFilter<"Venue"> | number | null
    pricePerDay?: FloatNullableFilter<"Venue"> | number | null
    maxGuest?: IntFilter<"Venue"> | number
  }

  export type OwnerUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OwnerWhereUniqueInput
    update: XOR<OwnerUpdateWithoutOrganizationInput, OwnerUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OwnerCreateWithoutOrganizationInput, OwnerUncheckedCreateWithoutOrganizationInput>
  }

  export type OwnerUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OwnerWhereUniqueInput
    data: XOR<OwnerUpdateWithoutOrganizationInput, OwnerUncheckedUpdateWithoutOrganizationInput>
  }

  export type OwnerUpdateManyWithWhereWithoutOrganizationInput = {
    where: OwnerScalarWhereInput
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OwnerScalarWhereInput = {
    AND?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
    OR?: OwnerScalarWhereInput[]
    NOT?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
    id?: StringFilter<"Owner"> | string
    completeName?: StringFilter<"Owner"> | string
    rg?: StringNullableFilter<"Owner"> | string | null
    cpf?: StringFilter<"Owner"> | string
    pix?: StringFilter<"Owner"> | string
    street?: StringFilter<"Owner"> | string
    streetNumber?: StringFilter<"Owner"> | string
    complement?: StringNullableFilter<"Owner"> | string | null
    neighborhood?: StringFilter<"Owner"> | string
    city?: StringFilter<"Owner"> | string
    state?: StringFilter<"Owner"> | string
    bankName?: StringFilter<"Owner"> | string
    bankAgency?: StringFilter<"Owner"> | string
    cep?: StringFilter<"Owner"> | string
    createdAt?: DateTimeFilter<"Owner"> | Date | string
    bankAccountNumber?: StringFilter<"Owner"> | string
    organizationId?: StringFilter<"Owner"> | string
  }

  export type UserOrganizationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserOrganizationWhereUniqueInput
    update: XOR<UserOrganizationUpdateWithoutOrganizationInput, UserOrganizationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserOrganizationCreateWithoutOrganizationInput, UserOrganizationUncheckedCreateWithoutOrganizationInput>
  }

  export type UserOrganizationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserOrganizationWhereUniqueInput
    data: XOR<UserOrganizationUpdateWithoutOrganizationInput, UserOrganizationUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserOrganizationUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserOrganizationScalarWhereInput
    data: XOR<UserOrganizationUpdateManyMutationInput, UserOrganizationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ClauseUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ClauseWhereUniqueInput
    update: XOR<ClauseUpdateWithoutOrganizationInput, ClauseUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ClauseCreateWithoutOrganizationInput, ClauseUncheckedCreateWithoutOrganizationInput>
  }

  export type ClauseUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ClauseWhereUniqueInput
    data: XOR<ClauseUpdateWithoutOrganizationInput, ClauseUncheckedUpdateWithoutOrganizationInput>
  }

  export type ClauseUpdateManyWithWhereWithoutOrganizationInput = {
    where: ClauseScalarWhereInput
    data: XOR<ClauseUpdateManyMutationInput, ClauseUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ClauseScalarWhereInput = {
    AND?: ClauseScalarWhereInput | ClauseScalarWhereInput[]
    OR?: ClauseScalarWhereInput[]
    NOT?: ClauseScalarWhereInput | ClauseScalarWhereInput[]
    id?: StringFilter<"Clause"> | string
    text?: StringFilter<"Clause"> | string
    title?: StringFilter<"Clause"> | string
    position?: IntNullableFilter<"Clause"> | number | null
    createdAt?: DateTimeFilter<"Clause"> | Date | string
    updatedAt?: DateTimeFilter<"Clause"> | Date | string
    organizationId?: StringNullableFilter<"Clause"> | string | null
    contractId?: StringNullableFilter<"Clause"> | string | null
  }

  export type ContractUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutOrganizationInput, ContractUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ContractCreateWithoutOrganizationInput, ContractUncheckedCreateWithoutOrganizationInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutOrganizationInput, ContractUncheckedUpdateWithoutOrganizationInput>
  }

  export type ContractUpdateManyWithWhereWithoutOrganizationInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: StringFilter<"Contract"> | string
    name?: StringFilter<"Contract"> | string
    title?: StringFilter<"Contract"> | string
    organizationId?: StringFilter<"Contract"> | string
  }

  export type UserCreateWithoutUserOrganizationsInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
    session?: SessionCreateNestedManyWithoutUserInput
    histories?: HistoryCreateNestedManyWithoutUserInput
    refreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserOrganizationsInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    histories?: HistoryUncheckedCreateNestedManyWithoutUserInput
    refreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserOrganizationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserOrganizationsInput, UserUncheckedCreateWithoutUserOrganizationsInput>
  }

  export type OrganizationCreateWithoutUserOrganizationsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    venues?: VenueCreateNestedManyWithoutOrganizationInput
    owners?: OwnerCreateNestedManyWithoutOrganizationInput
    Clause?: ClauseCreateNestedManyWithoutOrganizationInput
    Contract?: ContractCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUserOrganizationsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutOrganizationInput
    owners?: OwnerUncheckedCreateNestedManyWithoutOrganizationInput
    Clause?: ClauseUncheckedCreateNestedManyWithoutOrganizationInput
    Contract?: ContractUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUserOrganizationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUserOrganizationsInput, OrganizationUncheckedCreateWithoutUserOrganizationsInput>
  }

  export type UserUpsertWithoutUserOrganizationsInput = {
    update: XOR<UserUpdateWithoutUserOrganizationsInput, UserUncheckedUpdateWithoutUserOrganizationsInput>
    create: XOR<UserCreateWithoutUserOrganizationsInput, UserUncheckedCreateWithoutUserOrganizationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserOrganizationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserOrganizationsInput, UserUncheckedUpdateWithoutUserOrganizationsInput>
  }

  export type UserUpdateWithoutUserOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUpdateManyWithoutUserNestedInput
    histories?: HistoryUpdateManyWithoutUserNestedInput
    refreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutUserNestedInput
    refreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutUserOrganizationsInput = {
    update: XOR<OrganizationUpdateWithoutUserOrganizationsInput, OrganizationUncheckedUpdateWithoutUserOrganizationsInput>
    create: XOR<OrganizationCreateWithoutUserOrganizationsInput, OrganizationUncheckedCreateWithoutUserOrganizationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUserOrganizationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUserOrganizationsInput, OrganizationUncheckedUpdateWithoutUserOrganizationsInput>
  }

  export type OrganizationUpdateWithoutUserOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutOrganizationNestedInput
    owners?: OwnerUpdateManyWithoutOrganizationNestedInput
    Clause?: ClauseUpdateManyWithoutOrganizationNestedInput
    Contract?: ContractUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUserOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutOrganizationNestedInput
    owners?: OwnerUncheckedUpdateManyWithoutOrganizationNestedInput
    Clause?: ClauseUncheckedUpdateManyWithoutOrganizationNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type VenueCreateWithoutProposalsInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutProposalsInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutProposalsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutProposalsInput, VenueUncheckedCreateWithoutProposalsInput>
  }

  export type PersonCreateWithoutProposalInput = {
    id?: string
    attendance?: boolean
    type: $Enums.PersonType
    name: string
    email?: string | null
    rg?: string | null
  }

  export type PersonUncheckedCreateWithoutProposalInput = {
    id?: string
    attendance?: boolean
    type: $Enums.PersonType
    name: string
    email?: string | null
    rg?: string | null
  }

  export type PersonCreateOrConnectWithoutProposalInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutProposalInput, PersonUncheckedCreateWithoutProposalInput>
  }

  export type PersonCreateManyProposalInputEnvelope = {
    data: PersonCreateManyProposalInput | PersonCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type HistoryCreateWithoutProposalInput = {
    id?: string
    action: string
    username?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutHistoriesInput
  }

  export type HistoryUncheckedCreateWithoutProposalInput = {
    id?: string
    action: string
    username?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type HistoryCreateOrConnectWithoutProposalInput = {
    where: HistoryWhereUniqueInput
    create: XOR<HistoryCreateWithoutProposalInput, HistoryUncheckedCreateWithoutProposalInput>
  }

  export type HistoryCreateManyProposalInputEnvelope = {
    data: HistoryCreateManyProposalInput | HistoryCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutProposalInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    venue: VenueCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutProposalInput = {
    id?: string
    venueId: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
  }

  export type PaymentCreateOrConnectWithoutProposalInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutProposalInput, PaymentUncheckedCreateWithoutProposalInput>
  }

  export type PaymentCreateManyProposalInputEnvelope = {
    data: PaymentCreateManyProposalInput | PaymentCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type DateEventCreateWithoutProposalInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.DateEventType
    venue: VenueCreateNestedOneWithoutDateEventInput
    notifications?: NotificationCreateNestedManyWithoutDateEventInput
  }

  export type DateEventUncheckedCreateWithoutProposalInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    venueId: string
    type: $Enums.DateEventType
    notifications?: NotificationUncheckedCreateNestedManyWithoutDateEventInput
  }

  export type DateEventCreateOrConnectWithoutProposalInput = {
    where: DateEventWhereUniqueInput
    create: XOR<DateEventCreateWithoutProposalInput, DateEventUncheckedCreateWithoutProposalInput>
  }

  export type DateEventCreateManyProposalInputEnvelope = {
    data: DateEventCreateManyProposalInput | DateEventCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type ProposalCostCreateWithoutProposalsInput = {
    id?: string
    name: $Enums.ProposalName
    teste: string
    amount: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ProposalCostUncheckedCreateWithoutProposalsInput = {
    id?: string
    name: $Enums.ProposalName
    teste: string
    amount: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ProposalCostCreateOrConnectWithoutProposalsInput = {
    where: ProposalCostWhereUniqueInput
    create: XOR<ProposalCostCreateWithoutProposalsInput, ProposalCostUncheckedCreateWithoutProposalsInput>
  }

  export type ProposalServiceCreateWithoutProposalInput = {
    id?: string
    joinedAt?: Date | string
    service: ServiceCreateNestedOneWithoutProposalServicesInput
  }

  export type ProposalServiceUncheckedCreateWithoutProposalInput = {
    id?: string
    serviceId: string
    joinedAt?: Date | string
  }

  export type ProposalServiceCreateOrConnectWithoutProposalInput = {
    where: ProposalServiceWhereUniqueInput
    create: XOR<ProposalServiceCreateWithoutProposalInput, ProposalServiceUncheckedCreateWithoutProposalInput>
  }

  export type ProposalServiceCreateManyProposalInputEnvelope = {
    data: ProposalServiceCreateManyProposalInput | ProposalServiceCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutProposalInput = {
    id?: string
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
    venue: VenueCreateNestedOneWithoutNotificationsInput
    dateEvent?: DateEventCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutProposalInput = {
    id?: string
    venueId: string
    dateEventId?: string | null
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
  }

  export type NotificationCreateOrConnectWithoutProposalInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutProposalInput, NotificationUncheckedCreateWithoutProposalInput>
  }

  export type NotificationCreateManyProposalInputEnvelope = {
    data: NotificationCreateManyProposalInput | NotificationCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutProposalInput = {
    id?: string
    name: string
    workerNumber: number
    description?: string | null
    startHour: Date | string
    endHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUncheckedCreateWithoutProposalInput = {
    id?: string
    name: string
    workerNumber: number
    description?: string | null
    startHour: Date | string
    endHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutProposalInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutProposalInput, ScheduleUncheckedCreateWithoutProposalInput>
  }

  export type ScheduleCreateManyProposalInputEnvelope = {
    data: ScheduleCreateManyProposalInput | ScheduleCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type VenueUpsertWithoutProposalsInput = {
    update: XOR<VenueUpdateWithoutProposalsInput, VenueUncheckedUpdateWithoutProposalsInput>
    create: XOR<VenueCreateWithoutProposalsInput, VenueUncheckedCreateWithoutProposalsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutProposalsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutProposalsInput, VenueUncheckedUpdateWithoutProposalsInput>
  }

  export type VenueUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type PersonUpsertWithWhereUniqueWithoutProposalInput = {
    where: PersonWhereUniqueInput
    update: XOR<PersonUpdateWithoutProposalInput, PersonUncheckedUpdateWithoutProposalInput>
    create: XOR<PersonCreateWithoutProposalInput, PersonUncheckedCreateWithoutProposalInput>
  }

  export type PersonUpdateWithWhereUniqueWithoutProposalInput = {
    where: PersonWhereUniqueInput
    data: XOR<PersonUpdateWithoutProposalInput, PersonUncheckedUpdateWithoutProposalInput>
  }

  export type PersonUpdateManyWithWhereWithoutProposalInput = {
    where: PersonScalarWhereInput
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyWithoutProposalInput>
  }

  export type PersonScalarWhereInput = {
    AND?: PersonScalarWhereInput | PersonScalarWhereInput[]
    OR?: PersonScalarWhereInput[]
    NOT?: PersonScalarWhereInput | PersonScalarWhereInput[]
    id?: StringFilter<"Person"> | string
    attendance?: BoolFilter<"Person"> | boolean
    type?: EnumPersonTypeFilter<"Person"> | $Enums.PersonType
    name?: StringFilter<"Person"> | string
    email?: StringNullableFilter<"Person"> | string | null
    rg?: StringNullableFilter<"Person"> | string | null
    proposalId?: StringFilter<"Person"> | string
  }

  export type HistoryUpsertWithWhereUniqueWithoutProposalInput = {
    where: HistoryWhereUniqueInput
    update: XOR<HistoryUpdateWithoutProposalInput, HistoryUncheckedUpdateWithoutProposalInput>
    create: XOR<HistoryCreateWithoutProposalInput, HistoryUncheckedCreateWithoutProposalInput>
  }

  export type HistoryUpdateWithWhereUniqueWithoutProposalInput = {
    where: HistoryWhereUniqueInput
    data: XOR<HistoryUpdateWithoutProposalInput, HistoryUncheckedUpdateWithoutProposalInput>
  }

  export type HistoryUpdateManyWithWhereWithoutProposalInput = {
    where: HistoryScalarWhereInput
    data: XOR<HistoryUpdateManyMutationInput, HistoryUncheckedUpdateManyWithoutProposalInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutProposalInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutProposalInput, PaymentUncheckedUpdateWithoutProposalInput>
    create: XOR<PaymentCreateWithoutProposalInput, PaymentUncheckedCreateWithoutProposalInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutProposalInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutProposalInput, PaymentUncheckedUpdateWithoutProposalInput>
  }

  export type PaymentUpdateManyWithWhereWithoutProposalInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutProposalInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    proposalId?: StringFilter<"Payment"> | string
    venueId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"Payment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    imageUrl?: StringNullableFilter<"Payment"> | string | null
  }

  export type DateEventUpsertWithWhereUniqueWithoutProposalInput = {
    where: DateEventWhereUniqueInput
    update: XOR<DateEventUpdateWithoutProposalInput, DateEventUncheckedUpdateWithoutProposalInput>
    create: XOR<DateEventCreateWithoutProposalInput, DateEventUncheckedCreateWithoutProposalInput>
  }

  export type DateEventUpdateWithWhereUniqueWithoutProposalInput = {
    where: DateEventWhereUniqueInput
    data: XOR<DateEventUpdateWithoutProposalInput, DateEventUncheckedUpdateWithoutProposalInput>
  }

  export type DateEventUpdateManyWithWhereWithoutProposalInput = {
    where: DateEventScalarWhereInput
    data: XOR<DateEventUpdateManyMutationInput, DateEventUncheckedUpdateManyWithoutProposalInput>
  }

  export type DateEventScalarWhereInput = {
    AND?: DateEventScalarWhereInput | DateEventScalarWhereInput[]
    OR?: DateEventScalarWhereInput[]
    NOT?: DateEventScalarWhereInput | DateEventScalarWhereInput[]
    id?: StringFilter<"DateEvent"> | string
    title?: StringFilter<"DateEvent"> | string
    startDate?: DateTimeFilter<"DateEvent"> | Date | string
    endDate?: DateTimeFilter<"DateEvent"> | Date | string
    createdAt?: DateTimeFilter<"DateEvent"> | Date | string
    updatedAt?: DateTimeFilter<"DateEvent"> | Date | string
    proposalId?: StringNullableFilter<"DateEvent"> | string | null
    venueId?: StringFilter<"DateEvent"> | string
    type?: EnumDateEventTypeFilter<"DateEvent"> | $Enums.DateEventType
  }

  export type ProposalCostUpsertWithWhereUniqueWithoutProposalsInput = {
    where: ProposalCostWhereUniqueInput
    update: XOR<ProposalCostUpdateWithoutProposalsInput, ProposalCostUncheckedUpdateWithoutProposalsInput>
    create: XOR<ProposalCostCreateWithoutProposalsInput, ProposalCostUncheckedCreateWithoutProposalsInput>
  }

  export type ProposalCostUpdateWithWhereUniqueWithoutProposalsInput = {
    where: ProposalCostWhereUniqueInput
    data: XOR<ProposalCostUpdateWithoutProposalsInput, ProposalCostUncheckedUpdateWithoutProposalsInput>
  }

  export type ProposalCostUpdateManyWithWhereWithoutProposalsInput = {
    where: ProposalCostScalarWhereInput
    data: XOR<ProposalCostUpdateManyMutationInput, ProposalCostUncheckedUpdateManyWithoutProposalsInput>
  }

  export type ProposalCostScalarWhereInput = {
    AND?: ProposalCostScalarWhereInput | ProposalCostScalarWhereInput[]
    OR?: ProposalCostScalarWhereInput[]
    NOT?: ProposalCostScalarWhereInput | ProposalCostScalarWhereInput[]
    id?: StringFilter<"ProposalCost"> | string
    name?: EnumProposalNameFilter<"ProposalCost"> | $Enums.ProposalName
    teste?: StringFilter<"ProposalCost"> | string
    amount?: FloatFilter<"ProposalCost"> | number
    updatedAt?: DateTimeFilter<"ProposalCost"> | Date | string
    createdAt?: DateTimeFilter<"ProposalCost"> | Date | string
  }

  export type ProposalServiceUpsertWithWhereUniqueWithoutProposalInput = {
    where: ProposalServiceWhereUniqueInput
    update: XOR<ProposalServiceUpdateWithoutProposalInput, ProposalServiceUncheckedUpdateWithoutProposalInput>
    create: XOR<ProposalServiceCreateWithoutProposalInput, ProposalServiceUncheckedCreateWithoutProposalInput>
  }

  export type ProposalServiceUpdateWithWhereUniqueWithoutProposalInput = {
    where: ProposalServiceWhereUniqueInput
    data: XOR<ProposalServiceUpdateWithoutProposalInput, ProposalServiceUncheckedUpdateWithoutProposalInput>
  }

  export type ProposalServiceUpdateManyWithWhereWithoutProposalInput = {
    where: ProposalServiceScalarWhereInput
    data: XOR<ProposalServiceUpdateManyMutationInput, ProposalServiceUncheckedUpdateManyWithoutProposalInput>
  }

  export type ProposalServiceScalarWhereInput = {
    AND?: ProposalServiceScalarWhereInput | ProposalServiceScalarWhereInput[]
    OR?: ProposalServiceScalarWhereInput[]
    NOT?: ProposalServiceScalarWhereInput | ProposalServiceScalarWhereInput[]
    id?: StringFilter<"ProposalService"> | string
    proposalId?: StringFilter<"ProposalService"> | string
    serviceId?: StringFilter<"ProposalService"> | string
    joinedAt?: DateTimeFilter<"ProposalService"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutProposalInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutProposalInput, NotificationUncheckedUpdateWithoutProposalInput>
    create: XOR<NotificationCreateWithoutProposalInput, NotificationUncheckedCreateWithoutProposalInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutProposalInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutProposalInput, NotificationUncheckedUpdateWithoutProposalInput>
  }

  export type NotificationUpdateManyWithWhereWithoutProposalInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutProposalInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    venueId?: StringFilter<"Notification"> | string
    proposalId?: StringNullableFilter<"Notification"> | string | null
    dateEventId?: StringNullableFilter<"Notification"> | string | null
    content?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isRead?: BoolFilter<"Notification"> | boolean
  }

  export type ScheduleUpsertWithWhereUniqueWithoutProposalInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutProposalInput, ScheduleUncheckedUpdateWithoutProposalInput>
    create: XOR<ScheduleCreateWithoutProposalInput, ScheduleUncheckedCreateWithoutProposalInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutProposalInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutProposalInput, ScheduleUncheckedUpdateWithoutProposalInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutProposalInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutProposalInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    workerNumber?: IntFilter<"Schedule"> | number
    description?: StringNullableFilter<"Schedule"> | string | null
    startHour?: DateTimeFilter<"Schedule"> | Date | string
    endHour?: DateTimeFilter<"Schedule"> | Date | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    proposalId?: StringFilter<"Schedule"> | string
  }

  export type UserCreateWithoutHistoriesInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
    session?: SessionCreateNestedManyWithoutUserInput
    refreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    userOrganizations?: UserOrganizationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHistoriesInput = {
    id?: string
    email: string
    username: string
    password: string
    avatarUrl?: string | null
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    refreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    userOrganizations?: UserOrganizationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHistoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHistoriesInput, UserUncheckedCreateWithoutHistoriesInput>
  }

  export type ProposalCreateWithoutHistoriesInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venue: VenueCreateNestedOneWithoutProposalsInput
    personList?: PersonCreateNestedManyWithoutProposalInput
    payments?: PaymentCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceCreateNestedManyWithoutProposalInput
    noificationList?: NotificationCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutHistoriesInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venueId: string
    personList?: PersonUncheckedCreateNestedManyWithoutProposalInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventUncheckedCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostUncheckedCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutProposalInput
    noificationList?: NotificationUncheckedCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutHistoriesInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutHistoriesInput, ProposalUncheckedCreateWithoutHistoriesInput>
  }

  export type UserUpsertWithoutHistoriesInput = {
    update: XOR<UserUpdateWithoutHistoriesInput, UserUncheckedUpdateWithoutHistoriesInput>
    create: XOR<UserCreateWithoutHistoriesInput, UserUncheckedCreateWithoutHistoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHistoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHistoriesInput, UserUncheckedUpdateWithoutHistoriesInput>
  }

  export type UserUpdateWithoutHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUpdateManyWithoutUserNestedInput
    refreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    userOrganizations?: UserOrganizationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    refreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    userOrganizations?: UserOrganizationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProposalUpsertWithoutHistoriesInput = {
    update: XOR<ProposalUpdateWithoutHistoriesInput, ProposalUncheckedUpdateWithoutHistoriesInput>
    create: XOR<ProposalCreateWithoutHistoriesInput, ProposalUncheckedCreateWithoutHistoriesInput>
    where?: ProposalWhereInput
  }

  export type ProposalUpdateToOneWithWhereWithoutHistoriesInput = {
    where?: ProposalWhereInput
    data: XOR<ProposalUpdateWithoutHistoriesInput, ProposalUncheckedUpdateWithoutHistoriesInput>
  }

  export type ProposalUpdateWithoutHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venue?: VenueUpdateOneRequiredWithoutProposalsNestedInput
    personList?: PersonUpdateManyWithoutProposalNestedInput
    payments?: PaymentUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
    personList?: PersonUncheckedUpdateManyWithoutProposalNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUncheckedUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUncheckedUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUncheckedUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalCreateWithoutPersonListInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venue: VenueCreateNestedOneWithoutProposalsInput
    histories?: HistoryCreateNestedManyWithoutProposalInput
    payments?: PaymentCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceCreateNestedManyWithoutProposalInput
    noificationList?: NotificationCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutPersonListInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venueId: string
    histories?: HistoryUncheckedCreateNestedManyWithoutProposalInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventUncheckedCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostUncheckedCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutProposalInput
    noificationList?: NotificationUncheckedCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutPersonListInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutPersonListInput, ProposalUncheckedCreateWithoutPersonListInput>
  }

  export type ProposalUpsertWithoutPersonListInput = {
    update: XOR<ProposalUpdateWithoutPersonListInput, ProposalUncheckedUpdateWithoutPersonListInput>
    create: XOR<ProposalCreateWithoutPersonListInput, ProposalUncheckedCreateWithoutPersonListInput>
    where?: ProposalWhereInput
  }

  export type ProposalUpdateToOneWithWhereWithoutPersonListInput = {
    where?: ProposalWhereInput
    data: XOR<ProposalUpdateWithoutPersonListInput, ProposalUncheckedUpdateWithoutPersonListInput>
  }

  export type ProposalUpdateWithoutPersonListInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venue?: VenueUpdateOneRequiredWithoutProposalsNestedInput
    histories?: HistoryUpdateManyWithoutProposalNestedInput
    payments?: PaymentUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutPersonListInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
    histories?: HistoryUncheckedUpdateManyWithoutProposalNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUncheckedUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUncheckedUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUncheckedUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ServiceCreateWithoutProposalServicesInput = {
    id?: string
    name: string
    price: number
    venue: VenueCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutProposalServicesInput = {
    id?: string
    name: string
    price: number
    venueId: string
  }

  export type ServiceCreateOrConnectWithoutProposalServicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutProposalServicesInput, ServiceUncheckedCreateWithoutProposalServicesInput>
  }

  export type ProposalCreateWithoutProposalServicesInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venue: VenueCreateNestedOneWithoutProposalsInput
    personList?: PersonCreateNestedManyWithoutProposalInput
    histories?: HistoryCreateNestedManyWithoutProposalInput
    payments?: PaymentCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostCreateNestedManyWithoutProposalsInput
    noificationList?: NotificationCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutProposalServicesInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venueId: string
    personList?: PersonUncheckedCreateNestedManyWithoutProposalInput
    histories?: HistoryUncheckedCreateNestedManyWithoutProposalInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventUncheckedCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostUncheckedCreateNestedManyWithoutProposalsInput
    noificationList?: NotificationUncheckedCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutProposalServicesInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutProposalServicesInput, ProposalUncheckedCreateWithoutProposalServicesInput>
  }

  export type ServiceUpsertWithoutProposalServicesInput = {
    update: XOR<ServiceUpdateWithoutProposalServicesInput, ServiceUncheckedUpdateWithoutProposalServicesInput>
    create: XOR<ServiceCreateWithoutProposalServicesInput, ServiceUncheckedCreateWithoutProposalServicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutProposalServicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutProposalServicesInput, ServiceUncheckedUpdateWithoutProposalServicesInput>
  }

  export type ServiceUpdateWithoutProposalServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    venue?: VenueUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutProposalServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalUpsertWithoutProposalServicesInput = {
    update: XOR<ProposalUpdateWithoutProposalServicesInput, ProposalUncheckedUpdateWithoutProposalServicesInput>
    create: XOR<ProposalCreateWithoutProposalServicesInput, ProposalUncheckedCreateWithoutProposalServicesInput>
    where?: ProposalWhereInput
  }

  export type ProposalUpdateToOneWithWhereWithoutProposalServicesInput = {
    where?: ProposalWhereInput
    data: XOR<ProposalUpdateWithoutProposalServicesInput, ProposalUncheckedUpdateWithoutProposalServicesInput>
  }

  export type ProposalUpdateWithoutProposalServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venue?: VenueUpdateOneRequiredWithoutProposalsNestedInput
    personList?: PersonUpdateManyWithoutProposalNestedInput
    histories?: HistoryUpdateManyWithoutProposalNestedInput
    payments?: PaymentUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUpdateManyWithoutProposalsNestedInput
    noificationList?: NotificationUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutProposalServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
    personList?: PersonUncheckedUpdateManyWithoutProposalNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutProposalNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUncheckedUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUncheckedUpdateManyWithoutProposalsNestedInput
    noificationList?: NotificationUncheckedUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalServiceCreateWithoutServiceInput = {
    id?: string
    joinedAt?: Date | string
    proposal: ProposalCreateNestedOneWithoutProposalServicesInput
  }

  export type ProposalServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    proposalId: string
    joinedAt?: Date | string
  }

  export type ProposalServiceCreateOrConnectWithoutServiceInput = {
    where: ProposalServiceWhereUniqueInput
    create: XOR<ProposalServiceCreateWithoutServiceInput, ProposalServiceUncheckedCreateWithoutServiceInput>
  }

  export type ProposalServiceCreateManyServiceInputEnvelope = {
    data: ProposalServiceCreateManyServiceInput | ProposalServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type VenueCreateWithoutServicesInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutServicesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutServicesInput, VenueUncheckedCreateWithoutServicesInput>
  }

  export type ProposalServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: ProposalServiceWhereUniqueInput
    update: XOR<ProposalServiceUpdateWithoutServiceInput, ProposalServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<ProposalServiceCreateWithoutServiceInput, ProposalServiceUncheckedCreateWithoutServiceInput>
  }

  export type ProposalServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: ProposalServiceWhereUniqueInput
    data: XOR<ProposalServiceUpdateWithoutServiceInput, ProposalServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ProposalServiceUpdateManyWithWhereWithoutServiceInput = {
    where: ProposalServiceScalarWhereInput
    data: XOR<ProposalServiceUpdateManyMutationInput, ProposalServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type VenueUpsertWithoutServicesInput = {
    update: XOR<VenueUpdateWithoutServicesInput, VenueUncheckedUpdateWithoutServicesInput>
    create: XOR<VenueCreateWithoutServicesInput, VenueUncheckedCreateWithoutServicesInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutServicesInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutServicesInput, VenueUncheckedUpdateWithoutServicesInput>
  }

  export type VenueUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type ProposalCreateWithoutPaymentsInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venue: VenueCreateNestedOneWithoutProposalsInput
    personList?: PersonCreateNestedManyWithoutProposalInput
    histories?: HistoryCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceCreateNestedManyWithoutProposalInput
    noificationList?: NotificationCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutPaymentsInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venueId: string
    personList?: PersonUncheckedCreateNestedManyWithoutProposalInput
    histories?: HistoryUncheckedCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventUncheckedCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostUncheckedCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutProposalInput
    noificationList?: NotificationUncheckedCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutPaymentsInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutPaymentsInput, ProposalUncheckedCreateWithoutPaymentsInput>
  }

  export type VenueCreateWithoutPaymentInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutPaymentInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutPaymentInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutPaymentInput, VenueUncheckedCreateWithoutPaymentInput>
  }

  export type ProposalUpsertWithoutPaymentsInput = {
    update: XOR<ProposalUpdateWithoutPaymentsInput, ProposalUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ProposalCreateWithoutPaymentsInput, ProposalUncheckedCreateWithoutPaymentsInput>
    where?: ProposalWhereInput
  }

  export type ProposalUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ProposalWhereInput
    data: XOR<ProposalUpdateWithoutPaymentsInput, ProposalUncheckedUpdateWithoutPaymentsInput>
  }

  export type ProposalUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venue?: VenueUpdateOneRequiredWithoutProposalsNestedInput
    personList?: PersonUpdateManyWithoutProposalNestedInput
    histories?: HistoryUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
    personList?: PersonUncheckedUpdateManyWithoutProposalNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUncheckedUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUncheckedUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUncheckedUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type VenueUpsertWithoutPaymentInput = {
    update: XOR<VenueUpdateWithoutPaymentInput, VenueUncheckedUpdateWithoutPaymentInput>
    create: XOR<VenueCreateWithoutPaymentInput, VenueUncheckedCreateWithoutPaymentInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutPaymentInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutPaymentInput, VenueUncheckedUpdateWithoutPaymentInput>
  }

  export type VenueUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type ProposalCreateWithoutProposalCostsInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venue: VenueCreateNestedOneWithoutProposalsInput
    personList?: PersonCreateNestedManyWithoutProposalInput
    histories?: HistoryCreateNestedManyWithoutProposalInput
    payments?: PaymentCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventCreateNestedManyWithoutProposalInput
    proposalServices?: ProposalServiceCreateNestedManyWithoutProposalInput
    noificationList?: NotificationCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutProposalCostsInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venueId: string
    personList?: PersonUncheckedCreateNestedManyWithoutProposalInput
    histories?: HistoryUncheckedCreateNestedManyWithoutProposalInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventUncheckedCreateNestedManyWithoutProposalInput
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutProposalInput
    noificationList?: NotificationUncheckedCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutProposalCostsInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutProposalCostsInput, ProposalUncheckedCreateWithoutProposalCostsInput>
  }

  export type ProposalUpsertWithWhereUniqueWithoutProposalCostsInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutProposalCostsInput, ProposalUncheckedUpdateWithoutProposalCostsInput>
    create: XOR<ProposalCreateWithoutProposalCostsInput, ProposalUncheckedCreateWithoutProposalCostsInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutProposalCostsInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutProposalCostsInput, ProposalUncheckedUpdateWithoutProposalCostsInput>
  }

  export type ProposalUpdateManyWithWhereWithoutProposalCostsInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutProposalCostsInput>
  }

  export type ProposalScalarWhereInput = {
    AND?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    OR?: ProposalScalarWhereInput[]
    NOT?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    id?: StringFilter<"Proposal"> | string
    completeName?: StringNullableFilter<"Proposal"> | string | null
    cpf?: StringNullableFilter<"Proposal"> | string | null
    rg?: StringNullableFilter<"Proposal"> | string | null
    street?: StringNullableFilter<"Proposal"> | string | null
    streetNumber?: StringNullableFilter<"Proposal"> | string | null
    neighborhood?: StringNullableFilter<"Proposal"> | string | null
    cep?: StringNullableFilter<"Proposal"> | string | null
    city?: StringNullableFilter<"Proposal"> | string | null
    state?: StringNullableFilter<"Proposal"> | string | null
    type?: EnumProposalTypeFilter<"Proposal"> | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFilter<"Proposal"> | $Enums.TrafficSource
    guestNumber?: IntFilter<"Proposal"> | number
    knowsVenue?: BoolFilter<"Proposal"> | boolean
    startDate?: DateTimeFilter<"Proposal"> | Date | string
    endDate?: DateTimeFilter<"Proposal"> | Date | string
    name?: StringFilter<"Proposal"> | string
    email?: StringFilter<"Proposal"> | string
    whatsapp?: StringFilter<"Proposal"> | string
    description?: StringFilter<"Proposal"> | string
    basePrice?: FloatFilter<"Proposal"> | number
    extraHoursQty?: IntFilter<"Proposal"> | number
    extraHourPrice?: FloatFilter<"Proposal"> | number
    totalAmount?: FloatFilter<"Proposal"> | number
    termsAccepted?: BoolFilter<"Proposal"> | boolean
    approved?: BoolFilter<"Proposal"> | boolean
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    contact?: BoolNullableFilter<"Proposal"> | boolean | null
    paid?: BoolNullableFilter<"Proposal"> | boolean | null
    amountPaid?: FloatNullableFilter<"Proposal"> | number | null
    venueId?: StringFilter<"Proposal"> | string
  }

  export type VenueCreateWithoutExpensesInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutExpensesInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutExpensesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutExpensesInput, VenueUncheckedCreateWithoutExpensesInput>
  }

  export type VenueUpsertWithoutExpensesInput = {
    update: XOR<VenueUpdateWithoutExpensesInput, VenueUncheckedUpdateWithoutExpensesInput>
    create: XOR<VenueCreateWithoutExpensesInput, VenueUncheckedCreateWithoutExpensesInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutExpensesInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutExpensesInput, VenueUncheckedUpdateWithoutExpensesInput>
  }

  export type VenueUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateWithoutNotificationsInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutNotificationsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutNotificationsInput, VenueUncheckedCreateWithoutNotificationsInput>
  }

  export type ProposalCreateWithoutNoificationListInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venue: VenueCreateNestedOneWithoutProposalsInput
    personList?: PersonCreateNestedManyWithoutProposalInput
    histories?: HistoryCreateNestedManyWithoutProposalInput
    payments?: PaymentCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutNoificationListInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venueId: string
    personList?: PersonUncheckedCreateNestedManyWithoutProposalInput
    histories?: HistoryUncheckedCreateNestedManyWithoutProposalInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventUncheckedCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostUncheckedCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutNoificationListInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutNoificationListInput, ProposalUncheckedCreateWithoutNoificationListInput>
  }

  export type DateEventCreateWithoutNotificationsInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.DateEventType
    venue: VenueCreateNestedOneWithoutDateEventInput
    proposal?: ProposalCreateNestedOneWithoutDateEventsInput
  }

  export type DateEventUncheckedCreateWithoutNotificationsInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalId?: string | null
    venueId: string
    type: $Enums.DateEventType
  }

  export type DateEventCreateOrConnectWithoutNotificationsInput = {
    where: DateEventWhereUniqueInput
    create: XOR<DateEventCreateWithoutNotificationsInput, DateEventUncheckedCreateWithoutNotificationsInput>
  }

  export type VenueUpsertWithoutNotificationsInput = {
    update: XOR<VenueUpdateWithoutNotificationsInput, VenueUncheckedUpdateWithoutNotificationsInput>
    create: XOR<VenueCreateWithoutNotificationsInput, VenueUncheckedCreateWithoutNotificationsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutNotificationsInput, VenueUncheckedUpdateWithoutNotificationsInput>
  }

  export type VenueUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type ProposalUpsertWithoutNoificationListInput = {
    update: XOR<ProposalUpdateWithoutNoificationListInput, ProposalUncheckedUpdateWithoutNoificationListInput>
    create: XOR<ProposalCreateWithoutNoificationListInput, ProposalUncheckedCreateWithoutNoificationListInput>
    where?: ProposalWhereInput
  }

  export type ProposalUpdateToOneWithWhereWithoutNoificationListInput = {
    where?: ProposalWhereInput
    data: XOR<ProposalUpdateWithoutNoificationListInput, ProposalUncheckedUpdateWithoutNoificationListInput>
  }

  export type ProposalUpdateWithoutNoificationListInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venue?: VenueUpdateOneRequiredWithoutProposalsNestedInput
    personList?: PersonUpdateManyWithoutProposalNestedInput
    histories?: HistoryUpdateManyWithoutProposalNestedInput
    payments?: PaymentUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutNoificationListInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
    personList?: PersonUncheckedUpdateManyWithoutProposalNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutProposalNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUncheckedUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUncheckedUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type DateEventUpsertWithoutNotificationsInput = {
    update: XOR<DateEventUpdateWithoutNotificationsInput, DateEventUncheckedUpdateWithoutNotificationsInput>
    create: XOR<DateEventCreateWithoutNotificationsInput, DateEventUncheckedCreateWithoutNotificationsInput>
    where?: DateEventWhereInput
  }

  export type DateEventUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: DateEventWhereInput
    data: XOR<DateEventUpdateWithoutNotificationsInput, DateEventUncheckedUpdateWithoutNotificationsInput>
  }

  export type DateEventUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
    venue?: VenueUpdateOneRequiredWithoutDateEventNestedInput
    proposal?: ProposalUpdateOneWithoutDateEventsNestedInput
  }

  export type DateEventUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
  }

  export type VenueCreateWithoutDateEventInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutDateEventInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutDateEventInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutDateEventInput, VenueUncheckedCreateWithoutDateEventInput>
  }

  export type ProposalCreateWithoutDateEventsInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venue: VenueCreateNestedOneWithoutProposalsInput
    personList?: PersonCreateNestedManyWithoutProposalInput
    histories?: HistoryCreateNestedManyWithoutProposalInput
    payments?: PaymentCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceCreateNestedManyWithoutProposalInput
    noificationList?: NotificationCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutDateEventsInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venueId: string
    personList?: PersonUncheckedCreateNestedManyWithoutProposalInput
    histories?: HistoryUncheckedCreateNestedManyWithoutProposalInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostUncheckedCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutProposalInput
    noificationList?: NotificationUncheckedCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutDateEventsInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutDateEventsInput, ProposalUncheckedCreateWithoutDateEventsInput>
  }

  export type NotificationCreateWithoutDateEventInput = {
    id?: string
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
    venue: VenueCreateNestedOneWithoutNotificationsInput
    proposal?: ProposalCreateNestedOneWithoutNoificationListInput
  }

  export type NotificationUncheckedCreateWithoutDateEventInput = {
    id?: string
    venueId: string
    proposalId?: string | null
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
  }

  export type NotificationCreateOrConnectWithoutDateEventInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutDateEventInput, NotificationUncheckedCreateWithoutDateEventInput>
  }

  export type NotificationCreateManyDateEventInputEnvelope = {
    data: NotificationCreateManyDateEventInput | NotificationCreateManyDateEventInput[]
    skipDuplicates?: boolean
  }

  export type VenueUpsertWithoutDateEventInput = {
    update: XOR<VenueUpdateWithoutDateEventInput, VenueUncheckedUpdateWithoutDateEventInput>
    create: XOR<VenueCreateWithoutDateEventInput, VenueUncheckedCreateWithoutDateEventInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutDateEventInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutDateEventInput, VenueUncheckedUpdateWithoutDateEventInput>
  }

  export type VenueUpdateWithoutDateEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutDateEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type ProposalUpsertWithoutDateEventsInput = {
    update: XOR<ProposalUpdateWithoutDateEventsInput, ProposalUncheckedUpdateWithoutDateEventsInput>
    create: XOR<ProposalCreateWithoutDateEventsInput, ProposalUncheckedCreateWithoutDateEventsInput>
    where?: ProposalWhereInput
  }

  export type ProposalUpdateToOneWithWhereWithoutDateEventsInput = {
    where?: ProposalWhereInput
    data: XOR<ProposalUpdateWithoutDateEventsInput, ProposalUncheckedUpdateWithoutDateEventsInput>
  }

  export type ProposalUpdateWithoutDateEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venue?: VenueUpdateOneRequiredWithoutProposalsNestedInput
    personList?: PersonUpdateManyWithoutProposalNestedInput
    histories?: HistoryUpdateManyWithoutProposalNestedInput
    payments?: PaymentUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutDateEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
    personList?: PersonUncheckedUpdateManyWithoutProposalNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutProposalNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUncheckedUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUncheckedUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutDateEventInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutDateEventInput, NotificationUncheckedUpdateWithoutDateEventInput>
    create: XOR<NotificationCreateWithoutDateEventInput, NotificationUncheckedCreateWithoutDateEventInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutDateEventInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutDateEventInput, NotificationUncheckedUpdateWithoutDateEventInput>
  }

  export type NotificationUpdateManyWithWhereWithoutDateEventInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutDateEventInput>
  }

  export type OrganizationCreateWithoutVenuesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    owners?: OwnerCreateNestedManyWithoutOrganizationInput
    userOrganizations?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Clause?: ClauseCreateNestedManyWithoutOrganizationInput
    Contract?: ContractCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutVenuesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    owners?: OwnerUncheckedCreateNestedManyWithoutOrganizationInput
    userOrganizations?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Clause?: ClauseUncheckedCreateNestedManyWithoutOrganizationInput
    Contract?: ContractUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutVenuesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutVenuesInput, OrganizationUncheckedCreateWithoutVenuesInput>
  }

  export type TextCreateWithoutVenueInput = {
    id?: string
    area: string
    title?: string | null
    position?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextUncheckedCreateWithoutVenueInput = {
    id?: string
    area: string
    title?: string | null
    position?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextCreateOrConnectWithoutVenueInput = {
    where: TextWhereUniqueInput
    create: XOR<TextCreateWithoutVenueInput, TextUncheckedCreateWithoutVenueInput>
  }

  export type TextCreateManyVenueInputEnvelope = {
    data: TextCreateManyVenueInput | TextCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutVenueInput = {
    id?: string
    name: string
    role: string
    whatsapp: string
  }

  export type ContactUncheckedCreateWithoutVenueInput = {
    id?: string
    name: string
    role: string
    whatsapp: string
  }

  export type ContactCreateOrConnectWithoutVenueInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutVenueInput, ContactUncheckedCreateWithoutVenueInput>
  }

  export type ContactCreateManyVenueInputEnvelope = {
    data: ContactCreateManyVenueInput | ContactCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ImageCreateWithoutVenueInput = {
    id?: string
    imageUrl: string
    description?: string | null
    position: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    responsiveMode?: string | null
    tag?: string | null
  }

  export type ImageUncheckedCreateWithoutVenueInput = {
    id?: string
    imageUrl: string
    description?: string | null
    position: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    responsiveMode?: string | null
    tag?: string | null
  }

  export type ImageCreateOrConnectWithoutVenueInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutVenueInput, ImageUncheckedCreateWithoutVenueInput>
  }

  export type ImageCreateManyVenueInputEnvelope = {
    data: ImageCreateManyVenueInput | ImageCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutVenueInput = {
    id?: string
    name: string
    description?: string | null
    amount: number
    paymentDate: Date | string
    type: $Enums.ExpenseType
    category: $Enums.ExpenseCategory
    recurring: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUncheckedCreateWithoutVenueInput = {
    id?: string
    name: string
    description?: string | null
    amount: number
    paymentDate: Date | string
    type: $Enums.ExpenseType
    category: $Enums.ExpenseCategory
    recurring: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutVenueInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutVenueInput, ExpenseUncheckedCreateWithoutVenueInput>
  }

  export type ExpenseCreateManyVenueInputEnvelope = {
    data: ExpenseCreateManyVenueInput | ExpenseCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutVenueInput = {
    id?: string
    name: string
    price: number
    proposalServices?: ProposalServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutVenueInput = {
    id?: string
    name: string
    price: number
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutVenueInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutVenueInput, ServiceUncheckedCreateWithoutVenueInput>
  }

  export type ServiceCreateManyVenueInputEnvelope = {
    data: ServiceCreateManyVenueInput | ServiceCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutVenueInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
    proposal: ProposalCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutVenueInput = {
    id?: string
    proposalId: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
  }

  export type PaymentCreateOrConnectWithoutVenueInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutVenueInput, PaymentUncheckedCreateWithoutVenueInput>
  }

  export type PaymentCreateManyVenueInputEnvelope = {
    data: PaymentCreateManyVenueInput | PaymentCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutVenueInput = {
    id?: string
    question: string
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUncheckedCreateWithoutVenueInput = {
    id?: string
    question: string
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCreateOrConnectWithoutVenueInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutVenueInput, QuestionUncheckedCreateWithoutVenueInput>
  }

  export type QuestionCreateManyVenueInputEnvelope = {
    data: QuestionCreateManyVenueInput | QuestionCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutVenueInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    personList?: PersonCreateNestedManyWithoutProposalInput
    histories?: HistoryCreateNestedManyWithoutProposalInput
    payments?: PaymentCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceCreateNestedManyWithoutProposalInput
    noificationList?: NotificationCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutVenueInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    personList?: PersonUncheckedCreateNestedManyWithoutProposalInput
    histories?: HistoryUncheckedCreateNestedManyWithoutProposalInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventUncheckedCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostUncheckedCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutProposalInput
    noificationList?: NotificationUncheckedCreateNestedManyWithoutProposalInput
    scheduleList?: ScheduleUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutVenueInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutVenueInput, ProposalUncheckedCreateWithoutVenueInput>
  }

  export type ProposalCreateManyVenueInputEnvelope = {
    data: ProposalCreateManyVenueInput | ProposalCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type DateEventCreateWithoutVenueInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.DateEventType
    proposal?: ProposalCreateNestedOneWithoutDateEventsInput
    notifications?: NotificationCreateNestedManyWithoutDateEventInput
  }

  export type DateEventUncheckedCreateWithoutVenueInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalId?: string | null
    type: $Enums.DateEventType
    notifications?: NotificationUncheckedCreateNestedManyWithoutDateEventInput
  }

  export type DateEventCreateOrConnectWithoutVenueInput = {
    where: DateEventWhereUniqueInput
    create: XOR<DateEventCreateWithoutVenueInput, DateEventUncheckedCreateWithoutVenueInput>
  }

  export type DateEventCreateManyVenueInputEnvelope = {
    data: DateEventCreateManyVenueInput | DateEventCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type OwnerVenueCreateWithoutVenueInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutOwnerVenueInput
  }

  export type OwnerVenueUncheckedCreateWithoutVenueInput = {
    id?: string
    ownerId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type OwnerVenueCreateOrConnectWithoutVenueInput = {
    where: OwnerVenueWhereUniqueInput
    create: XOR<OwnerVenueCreateWithoutVenueInput, OwnerVenueUncheckedCreateWithoutVenueInput>
  }

  export type OwnerVenueCreateManyVenueInputEnvelope = {
    data: OwnerVenueCreateManyVenueInput | OwnerVenueCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutVenueInput = {
    id?: string
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
    proposal?: ProposalCreateNestedOneWithoutNoificationListInput
    dateEvent?: DateEventCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutVenueInput = {
    id?: string
    proposalId?: string | null
    dateEventId?: string | null
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
  }

  export type NotificationCreateOrConnectWithoutVenueInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutVenueInput, NotificationUncheckedCreateWithoutVenueInput>
  }

  export type NotificationCreateManyVenueInputEnvelope = {
    data: NotificationCreateManyVenueInput | NotificationCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutVenuesInput = {
    update: XOR<OrganizationUpdateWithoutVenuesInput, OrganizationUncheckedUpdateWithoutVenuesInput>
    create: XOR<OrganizationCreateWithoutVenuesInput, OrganizationUncheckedCreateWithoutVenuesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutVenuesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutVenuesInput, OrganizationUncheckedUpdateWithoutVenuesInput>
  }

  export type OrganizationUpdateWithoutVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: OwnerUpdateManyWithoutOrganizationNestedInput
    userOrganizations?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Clause?: ClauseUpdateManyWithoutOrganizationNestedInput
    Contract?: ContractUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: OwnerUncheckedUpdateManyWithoutOrganizationNestedInput
    userOrganizations?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Clause?: ClauseUncheckedUpdateManyWithoutOrganizationNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TextUpsertWithWhereUniqueWithoutVenueInput = {
    where: TextWhereUniqueInput
    update: XOR<TextUpdateWithoutVenueInput, TextUncheckedUpdateWithoutVenueInput>
    create: XOR<TextCreateWithoutVenueInput, TextUncheckedCreateWithoutVenueInput>
  }

  export type TextUpdateWithWhereUniqueWithoutVenueInput = {
    where: TextWhereUniqueInput
    data: XOR<TextUpdateWithoutVenueInput, TextUncheckedUpdateWithoutVenueInput>
  }

  export type TextUpdateManyWithWhereWithoutVenueInput = {
    where: TextScalarWhereInput
    data: XOR<TextUpdateManyMutationInput, TextUncheckedUpdateManyWithoutVenueInput>
  }

  export type TextScalarWhereInput = {
    AND?: TextScalarWhereInput | TextScalarWhereInput[]
    OR?: TextScalarWhereInput[]
    NOT?: TextScalarWhereInput | TextScalarWhereInput[]
    id?: StringFilter<"Text"> | string
    area?: StringFilter<"Text"> | string
    title?: StringNullableFilter<"Text"> | string | null
    position?: IntFilter<"Text"> | number
    text?: StringFilter<"Text"> | string
    createdAt?: DateTimeFilter<"Text"> | Date | string
    updatedAt?: DateTimeFilter<"Text"> | Date | string
    venueId?: StringFilter<"Text"> | string
  }

  export type ContactUpsertWithWhereUniqueWithoutVenueInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutVenueInput, ContactUncheckedUpdateWithoutVenueInput>
    create: XOR<ContactCreateWithoutVenueInput, ContactUncheckedCreateWithoutVenueInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutVenueInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutVenueInput, ContactUncheckedUpdateWithoutVenueInput>
  }

  export type ContactUpdateManyWithWhereWithoutVenueInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutVenueInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    role?: StringFilter<"Contact"> | string
    whatsapp?: StringFilter<"Contact"> | string
    venueId?: StringFilter<"Contact"> | string
  }

  export type ImageUpsertWithWhereUniqueWithoutVenueInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutVenueInput, ImageUncheckedUpdateWithoutVenueInput>
    create: XOR<ImageCreateWithoutVenueInput, ImageUncheckedCreateWithoutVenueInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutVenueInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutVenueInput, ImageUncheckedUpdateWithoutVenueInput>
  }

  export type ImageUpdateManyWithWhereWithoutVenueInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutVenueInput>
  }

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[]
    OR?: ImageScalarWhereInput[]
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[]
    id?: StringFilter<"Image"> | string
    imageUrl?: StringFilter<"Image"> | string
    description?: StringNullableFilter<"Image"> | string | null
    position?: IntFilter<"Image"> | number
    createdAt?: DateTimeNullableFilter<"Image"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Image"> | Date | string | null
    responsiveMode?: StringNullableFilter<"Image"> | string | null
    tag?: StringNullableFilter<"Image"> | string | null
    venueId?: StringFilter<"Image"> | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutVenueInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutVenueInput, ExpenseUncheckedUpdateWithoutVenueInput>
    create: XOR<ExpenseCreateWithoutVenueInput, ExpenseUncheckedCreateWithoutVenueInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutVenueInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutVenueInput, ExpenseUncheckedUpdateWithoutVenueInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutVenueInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutVenueInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    name?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    paymentDate?: DateTimeFilter<"Expense"> | Date | string
    type?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    recurring?: BoolFilter<"Expense"> | boolean
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    venueId?: StringFilter<"Expense"> | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutVenueInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutVenueInput, ServiceUncheckedUpdateWithoutVenueInput>
    create: XOR<ServiceCreateWithoutVenueInput, ServiceUncheckedCreateWithoutVenueInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutVenueInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutVenueInput, ServiceUncheckedUpdateWithoutVenueInput>
  }

  export type ServiceUpdateManyWithWhereWithoutVenueInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutVenueInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    price?: FloatFilter<"Service"> | number
    venueId?: StringFilter<"Service"> | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutVenueInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutVenueInput, PaymentUncheckedUpdateWithoutVenueInput>
    create: XOR<PaymentCreateWithoutVenueInput, PaymentUncheckedCreateWithoutVenueInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutVenueInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutVenueInput, PaymentUncheckedUpdateWithoutVenueInput>
  }

  export type PaymentUpdateManyWithWhereWithoutVenueInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutVenueInput>
  }

  export type QuestionUpsertWithWhereUniqueWithoutVenueInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutVenueInput, QuestionUncheckedUpdateWithoutVenueInput>
    create: XOR<QuestionCreateWithoutVenueInput, QuestionUncheckedCreateWithoutVenueInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutVenueInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutVenueInput, QuestionUncheckedUpdateWithoutVenueInput>
  }

  export type QuestionUpdateManyWithWhereWithoutVenueInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutVenueInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    question?: StringFilter<"Question"> | string
    response?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    venueId?: StringFilter<"Question"> | string
  }

  export type ProposalUpsertWithWhereUniqueWithoutVenueInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutVenueInput, ProposalUncheckedUpdateWithoutVenueInput>
    create: XOR<ProposalCreateWithoutVenueInput, ProposalUncheckedCreateWithoutVenueInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutVenueInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutVenueInput, ProposalUncheckedUpdateWithoutVenueInput>
  }

  export type ProposalUpdateManyWithWhereWithoutVenueInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutVenueInput>
  }

  export type DateEventUpsertWithWhereUniqueWithoutVenueInput = {
    where: DateEventWhereUniqueInput
    update: XOR<DateEventUpdateWithoutVenueInput, DateEventUncheckedUpdateWithoutVenueInput>
    create: XOR<DateEventCreateWithoutVenueInput, DateEventUncheckedCreateWithoutVenueInput>
  }

  export type DateEventUpdateWithWhereUniqueWithoutVenueInput = {
    where: DateEventWhereUniqueInput
    data: XOR<DateEventUpdateWithoutVenueInput, DateEventUncheckedUpdateWithoutVenueInput>
  }

  export type DateEventUpdateManyWithWhereWithoutVenueInput = {
    where: DateEventScalarWhereInput
    data: XOR<DateEventUpdateManyMutationInput, DateEventUncheckedUpdateManyWithoutVenueInput>
  }

  export type OwnerVenueUpsertWithWhereUniqueWithoutVenueInput = {
    where: OwnerVenueWhereUniqueInput
    update: XOR<OwnerVenueUpdateWithoutVenueInput, OwnerVenueUncheckedUpdateWithoutVenueInput>
    create: XOR<OwnerVenueCreateWithoutVenueInput, OwnerVenueUncheckedCreateWithoutVenueInput>
  }

  export type OwnerVenueUpdateWithWhereUniqueWithoutVenueInput = {
    where: OwnerVenueWhereUniqueInput
    data: XOR<OwnerVenueUpdateWithoutVenueInput, OwnerVenueUncheckedUpdateWithoutVenueInput>
  }

  export type OwnerVenueUpdateManyWithWhereWithoutVenueInput = {
    where: OwnerVenueScalarWhereInput
    data: XOR<OwnerVenueUpdateManyMutationInput, OwnerVenueUncheckedUpdateManyWithoutVenueInput>
  }

  export type OwnerVenueScalarWhereInput = {
    AND?: OwnerVenueScalarWhereInput | OwnerVenueScalarWhereInput[]
    OR?: OwnerVenueScalarWhereInput[]
    NOT?: OwnerVenueScalarWhereInput | OwnerVenueScalarWhereInput[]
    id?: StringFilter<"OwnerVenue"> | string
    ownerId?: StringFilter<"OwnerVenue"> | string
    venueId?: StringFilter<"OwnerVenue"> | string
    role?: EnumRoleFilter<"OwnerVenue"> | $Enums.Role
    joinedAt?: DateTimeFilter<"OwnerVenue"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutVenueInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutVenueInput, NotificationUncheckedUpdateWithoutVenueInput>
    create: XOR<NotificationCreateWithoutVenueInput, NotificationUncheckedCreateWithoutVenueInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutVenueInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutVenueInput, NotificationUncheckedUpdateWithoutVenueInput>
  }

  export type NotificationUpdateManyWithWhereWithoutVenueInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutVenueInput>
  }

  export type VenueCreateWithoutContactsInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutContactsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutContactsInput, VenueUncheckedCreateWithoutContactsInput>
  }

  export type VenueUpsertWithoutContactsInput = {
    update: XOR<VenueUpdateWithoutContactsInput, VenueUncheckedUpdateWithoutContactsInput>
    create: XOR<VenueCreateWithoutContactsInput, VenueUncheckedCreateWithoutContactsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutContactsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutContactsInput, VenueUncheckedUpdateWithoutContactsInput>
  }

  export type VenueUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type OwnerCreateWithoutOwnerVenueInput = {
    id?: string
    completeName: string
    rg?: string | null
    cpf: string
    pix: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    bankName: string
    bankAgency: string
    cep: string
    createdAt?: Date | string
    bankAccountNumber: string
    organization: OrganizationCreateNestedOneWithoutOwnersInput
  }

  export type OwnerUncheckedCreateWithoutOwnerVenueInput = {
    id?: string
    completeName: string
    rg?: string | null
    cpf: string
    pix: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    bankName: string
    bankAgency: string
    cep: string
    createdAt?: Date | string
    bankAccountNumber: string
    organizationId: string
  }

  export type OwnerCreateOrConnectWithoutOwnerVenueInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutOwnerVenueInput, OwnerUncheckedCreateWithoutOwnerVenueInput>
  }

  export type VenueCreateWithoutOwnerVenueInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutOwnerVenueInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutOwnerVenueInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutOwnerVenueInput, VenueUncheckedCreateWithoutOwnerVenueInput>
  }

  export type OwnerUpsertWithoutOwnerVenueInput = {
    update: XOR<OwnerUpdateWithoutOwnerVenueInput, OwnerUncheckedUpdateWithoutOwnerVenueInput>
    create: XOR<OwnerCreateWithoutOwnerVenueInput, OwnerUncheckedCreateWithoutOwnerVenueInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutOwnerVenueInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutOwnerVenueInput, OwnerUncheckedUpdateWithoutOwnerVenueInput>
  }

  export type OwnerUpdateWithoutOwnerVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: StringFieldUpdateOperationsInput | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: StringFieldUpdateOperationsInput | string
    pix?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAgency?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutOwnersNestedInput
  }

  export type OwnerUncheckedUpdateWithoutOwnerVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: StringFieldUpdateOperationsInput | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: StringFieldUpdateOperationsInput | string
    pix?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAgency?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type VenueUpsertWithoutOwnerVenueInput = {
    update: XOR<VenueUpdateWithoutOwnerVenueInput, VenueUncheckedUpdateWithoutOwnerVenueInput>
    create: XOR<VenueCreateWithoutOwnerVenueInput, VenueUncheckedCreateWithoutOwnerVenueInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutOwnerVenueInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutOwnerVenueInput, VenueUncheckedUpdateWithoutOwnerVenueInput>
  }

  export type VenueUpdateWithoutOwnerVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutOwnerVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type OwnerVenueCreateWithoutOwnerInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    venue: VenueCreateNestedOneWithoutOwnerVenueInput
  }

  export type OwnerVenueUncheckedCreateWithoutOwnerInput = {
    id?: string
    venueId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type OwnerVenueCreateOrConnectWithoutOwnerInput = {
    where: OwnerVenueWhereUniqueInput
    create: XOR<OwnerVenueCreateWithoutOwnerInput, OwnerVenueUncheckedCreateWithoutOwnerInput>
  }

  export type OwnerVenueCreateManyOwnerInputEnvelope = {
    data: OwnerVenueCreateManyOwnerInput | OwnerVenueCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutOwnersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    venues?: VenueCreateNestedManyWithoutOrganizationInput
    userOrganizations?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Clause?: ClauseCreateNestedManyWithoutOrganizationInput
    Contract?: ContractCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOwnersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutOrganizationInput
    userOrganizations?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Clause?: ClauseUncheckedCreateNestedManyWithoutOrganizationInput
    Contract?: ContractUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOwnersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOwnersInput, OrganizationUncheckedCreateWithoutOwnersInput>
  }

  export type OwnerVenueUpsertWithWhereUniqueWithoutOwnerInput = {
    where: OwnerVenueWhereUniqueInput
    update: XOR<OwnerVenueUpdateWithoutOwnerInput, OwnerVenueUncheckedUpdateWithoutOwnerInput>
    create: XOR<OwnerVenueCreateWithoutOwnerInput, OwnerVenueUncheckedCreateWithoutOwnerInput>
  }

  export type OwnerVenueUpdateWithWhereUniqueWithoutOwnerInput = {
    where: OwnerVenueWhereUniqueInput
    data: XOR<OwnerVenueUpdateWithoutOwnerInput, OwnerVenueUncheckedUpdateWithoutOwnerInput>
  }

  export type OwnerVenueUpdateManyWithWhereWithoutOwnerInput = {
    where: OwnerVenueScalarWhereInput
    data: XOR<OwnerVenueUpdateManyMutationInput, OwnerVenueUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OrganizationUpsertWithoutOwnersInput = {
    update: XOR<OrganizationUpdateWithoutOwnersInput, OrganizationUncheckedUpdateWithoutOwnersInput>
    create: XOR<OrganizationCreateWithoutOwnersInput, OrganizationUncheckedCreateWithoutOwnersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOwnersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOwnersInput, OrganizationUncheckedUpdateWithoutOwnersInput>
  }

  export type OrganizationUpdateWithoutOwnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutOrganizationNestedInput
    userOrganizations?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Clause?: ClauseUpdateManyWithoutOrganizationNestedInput
    Contract?: ContractUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOwnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutOrganizationNestedInput
    userOrganizations?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Clause?: ClauseUncheckedUpdateManyWithoutOrganizationNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type VenueCreateWithoutImagesInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutImagesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutImagesInput, VenueUncheckedCreateWithoutImagesInput>
  }

  export type VenueUpsertWithoutImagesInput = {
    update: XOR<VenueUpdateWithoutImagesInput, VenueUncheckedUpdateWithoutImagesInput>
    create: XOR<VenueCreateWithoutImagesInput, VenueUncheckedCreateWithoutImagesInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutImagesInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutImagesInput, VenueUncheckedUpdateWithoutImagesInput>
  }

  export type VenueUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateWithoutTextsInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    questions?: QuestionCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutTextsInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutTextsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutTextsInput, VenueUncheckedCreateWithoutTextsInput>
  }

  export type VenueUpsertWithoutTextsInput = {
    update: XOR<VenueUpdateWithoutTextsInput, VenueUncheckedUpdateWithoutTextsInput>
    create: XOR<VenueCreateWithoutTextsInput, VenueUncheckedCreateWithoutTextsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutTextsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutTextsInput, VenueUncheckedUpdateWithoutTextsInput>
  }

  export type VenueUpdateWithoutTextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutTextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateWithoutQuestionsInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    organization: OrganizationCreateNestedOneWithoutVenuesInput
    texts?: TextCreateNestedManyWithoutVenueInput
    contacts?: ContactCreateNestedManyWithoutVenueInput
    images?: ImageCreateNestedManyWithoutVenueInput
    expenses?: ExpenseCreateNestedManyWithoutVenueInput
    services?: ServiceCreateNestedManyWithoutVenueInput
    Payment?: PaymentCreateNestedManyWithoutVenueInput
    proposals?: ProposalCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueCreateNestedManyWithoutVenueInput
    notifications?: NotificationCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutQuestionsInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    organizationId: string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
    texts?: TextUncheckedCreateNestedManyWithoutVenueInput
    contacts?: ContactUncheckedCreateNestedManyWithoutVenueInput
    images?: ImageUncheckedCreateNestedManyWithoutVenueInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVenueInput
    services?: ServiceUncheckedCreateNestedManyWithoutVenueInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutVenueInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutVenueInput
    DateEvent?: DateEventUncheckedCreateNestedManyWithoutVenueInput
    ownerVenue?: OwnerVenueUncheckedCreateNestedManyWithoutVenueInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutQuestionsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutQuestionsInput, VenueUncheckedCreateWithoutQuestionsInput>
  }

  export type VenueUpsertWithoutQuestionsInput = {
    update: XOR<VenueUpdateWithoutQuestionsInput, VenueUncheckedUpdateWithoutQuestionsInput>
    create: XOR<VenueCreateWithoutQuestionsInput, VenueUncheckedCreateWithoutQuestionsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutQuestionsInput, VenueUncheckedUpdateWithoutQuestionsInput>
  }

  export type VenueUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    organization?: OrganizationUpdateOneRequiredWithoutVenuesNestedInput
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type OrganizationCreateWithoutContractInput = {
    id?: string
    name: string
    createdAt?: Date | string
    venues?: VenueCreateNestedManyWithoutOrganizationInput
    owners?: OwnerCreateNestedManyWithoutOrganizationInput
    userOrganizations?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Clause?: ClauseCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutContractInput = {
    id?: string
    name: string
    createdAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutOrganizationInput
    owners?: OwnerUncheckedCreateNestedManyWithoutOrganizationInput
    userOrganizations?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Clause?: ClauseUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutContractInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutContractInput, OrganizationUncheckedCreateWithoutContractInput>
  }

  export type ClauseCreateWithoutContractInput = {
    id?: string
    text: string
    title: string
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutClauseInput
  }

  export type ClauseUncheckedCreateWithoutContractInput = {
    id?: string
    text: string
    title: string
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId?: string | null
  }

  export type ClauseCreateOrConnectWithoutContractInput = {
    where: ClauseWhereUniqueInput
    create: XOR<ClauseCreateWithoutContractInput, ClauseUncheckedCreateWithoutContractInput>
  }

  export type ClauseCreateManyContractInputEnvelope = {
    data: ClauseCreateManyContractInput | ClauseCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutContractInput = {
    update: XOR<OrganizationUpdateWithoutContractInput, OrganizationUncheckedUpdateWithoutContractInput>
    create: XOR<OrganizationCreateWithoutContractInput, OrganizationUncheckedCreateWithoutContractInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutContractInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutContractInput, OrganizationUncheckedUpdateWithoutContractInput>
  }

  export type OrganizationUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutOrganizationNestedInput
    owners?: OwnerUpdateManyWithoutOrganizationNestedInput
    userOrganizations?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Clause?: ClauseUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutOrganizationNestedInput
    owners?: OwnerUncheckedUpdateManyWithoutOrganizationNestedInput
    userOrganizations?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Clause?: ClauseUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ClauseUpsertWithWhereUniqueWithoutContractInput = {
    where: ClauseWhereUniqueInput
    update: XOR<ClauseUpdateWithoutContractInput, ClauseUncheckedUpdateWithoutContractInput>
    create: XOR<ClauseCreateWithoutContractInput, ClauseUncheckedCreateWithoutContractInput>
  }

  export type ClauseUpdateWithWhereUniqueWithoutContractInput = {
    where: ClauseWhereUniqueInput
    data: XOR<ClauseUpdateWithoutContractInput, ClauseUncheckedUpdateWithoutContractInput>
  }

  export type ClauseUpdateManyWithWhereWithoutContractInput = {
    where: ClauseScalarWhereInput
    data: XOR<ClauseUpdateManyMutationInput, ClauseUncheckedUpdateManyWithoutContractInput>
  }

  export type OrganizationCreateWithoutClauseInput = {
    id?: string
    name: string
    createdAt?: Date | string
    venues?: VenueCreateNestedManyWithoutOrganizationInput
    owners?: OwnerCreateNestedManyWithoutOrganizationInput
    userOrganizations?: UserOrganizationCreateNestedManyWithoutOrganizationInput
    Contract?: ContractCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutClauseInput = {
    id?: string
    name: string
    createdAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutOrganizationInput
    owners?: OwnerUncheckedCreateNestedManyWithoutOrganizationInput
    userOrganizations?: UserOrganizationUncheckedCreateNestedManyWithoutOrganizationInput
    Contract?: ContractUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutClauseInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutClauseInput, OrganizationUncheckedCreateWithoutClauseInput>
  }

  export type ContractCreateWithoutClausesInput = {
    id?: string
    name: string
    title: string
    organization: OrganizationCreateNestedOneWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutClausesInput = {
    id?: string
    name: string
    title: string
    organizationId: string
  }

  export type ContractCreateOrConnectWithoutClausesInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutClausesInput, ContractUncheckedCreateWithoutClausesInput>
  }

  export type OrganizationUpsertWithoutClauseInput = {
    update: XOR<OrganizationUpdateWithoutClauseInput, OrganizationUncheckedUpdateWithoutClauseInput>
    create: XOR<OrganizationCreateWithoutClauseInput, OrganizationUncheckedCreateWithoutClauseInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutClauseInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutClauseInput, OrganizationUncheckedUpdateWithoutClauseInput>
  }

  export type OrganizationUpdateWithoutClauseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutOrganizationNestedInput
    owners?: OwnerUpdateManyWithoutOrganizationNestedInput
    userOrganizations?: UserOrganizationUpdateManyWithoutOrganizationNestedInput
    Contract?: ContractUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutClauseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutOrganizationNestedInput
    owners?: OwnerUncheckedUpdateManyWithoutOrganizationNestedInput
    userOrganizations?: UserOrganizationUncheckedUpdateManyWithoutOrganizationNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ContractUpsertWithoutClausesInput = {
    update: XOR<ContractUpdateWithoutClausesInput, ContractUncheckedUpdateWithoutClausesInput>
    create: XOR<ContractCreateWithoutClausesInput, ContractUncheckedCreateWithoutClausesInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutClausesInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutClausesInput, ContractUncheckedUpdateWithoutClausesInput>
  }

  export type ContractUpdateWithoutClausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutClausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalCreateWithoutScheduleListInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venue: VenueCreateNestedOneWithoutProposalsInput
    personList?: PersonCreateNestedManyWithoutProposalInput
    histories?: HistoryCreateNestedManyWithoutProposalInput
    payments?: PaymentCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceCreateNestedManyWithoutProposalInput
    noificationList?: NotificationCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutScheduleListInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
    venueId: string
    personList?: PersonUncheckedCreateNestedManyWithoutProposalInput
    histories?: HistoryUncheckedCreateNestedManyWithoutProposalInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProposalInput
    dateEvents?: DateEventUncheckedCreateNestedManyWithoutProposalInput
    proposalCosts?: ProposalCostUncheckedCreateNestedManyWithoutProposalsInput
    proposalServices?: ProposalServiceUncheckedCreateNestedManyWithoutProposalInput
    noificationList?: NotificationUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutScheduleListInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutScheduleListInput, ProposalUncheckedCreateWithoutScheduleListInput>
  }

  export type ProposalUpsertWithoutScheduleListInput = {
    update: XOR<ProposalUpdateWithoutScheduleListInput, ProposalUncheckedUpdateWithoutScheduleListInput>
    create: XOR<ProposalCreateWithoutScheduleListInput, ProposalUncheckedCreateWithoutScheduleListInput>
    where?: ProposalWhereInput
  }

  export type ProposalUpdateToOneWithWhereWithoutScheduleListInput = {
    where?: ProposalWhereInput
    data: XOR<ProposalUpdateWithoutScheduleListInput, ProposalUncheckedUpdateWithoutScheduleListInput>
  }

  export type ProposalUpdateWithoutScheduleListInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venue?: VenueUpdateOneRequiredWithoutProposalsNestedInput
    personList?: PersonUpdateManyWithoutProposalNestedInput
    histories?: HistoryUpdateManyWithoutProposalNestedInput
    payments?: PaymentUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutScheduleListInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
    personList?: PersonUncheckedUpdateManyWithoutProposalNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutProposalNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUncheckedUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUncheckedUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type SessionCreateManyRefreshTokenInput = {
    id?: string
    userId: string
    ipAddress?: string | null
    isValid?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SessionUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    refreshTokenId: string
    ipAddress?: string | null
    isValid?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type HistoryCreateManyUserInput = {
    id?: string
    action: string
    username?: string | null
    proposalId: string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    expireIn: number
    createdAt?: Date | string
  }

  export type UserOrganizationCreateManyUserInput = {
    id?: string
    organizationId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: RefreshTokenUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: ProposalUpdateOneRequiredWithoutHistoriesNestedInput
  }

  export type HistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    proposalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    proposalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expireIn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateManyWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expireIn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUncheckedUpdateManyWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expireIn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUserOrganizationsNestedInput
  }

  export type UserOrganizationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueCreateManyOrganizationInput = {
    id?: string
    name: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    checkIn?: string | null
    checkOut?: string | null
    cep: string
    hasOvernightStay: boolean
    createdAt?: Date | string
    pricingModel: $Enums.PricingModel
    pricePerPerson?: number | null
    pricePerDay?: number | null
    maxGuest: number
  }

  export type OwnerCreateManyOrganizationInput = {
    id?: string
    completeName: string
    rg?: string | null
    cpf: string
    pix: string
    street: string
    streetNumber: string
    complement?: string | null
    neighborhood: string
    city: string
    state: string
    bankName: string
    bankAgency: string
    cep: string
    createdAt?: Date | string
    bankAccountNumber: string
  }

  export type UserOrganizationCreateManyOrganizationInput = {
    id?: string
    userId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type ClauseCreateManyOrganizationInput = {
    id?: string
    text: string
    title: string
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contractId?: string | null
  }

  export type ContractCreateManyOrganizationInput = {
    id?: string
    name: string
    title: string
  }

  export type VenueUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUpdateManyWithoutVenueNestedInput
    contacts?: ContactUpdateManyWithoutVenueNestedInput
    images?: ImageUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUpdateManyWithoutVenueNestedInput
    services?: ServiceUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUpdateManyWithoutVenueNestedInput
    questions?: QuestionUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
    texts?: TextUncheckedUpdateManyWithoutVenueNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutVenueNestedInput
    images?: ImageUncheckedUpdateManyWithoutVenueNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutVenueNestedInput
    services?: ServiceUncheckedUpdateManyWithoutVenueNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutVenueNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVenueNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutVenueNestedInput
    DateEvent?: DateEventUncheckedUpdateManyWithoutVenueNestedInput
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutVenueNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    checkIn?: NullableStringFieldUpdateOperationsInput | string | null
    checkOut?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    hasOvernightStay?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    pricePerPerson?: NullableFloatFieldUpdateOperationsInput | number | null
    pricePerDay?: NullableFloatFieldUpdateOperationsInput | number | null
    maxGuest?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: StringFieldUpdateOperationsInput | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: StringFieldUpdateOperationsInput | string
    pix?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAgency?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    ownerVenue?: OwnerVenueUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: StringFieldUpdateOperationsInput | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: StringFieldUpdateOperationsInput | string
    pix?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAgency?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
    ownerVenue?: OwnerVenueUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: StringFieldUpdateOperationsInput | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: StringFieldUpdateOperationsInput | string
    pix?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankAgency?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccountNumber?: StringFieldUpdateOperationsInput | string
  }

  export type UserOrganizationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserOrganizationsNestedInput
  }

  export type UserOrganizationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrganizationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClauseUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Contract?: ContractUpdateOneWithoutClausesNestedInput
  }

  export type ClauseUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClauseUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    clauses?: ClauseUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    clauses?: ClauseUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type PersonCreateManyProposalInput = {
    id?: string
    attendance?: boolean
    type: $Enums.PersonType
    name: string
    email?: string | null
    rg?: string | null
  }

  export type HistoryCreateManyProposalInput = {
    id?: string
    action: string
    username?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateManyProposalInput = {
    id?: string
    venueId: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
  }

  export type DateEventCreateManyProposalInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    venueId: string
    type: $Enums.DateEventType
  }

  export type ProposalServiceCreateManyProposalInput = {
    id?: string
    serviceId: string
    joinedAt?: Date | string
  }

  export type NotificationCreateManyProposalInput = {
    id?: string
    venueId: string
    dateEventId?: string | null
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
  }

  export type ScheduleCreateManyProposalInput = {
    id?: string
    name: string
    workerNumber: number
    description?: string | null
    startHour: Date | string
    endHour: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistoryUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutHistoriesNestedInput
  }

  export type HistoryUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: VenueUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DateEventUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
    venue?: VenueUpdateOneRequiredWithoutDateEventNestedInput
    notifications?: NotificationUpdateManyWithoutDateEventNestedInput
  }

  export type DateEventUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: StringFieldUpdateOperationsInput | string
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
    notifications?: NotificationUncheckedUpdateManyWithoutDateEventNestedInput
  }

  export type DateEventUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: StringFieldUpdateOperationsInput | string
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
  }

  export type ProposalCostUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumProposalNameFieldUpdateOperationsInput | $Enums.ProposalName
    teste?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCostUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumProposalNameFieldUpdateOperationsInput | $Enums.ProposalName
    teste?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCostUncheckedUpdateManyWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumProposalNameFieldUpdateOperationsInput | $Enums.ProposalName
    teste?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalServiceUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutProposalServicesNestedInput
  }

  export type ProposalServiceUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalServiceUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    venue?: VenueUpdateOneRequiredWithoutNotificationsNestedInput
    dateEvent?: DateEventUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    dateEventId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    dateEventId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ScheduleUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workerNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startHour?: DateTimeFieldUpdateOperationsInput | Date | string
    endHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workerNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startHour?: DateTimeFieldUpdateOperationsInput | Date | string
    endHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workerNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startHour?: DateTimeFieldUpdateOperationsInput | Date | string
    endHour?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalServiceCreateManyServiceInput = {
    id?: string
    proposalId: string
    joinedAt?: Date | string
  }

  export type ProposalServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: ProposalUpdateOneRequiredWithoutProposalServicesNestedInput
  }

  export type ProposalServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUpdateWithoutProposalCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venue?: VenueUpdateOneRequiredWithoutProposalsNestedInput
    personList?: PersonUpdateManyWithoutProposalNestedInput
    histories?: HistoryUpdateManyWithoutProposalNestedInput
    payments?: PaymentUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUpdateManyWithoutProposalNestedInput
    proposalServices?: ProposalServiceUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutProposalCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
    personList?: PersonUncheckedUpdateManyWithoutProposalNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutProposalNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUncheckedUpdateManyWithoutProposalNestedInput
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUncheckedUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateManyWithoutProposalCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    venueId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyDateEventInput = {
    id?: string
    venueId: string
    proposalId?: string | null
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
  }

  export type NotificationUpdateWithoutDateEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    venue?: VenueUpdateOneRequiredWithoutNotificationsNestedInput
    proposal?: ProposalUpdateOneWithoutNoificationListNestedInput
  }

  export type NotificationUncheckedUpdateWithoutDateEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyWithoutDateEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TextCreateManyVenueInput = {
    id?: string
    area: string
    title?: string | null
    position?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyVenueInput = {
    id?: string
    name: string
    role: string
    whatsapp: string
  }

  export type ImageCreateManyVenueInput = {
    id?: string
    imageUrl: string
    description?: string | null
    position: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    responsiveMode?: string | null
    tag?: string | null
  }

  export type ExpenseCreateManyVenueInput = {
    id?: string
    name: string
    description?: string | null
    amount: number
    paymentDate: Date | string
    type: $Enums.ExpenseType
    category: $Enums.ExpenseCategory
    recurring: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateManyVenueInput = {
    id?: string
    name: string
    price: number
  }

  export type PaymentCreateManyVenueInput = {
    id?: string
    proposalId: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imageUrl?: string | null
  }

  export type QuestionCreateManyVenueInput = {
    id?: string
    question: string
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateManyVenueInput = {
    id?: string
    completeName?: string | null
    cpf?: string | null
    rg?: string | null
    street?: string | null
    streetNumber?: string | null
    neighborhood?: string | null
    cep?: string | null
    city?: string | null
    state?: string | null
    type: $Enums.ProposalType
    trafficSource: $Enums.TrafficSource
    guestNumber: number
    knowsVenue?: boolean
    startDate: Date | string
    endDate: Date | string
    name: string
    email: string
    whatsapp: string
    description: string
    basePrice: number
    extraHoursQty: number
    extraHourPrice: number
    totalAmount: number
    termsAccepted?: boolean
    approved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: boolean | null
    paid?: boolean | null
    amountPaid?: number | null
  }

  export type DateEventCreateManyVenueInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalId?: string | null
    type: $Enums.DateEventType
  }

  export type OwnerVenueCreateManyVenueInput = {
    id?: string
    ownerId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type NotificationCreateManyVenueInput = {
    id?: string
    proposalId?: string | null
    dateEventId?: string | null
    content: string
    type: $Enums.NotificationType
    createdAt?: Date | string
    isRead?: boolean
  }

  export type TextUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsiveMode?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsiveMode?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsiveMode?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    recurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    recurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    recurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    proposalServices?: ProposalServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type PaymentUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: ProposalUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    personList?: PersonUpdateManyWithoutProposalNestedInput
    histories?: HistoryUpdateManyWithoutProposalNestedInput
    payments?: PaymentUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    personList?: PersonUncheckedUpdateManyWithoutProposalNestedInput
    histories?: HistoryUncheckedUpdateManyWithoutProposalNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProposalNestedInput
    dateEvents?: DateEventUncheckedUpdateManyWithoutProposalNestedInput
    proposalCosts?: ProposalCostUncheckedUpdateManyWithoutProposalsNestedInput
    proposalServices?: ProposalServiceUncheckedUpdateManyWithoutProposalNestedInput
    noificationList?: NotificationUncheckedUpdateManyWithoutProposalNestedInput
    scheduleList?: ScheduleUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    completeName?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProposalTypeFieldUpdateOperationsInput | $Enums.ProposalType
    trafficSource?: EnumTrafficSourceFieldUpdateOperationsInput | $Enums.TrafficSource
    guestNumber?: IntFieldUpdateOperationsInput | number
    knowsVenue?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraHoursQty?: IntFieldUpdateOperationsInput | number
    extraHourPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DateEventUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
    proposal?: ProposalUpdateOneWithoutDateEventsNestedInput
    notifications?: NotificationUpdateManyWithoutDateEventNestedInput
  }

  export type DateEventUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
    notifications?: NotificationUncheckedUpdateManyWithoutDateEventNestedInput
  }

  export type DateEventUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDateEventTypeFieldUpdateOperationsInput | $Enums.DateEventType
  }

  export type OwnerVenueUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutOwnerVenueNestedInput
  }

  export type OwnerVenueUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerVenueUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    proposal?: ProposalUpdateOneWithoutNoificationListNestedInput
    dateEvent?: DateEventUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    dateEventId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    dateEventId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OwnerVenueCreateManyOwnerInput = {
    id?: string
    venueId: string
    role?: $Enums.Role
    joinedAt?: Date | string
  }

  export type OwnerVenueUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutOwnerVenueNestedInput
  }

  export type OwnerVenueUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerVenueUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClauseCreateManyContractInput = {
    id?: string
    text: string
    title: string
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId?: string | null
  }

  export type ClauseUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutClauseNestedInput
  }

  export type ClauseUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClauseUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use RefreshTokenCountOutputTypeDefaultArgs instead
     */
    export type RefreshTokenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProposalCountOutputTypeDefaultArgs instead
     */
    export type ProposalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProposalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProposalCostCountOutputTypeDefaultArgs instead
     */
    export type ProposalCostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProposalCostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DateEventCountOutputTypeDefaultArgs instead
     */
    export type DateEventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DateEventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenueCountOutputTypeDefaultArgs instead
     */
    export type VenueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerCountOutputTypeDefaultArgs instead
     */
    export type OwnerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractCountOutputTypeDefaultArgs instead
     */
    export type ContractCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserOrganizationDefaultArgs instead
     */
    export type UserOrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserOrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProposalDefaultArgs instead
     */
    export type ProposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProposalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HistoryDefaultArgs instead
     */
    export type HistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonDefaultArgs instead
     */
    export type PersonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProposalServiceDefaultArgs instead
     */
    export type ProposalServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProposalServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProposalCostDefaultArgs instead
     */
    export type ProposalCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProposalCostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DateEventDefaultArgs instead
     */
    export type DateEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DateEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenueDefaultArgs instead
     */
    export type VenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerVenueDefaultArgs instead
     */
    export type OwnerVenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerVenueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerDefaultArgs instead
     */
    export type OwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImageDefaultArgs instead
     */
    export type ImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TextDefaultArgs instead
     */
    export type TextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TextDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionDefaultArgs instead
     */
    export type QuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractDefaultArgs instead
     */
    export type ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClauseDefaultArgs instead
     */
    export type ClauseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClauseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduleDefaultArgs instead
     */
    export type ScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduleDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}